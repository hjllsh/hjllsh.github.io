{"total":70,"pageSize":12,"pageCount":6,"data":[{"title":"Lambda表达式","uid":"32a652994e7e566383677d79f35d7c59","slug":"Lambda表达式","date":"2023-06-10T07:21:11.000Z","updated":"2023-06-10T15:16:34.349Z","comments":true,"path":"api/articles/Lambda表达式.json","cover":[],"text":"函数式编程思想函数式编程思想类似于我们数学中的函数，它主要关注的是对数据进行了什么操作。 优点： 代码简洁，开发快速 接近自然语言，易于理解 易于“并发编程” Lambda表达式Lambda是JDK8中一个语法糖，它可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Lambda","slug":"Lambda","count":1,"path":"api/tags/Lambda.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"接口优化技巧","uid":"a4984df6ed448f92b70760ecd7f1272b","slug":"接口优化技巧","date":"2023-06-10T06:32:07.000Z","updated":"2023-06-10T15:19:21.407Z","comments":true,"path":"api/articles/接口优化技巧.json","cover":[],"text":"接口优化的通用方案 1.批处理批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。 //for循环单笔入库 list.stream().forEatch(msg->&#123; insert(); &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"优化","slug":"优化","count":1,"path":"api/tags/优化.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"进程与线程","uid":"89180d8ad200729090513c1ce4f6ad31","slug":"进程与线程","date":"2023-06-09T12:37:40.000Z","updated":"2023-06-09T12:37:40.138Z","comments":true,"path":"api/articles/进程与线程.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"微服务-基础","uid":"cbf42b2f3cbb0eee5de5bbaaf2ed03ea","slug":"微服务-基础","date":"2023-06-09T08:53:51.000Z","updated":"2023-06-09T12:36:14.429Z","comments":true,"path":"api/articles/微服务-基础.json","cover":[],"text":"Nacos配置管理Nacos除了可以做注册中心，同样可以做配置管理来使用。 统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。 Nacos一方面可以将配置集中管理，另...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"RabbitMQ","uid":"eb3ef2175aab37a16c1ed443702f7a7d","slug":"RabbitMQ-基础","date":"2023-06-08T14:02:31.000Z","updated":"2023-06-10T15:33:25.442Z","comments":true,"path":"api/articles/RabbitMQ-基础.json","cover":[],"text":"RabbitMQ一篇就够了同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。 同步通讯存在下面的问题： 总结： 同步调用的优点： 时效性较强，可以立即得到结果 同步调用的问题： 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 异步通讯异步...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","count":1,"path":"api/tags/RabbitMQ.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"微服务_入门","uid":"fe3fb8c55b48b7e212cb33aae1728c63","slug":"微服务-入门","date":"2023-06-08T09:44:27.000Z","updated":"2023-06-10T15:48:11.230Z","comments":true,"path":"api/articles/微服务-入门.json","cover":[],"text":"认识微服务单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2023-06-07T11:42:20.000Z","updated":"2023-06-07T13:31:41.753Z","comments":true,"path":"api/articles/线程池.json","cover":[],"text":"Executor线程池在Java框架设计中，一般涉及到资源相关的，并且资源具有创建消耗大、可复用的特点时，都采用了池化技术管理资源，形成一个“资源池”，池化技术可以带来以下一般性好处：对外部隐藏了资源的创建与释放的细节、实现资源的复用减少内存或者时间性能开销。常见Java中池化技...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Java集合高频考点","uid":"19e0c7830137ba378427a6cdcb7fc021","slug":"Java集合高频考点","date":"2023-06-06T04:20:49.000Z","updated":"2023-06-07T11:08:27.946Z","comments":true,"path":"api/articles/Java集合高频考点.json","cover":[],"text":"1. 常见的集合有哪些？Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意：Col...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-用户签到_UV统计","uid":"37c665cf8e0e08ae6a11b540ba094729","slug":"Redis实战-用户签到","date":"2023-06-06T02:48:05.000Z","updated":"2023-06-06T03:25:10.077Z","comments":true,"path":"api/articles/Redis实战-用户签到.json","cover":[],"text":"用户签到用户签到-BitMap功能演示我们针对签到功能完全可以通过mysql来完成，比如说以下这张表 用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-附近商户","uid":"9da38b0fade8e3816513eac32a87f012","slug":"Redis实战-附近商户","date":"2023-06-06T02:39:30.000Z","updated":"2023-06-06T02:52:37.410Z","comments":true,"path":"api/articles/Redis实战-附近商户.json","cover":[],"text":"附近商户附近商户-GEO数据结构的基本用法GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有： GEOADD：添加一个地理空间信息，包含：经度（longitude...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-好友关注","uid":"aa18ca8bbe4604cca91aa58ef474fe02","slug":"Redis实战-好友关注","date":"2023-06-06T01:49:53.000Z","updated":"2023-06-06T02:38:59.381Z","comments":true,"path":"api/articles/Redis实战-好友关注.json","cover":[],"text":"好友关注好友关注-关注和取消关注针对用户的操作：可以对用户进行关注和取消关注功能。 实现思路： 需求：基于该表数据结构，实现两个接口： 关注和取关接口 判断是否关注的接口 关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示： 注意: 这里需要把...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-点赞排行榜","uid":"6b1fcf8efc840ca23645e7afc15b96ff","slug":"Redis实战-点赞排行榜","date":"2023-06-06T01:30:08.000Z","updated":"2023-06-06T01:48:55.161Z","comments":true,"path":"api/articles/Redis实战-点赞排行榜.json","cover":[],"text":"点赞排行榜点赞功能初始代码 @GetMapping(\"/likes/&#123;id&#125;\") public Result queryBlogLikes(@PathVariable(\"id\") Long id) &#123; //修改点赞数量 blogService.upd...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}]}