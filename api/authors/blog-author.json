{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}},"post_list":[{"title":"SpringTask实现定时任务","uid":"34f154820ac35e3d8f3e9afce6bf7431","slug":"SpringTask实现定时任务","date":"2023-05-31T02:51:56.000Z","updated":"2023-05-31T08:12:18.441Z","comments":true,"path":"api/articles/SpringTask实现定时任务.json","keywords":null,"cover":null,"text":"SpringTask SpringTask是Spring自主研发的轻量级定时任务工具，相比于Quartz更加简单方便，且不需要引入其他依赖即可使用。 Cron表达式 Cron表达式是一个字符串，包括6~7个时间元素，在SpringTask中可以用于指定任务的执行时间。 Cron的...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"SpringTask","slug":"SpringTask","count":1,"path":"api/tags/SpringTask.json"},{"name":"定时任务","slug":"定时任务","count":1,"path":"api/tags/定时任务.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"线程池异常日志处理","uid":"c03c4f80044b1216d3d7a05319a58324","slug":"线程池异常日志处理","date":"2023-05-30T12:43:04.000Z","updated":"2023-05-30T13:13:27.663Z","comments":true,"path":"api/articles/线程池异常日志处理.json","keywords":null,"cover":null,"text":"线程池异常日志处理线程池是作为池化技术的一种常见应用 先定义一个线程池实例 @Bean public ThreadPoolExecutor uncaughtExceptionExecutor() &#123; ThreadFactory threadFactory = new T...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"SpringSecurity和JWT实现认证授权","uid":"2e24c73ebcb94047e46d06be7faec991","slug":"SpringSecurity和JWT实现认证授权","date":"2023-05-30T02:49:20.000Z","updated":"2023-05-31T02:48:51.996Z","comments":true,"path":"api/articles/SpringSecurity和JWT实现认证授权.json","keywords":null,"cover":null,"text":"SpringSecurity和JWT实现认证授权在pom.xml中添加项目依赖&lt;!--SpringSecurity依赖配置--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;ar...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":2,"path":"api/tags/认证授权.json"},{"name":"SpringSecurity","slug":"SpringSecurity","count":1,"path":"api/tags/SpringSecurity.json"},{"name":"JWT","slug":"JWT","count":1,"path":"api/tags/JWT.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"SpringBoot中自定义注解","uid":"d706fd469eec284e90755d9abf2cccf2","slug":"SpringBoot中自定义注解","date":"2023-05-29T14:05:15.000Z","updated":"2023-05-29T14:06:30.891Z","comments":true,"path":"api/articles/SpringBoot中自定义注解.json","keywords":null,"cover":null,"text":"SpringBoot中自定义注解","link":"","photos":[],"count_time":{"symbolsCount":16,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"注解","slug":"注解","count":1,"path":"api/tags/注解.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Netty进阶","uid":"6ee3eede71e00c52eb0546cb31634cea","slug":"Netty进阶","date":"2023-05-27T12:51:09.000Z","updated":"2023-05-27T14:06:53.250Z","comments":true,"path":"api/articles/Netty进阶.json","keywords":null,"cover":[],"text":"粘包与半包服务端代码 public class HelloWorldServer &#123; static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class); void start() &#12...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Netty基础","uid":"50b6ca39b1c5fcfd54bce8129993cbda","slug":"Netty基础","date":"2023-05-26T02:36:45.000Z","updated":"2023-05-26T11:58:35.057Z","comments":true,"path":"api/articles/Netty基础.json","keywords":null,"cover":[],"text":"Netty 概述Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端 Netty 的优势 Netty vs NIO，工作量大，bug 多 需要自己构建协议 解决 TCP 传输问题，如粘包、半包 epoll 空轮询导致 CPU 100...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2023-05-25T02:38:47.000Z","updated":"2023-05-25T15:12:11.103Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"NIO 基础non-blocking io 非阻塞 IO三大组件Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之...","link":"","photos":[],"count_time":{"symbolsCount":"47k","symbolsTime":"43 mins."},"categories":[],"tags":[{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2023-05-24T11:24:04.000Z","updated":"2023-05-24T12:33:11.159Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":[],"text":"Docker的用途Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Dock...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"SQL优化","uid":"f515c75be93536d047fb1ea7dd55160d","slug":"SQL优化","date":"2023-05-23T13:48:45.000Z","updated":"2023-05-23T15:55:25.049Z","comments":true,"path":"api/articles/SQL优化.json","keywords":null,"cover":null,"text":"SQL优化插入数据insert 如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。 优化方案一 批量插入数据 Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerr...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring MVC","uid":"84c6604e94d88eec227a0b74aad54f6e","slug":"Spring-MVC","date":"2023-05-20T12:40:51.000Z","updated":"2023-05-20T12:44:54.770Z","comments":true,"path":"api/articles/Spring-MVC.json","keywords":null,"cover":null,"text":"Spring MVCWebMvcConfigurerWebMvcConfigurer是一个Spring MVC的配置接口，它提供了一些方法来进行各种配置。WebConfig类实现了这个接口，因此可以利用这些方法来配置应用程序。例如：addInterceptors()：用于添加拦截...","link":"","photos":[],"count_time":{"symbolsCount":370,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Spring MVC","slug":"Spring-MVC","count":1,"path":"api/tags/Spring-MVC.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"InnoDB存储引擎_MVCC原理","uid":"12e6f0c825691db3e38970eadda0c57d","slug":"InnoDB存储引擎-MVCC原理","date":"2023-05-20T02:00:56.000Z","updated":"2023-05-20T09:10:10.924Z","comments":true,"path":"api/articles/InnoDB存储引擎-MVCC原理.json","keywords":null,"cover":[],"text":"InnoDB引擎逻辑存储结构InnoDB的逻辑存储结构如下图所示: 表空间 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_锁","uid":"083e3a4ebfcb19d327b53b7d73aaddd3","slug":"MySQL-锁","date":"2023-05-19T01:39:57.000Z","updated":"2023-05-19T15:44:11.108Z","comments":true,"path":"api/articles/MySQL-锁.json","keywords":null,"cover":[],"text":"锁​ 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"基于session实现认证","uid":"7a80ec680e8c46b9ee58692b58f8ab63","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","updated":"2023-05-18T16:15:24.710Z","comments":true,"path":"api/articles/基于session实现认证.json","keywords":null,"cover":[],"text":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。 什么是会话用户认证通过后，为了避免用户的每...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":2,"path":"api/tags/认证授权.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_存储引擎_索引","uid":"ca0fb70bccc39b11cac4043db766085d","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","updated":"2023-05-23T13:47:20.934Z","comments":true,"path":"api/articles/MySQL-存储引擎-索引.json","keywords":null,"cover":[],"text":"MySQL存储引擎MySQL体系结构 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"MySQL-事务","date":"2023-05-17T13:51:38.000Z","updated":"2023-05-18T03:11:52.678Z","comments":true,"path":"api/articles/MySQL-事务.json","keywords":null,"cover":[],"text":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。 事务操作未控制事...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_约束_多表查询","uid":"f293b2fcfae54b8509d50db2914ed7a0","slug":"MySQL-约束-多表联查","date":"2023-05-16T13:40:42.000Z","updated":"2023-05-17T13:50:48.431Z","comments":true,"path":"api/articles/MySQL-约束-多表联查.json","keywords":null,"cover":[],"text":"约束概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。 目的：保证数据库中数据的正确、有效性和完整性。 约束 描述 关键词 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DCL_函数","uid":"8f9e88b96addebc57d8b075bdae2d985","slug":"MySQL-DCL-函数","date":"2023-05-16T08:56:15.000Z","updated":"2023-05-18T02:45:07.908Z","comments":true,"path":"api/articles/MySQL-DCL-函数.json","keywords":null,"cover":[],"text":"DCLData Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。 管理用户查询用户 select * from mysql.user; 其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"状态模式","uid":"b886b366f3cb34006709f66f49ec6b62","slug":"状态模式","date":"2023-05-15T10:11:38.000Z","updated":"2023-05-15T11:53:16.531Z","comments":true,"path":"api/articles/状态模式.json","keywords":null,"cover":null,"text":"状态模式它将对象的行为与其内部状态分离开来，使得对象可以根据其内部状态的变化而改变其行为。状态模式通过将状态的切换封装在状态类中，使得状态转换具有可扩展性和灵活性，并避免了由于状态转换所带来的“if-else”嵌套过多的问题。 状态模式的基本机制是将状态抽象为一个接口或者抽象类，...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"迭代器模式","uid":"ab4a664e2e3638cd67bb057e6ee644aa","slug":"迭代器模式","date":"2023-05-15T09:44:26.000Z","updated":"2023-05-15T10:07:39.257Z","comments":true,"path":"api/articles/迭代器模式.json","keywords":null,"cover":null,"text":"迭代器模式它提供一种方便的方式来访问并遍历集合对象的元素，而无需暴露集合的内部表示。该模式将遍历集合的过程与集合的实现分离开来，使得可以在不影响客户端代码的情况下更改集合的内部实现。 迭代器模式包括以下几个元素： 1.迭代器接口（Iterator）：定义了用于访问和遍历集合元素的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"命令模式","uid":"35b7e7d45f0bf660fac88351c60754e3","slug":"命令模式","date":"2023-05-15T09:17:29.000Z","updated":"2023-05-15T09:43:43.625Z","comments":true,"path":"api/articles/命令模式.json","keywords":null,"cover":null,"text":"命令模式它允许将请求封装为对象，从而使得请求的发送者和接收者解耦，同时可实现请求的队列化、撤销和恢复。 该模式的关键点是将请求与实现解耦并引入命令对象，以便将请求发送给不同的对象，并可随时进行撤销和恢复。通常情况下，命令对象包含执行请求的接收者、请求数据以及实现该请求的方法。 命...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"访问者模式","uid":"d75c20296e97428894e8c62bab0f606e","slug":"访问者模式","date":"2023-05-15T08:21:18.000Z","updated":"2023-05-15T09:16:11.083Z","comments":true,"path":"api/articles/访问者模式.json","keywords":null,"cover":null,"text":"访问者模式它将算法封装到独立的对象中，使其可以在不修改现有对象结构的情况下增加新的操作。访问者模式的核心思想是在被访问的对象上定义一个接受访问者对象的接口，然后访问者对象通过该接口访问被访问对象。这样可以使得被访问对象保持稳定，而访问者对象可以根据需要进行扩展。 访问者模式包含以...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"中介者模式","uid":"ba45023a93415880bd8ff889992600c8","slug":"中介者模式","date":"2023-05-15T07:45:06.000Z","updated":"2023-05-15T08:20:29.485Z","comments":true,"path":"api/articles/中介者模式.json","keywords":null,"cover":null,"text":"中介者模式它的作用是减少对象之间的直接耦合关系，通过引入一个中介者对象来协调多个对象之间的交互行为，从而将系统中复杂的网状关系变为简单的星型结构。 中介者模式的机制基于以下两个关键点： 抽象中介者（Mediator）：为了把各同事类的耦合度降到最低，将对象间通信的控制交给一个中介...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DQL","uid":"4fe76f7b940933ddf5de5f39814faa1c","slug":"MySQL-DQL","date":"2023-05-14T06:22:31.000Z","updated":"2023-05-16T08:55:45.033Z","comments":true,"path":"api/articles/MySQL-DQL.json","keywords":null,"cover":[],"text":"DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录 基本语法DQL 查询语句，语法结构如下： SELET 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DML","uid":"676b4ad0d6495672245716dc73cc8c9e","slug":"MySQL-DML","date":"2023-05-14T01:30:25.000Z","updated":"2023-05-14T08:04:28.656Z","comments":true,"path":"api/articles/MySQL-DML.json","keywords":null,"cover":null,"text":"DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。 添加数据 给指定字段添加数据 INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...); 案例:...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DDL_Linux","uid":"56fbe19991b11dc0bb9030f36adcdf92","slug":"MySQL-DDL","date":"2023-05-13T10:36:19.000Z","updated":"2023-05-14T15:28:23.957Z","comments":true,"path":"api/articles/MySQL-DDL.json","keywords":null,"cover":null,"text":"启动MySQL服务启动mysql服务 systemctl start mysqld 重启mysql服务 systemctl restart mysqld 停止mysql服务 systemctl stop mysqld 查询首次安装数据库自动生成的root密码grep 'tempo...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"},{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring Bean的生命周期","uid":"b847fc9b240aefdbf95225a3e7dc9026","slug":"Spring Bean的生命周期","date":"2023-05-13T04:32:54.000Z","updated":"2023-05-13T08:18:53.223Z","comments":true,"path":"api/articles/Spring Bean的生命周期.json","keywords":null,"cover":null,"text":"Spring Bean的生命周期getBean方法都会调用doGetBean的逻辑 public &lt;T> T getBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object... args)...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring refresh流程","uid":"ec47f8662f4dbcb9ad26f0a7bcc5e407","slug":"Spring-refresh流程","date":"2023-05-13T01:19:52.000Z","updated":"2023-05-18T02:31:56.825Z","comments":true,"path":"api/articles/Spring-refresh流程.json","keywords":null,"cover":[],"text":"refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤： pre...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring如何解决循环依赖","uid":"2846594611fd32071ec8e1a72cd8f17d","slug":"Spring如何解决循环依赖","date":"2023-05-11T13:26:38.000Z","updated":"2023-05-13T09:55:27.202Z","comments":true,"path":"api/articles/Spring如何解决循环依赖.json","keywords":null,"cover":[],"text":"Spring如何解决循环依赖解决Set循环依赖注入Spring一级缓存singletonObjects singletonObjects是一级缓存，用于存储单例Bean的实例对象。也就是说，当Spring容器创建一个单例Bean时，会将该Bean的实例对象放入一级缓存中，在后续使...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"代理的创建时机","uid":"a685b627e4865e5f328e43bd436e0d9e","slug":"代理的创建时机","date":"2023-05-11T12:55:58.000Z","updated":"2023-05-11T13:36:21.626Z","comments":true,"path":"api/articles/代理的创建时机.json","keywords":null,"cover":null,"text":"代理的创建时机代理的创建时机 创建 -&gt; ( * ) 依赖注入 -&gt; 初始化 ( * ) 初始化之后 (无循环依赖时) 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存 public class A17_1 &#123; public static vo...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Proxy","slug":"Proxy","count":2,"path":"api/tags/Proxy.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"从@Aspect到Advisor","uid":"a95318a81b0b3097ed11bab255c7390f","slug":"从@Aspect到Advisor","date":"2023-05-11T12:04:08.000Z","updated":"2023-05-11T13:38:30.919Z","comments":true,"path":"api/articles/从@Aspect到Advisor.json","keywords":null,"cover":null,"text":"@Aspect—&gt;&gt;AdvisorAnnotationAwareAspectJAutoProxyCreator AnnotationAwareAspectJAutoProxyCreator的作用是将高级切面转换成低级切面，使其能够被Spring框架所识别和使用。具体来...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"切点匹配规则","uid":"d3cf2f31cfa6170a433ba0c99bf2326a","slug":"切点匹配规则","date":"2023-05-11T09:35:15.000Z","updated":"2023-05-11T12:02:12.278Z","comments":true,"path":"api/articles/切点匹配规则.json","keywords":null,"cover":null,"text":"切点匹配规则AspectJ使用切点指示器（Pointcut Designator）来描述需要匹配的切点，切点指示器定义了切点的名称、参数、返回类型、标注等信息。切点指示器可以根据需要使用通配符、逻辑运算符、正则表达式等方式来描述切点。 AspectJ中的切点指示符主要分为以下几种...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"JDK和CGlib在Spring中的统一","uid":"42403d33a4a316854760bf766fee144b","slug":"JDK和CGlib在Spring中的统一","date":"2023-05-11T05:01:11.000Z","updated":"2023-05-11T10:00:53.217Z","comments":true,"path":"api/articles/JDK和CGlib在Spring中的统一.json","keywords":null,"cover":null,"text":"JDK和CGlib在Spring中的统一Spring 中对切点、通知、切面的抽象如下 切点：接口 Pointcut，典型实现 AspectJExpressionPointcut 通知：典型接口为 MethodInterceptor 代表环绕通知 切面：Advisor，包含一个 A...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Proxy","slug":"Proxy","count":2,"path":"api/tags/Proxy.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","updated":"2023-05-11T05:18:39.984Z","comments":true,"path":"api/articles/AOP实现之proxy.json","keywords":null,"cover":[],"text":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags: AOP Spring Java AOP实现之proxyjdk动态代理 动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。 ...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"AOP实现之agent类加载","uid":"d7e2802c58918040c31b14740192f666","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","updated":"2023-05-10T08:39:08.324Z","comments":true,"path":"api/articles/AOP实现之agent类加载.json","keywords":null,"cover":null,"text":"AOP实现之agent类加载","link":"","photos":[],"count_time":{"symbolsCount":14,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"AOP","slug":"AOP","count":1,"path":"api/tags/AOP.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"模板方法的设计模式","uid":"594a23198fd2599edc1d35598ede3148","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","updated":"2023-05-09T14:04:17.842Z","comments":true,"path":"api/articles/模板方法模式.json","keywords":null,"cover":null,"text":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。 模板方法设计模式的优点 将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。 通过把通用方法提取到抽象类中，避免了重复代码的出现，...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"策略模式","uid":"8ced7c3b7dad33d06ee59bde7028cd4a","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","updated":"2023-05-09T13:33:40.042Z","comments":true,"path":"api/articles/策略模式.json","keywords":null,"cover":null,"text":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。 在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。 优点 封装了一系列算法：将一系列...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"观察者模式","uid":"cd55e9d94b94ab2ca447027ce4beeca6","slug":"观察者模式","date":"2023-05-09T12:47:06.000Z","updated":"2023-05-09T13:07:55.500Z","comments":true,"path":"api/articles/观察者模式.json","keywords":null,"cover":null,"text":"观察者模式它允许一个对象（称为被观察者或主题）维护一组依赖于它的对象（称为观察者），当被观察者发生变化时，它会通知所有观察者以便更新它们自己的状态。 优点： 在观察者模式中，被观察者和观察者之间是松耦合的关系，使得它们之间的交互变得简单而灵活。 观察者模式支持广播通信，当一个对象...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"责任链模式","uid":"2b09bf65e737f820cf301fb7434c8c8e","slug":"责任链模式","date":"2023-05-09T12:16:17.000Z","updated":"2023-05-09T12:38:56.430Z","comments":true,"path":"api/articles/责任链模式.json","keywords":null,"cover":null,"text":"责任链模式责任链模式是一种行为设计模式，用于将请求从一个处理程序传递到另一个处理程序，直到找到能够处理请求的处理程序。每个处理程序都将请求传递给下一个处理程序，直到请求被处理为止。 责任链模式的特点 请求发送者不必知道请求在何时、何处以及如何被处理。 可以动态增加或修改请求的处理...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"代理模式","uid":"424f199f6c88af138e76cfdf85fb4fa5","slug":"代理模式","date":"2023-05-09T11:52:50.000Z","updated":"2023-05-09T11:58:21.290Z","comments":true,"path":"api/articles/代理模式.json","keywords":null,"cover":null,"text":"代理模式它为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，可以进行一些附加的工作，例如访问控制、远程访问、缓存等。 以下是一个简单的代理模式的Java例子：interface Image &#123; void display(); &#...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"装饰器模式","uid":"af957b16e3777023cafc3b1e9179b2cd","slug":"装饰器模式","date":"2023-05-09T11:12:05.000Z","updated":"2023-05-09T11:42:05.537Z","comments":true,"path":"api/articles/装饰器模式.json","keywords":null,"cover":null,"text":"装饰器模式装饰者模式（Decorator Pattern） ​ 它允许你向现有对象添加新的功能，同时又不改变其结构。装饰者模式的核心思想是将功能进行分离，让各个类只专注于自己的职责。通过这种方式，我们可以以非常灵活的方式扩展系统的功能，而不必修改原有代码。 ​ 装饰器模式的主要目...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"组合模式","uid":"890198f3e29403fa2d961081f54ed8cd","slug":"组合模式","date":"2023-05-09T10:42:25.000Z","updated":"2023-05-09T11:00:22.048Z","comments":true,"path":"api/articles/组合模式.json","keywords":null,"cover":null,"text":"组合模式组合模式 主要通过将对象组合成树形结构来表示“整体-部分”的关系，让客户端能够以一致的方式对待单个对象和对象合。 下面是一个简单的例子import java.util.ArrayList; import java.util.List; public interface E...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"适配器模式","uid":"a8b2eb4f810dce05fcecb16e8edfd126","slug":"适配器模式","date":"2023-05-09T08:09:59.000Z","updated":"2023-05-09T09:08:48.890Z","comments":true,"path":"api/articles/适配器模式.json","keywords":null,"cover":null,"text":"适配器模式适配器模式（Adapter Pattern）是一种结构型设计模式，它用于将一个类的接口转换成客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作。在适配器模式中，适配器充当了两个不兼容接口之间的桥梁，它负责允许这些接口间能够相互协作。 在Java中，适配器模式常...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"工厂模式","uid":"3dbdc722104d94fc07273118e255f7fd","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","updated":"2023-05-09T07:00:21.428Z","comments":true,"path":"api/articles/工厂模式.json","keywords":null,"cover":[],"text":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数 简单工厂UML类图 适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。 简单工厂的例子: Ca...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"建造者模式","uid":"b00cac0eae3b04411014ea36945005af","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","updated":"2023-05-09T04:53:43.979Z","comments":true,"path":"api/articles/建造者模式.json","keywords":null,"cover":null,"text":"Java建造者模式Java中的建造者模式(Builder Pattern) 主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。 该模式包含以下几个角色： Builder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。 Concrete...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"spring中常见的设计模式","uid":"0c6e8405652937a86cc3782f838cf782","slug":"Spring中的设计模式","date":"2023-05-09T04:00:50.000Z","updated":"2023-05-18T02:32:40.385Z","comments":true,"path":"api/articles/Spring中的设计模式.json","keywords":null,"cover":null,"text":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别 根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it 就是确...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"单例模式","uid":"5e422a9b2c69bd7294ec71b84cbbb53b","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","updated":"2023-05-08T15:15:46.818Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":"/img/5.8.jpg","text":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":17,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"spring事务失效的情况以及注意事项","uid":"064fd1f961f785b45ddfca5b3ce563ee","slug":"Spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","updated":"2023-05-18T02:32:28.591Z","comments":true,"path":"api/articles/Spring事务失效的情况以及注意事项.json","keywords":null,"cover":"/img/5.7.jpg","text":"什么是spring事务？​ Spring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。 ​ Sp...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"How to use Hexo","uid":"94364c933b9df4578d2492ddcb35178f","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","updated":"2023-05-09T04:37:24.253Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":419,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}],"categories":0,"tags":0,"word_count":"382k","post_count":48}