{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}},"post_list":[{"title":"MySQL实战","uid":"11fe232dbef934e03d9537a3a12675e0","slug":"MySQL-实战(1)","date":"2023-06-14T07:25:58.000Z","updated":"2023-06-14T13:13:20.284Z","comments":true,"path":"api/articles/MySQL-实战(1).json","keywords":null,"cover":[],"text":"不建议使用长事务假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"Mybatis(一)","uid":"9f1c39845db12e0e40a2bf8f9721b61a","slug":"Mybatis(1)","date":"2023-06-14T02:03:59.000Z","updated":"2023-06-14T13:16:35.005Z","comments":true,"path":"api/articles/Mybatis(1).json","keywords":null,"cover":[],"text":"MybatisMyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几 乎所有的 JDBC 代码和手动设置参数以及 获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"MySQL日志系统","uid":"1442087dfdabdc07946399fb7094e2fa","slug":"MySQL日志系统","date":"2023-06-11T04:33:43.000Z","updated":"2023-06-14T07:25:30.255Z","comments":true,"path":"api/articles/MySQL日志系统.json","keywords":null,"cover":[],"text":"MySQL的基本架构比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时： mysql> select * from T where ID=10； MySQL内部的执行过程MySQL的基本架构示意图 大体来说，MySQL可以分为Server层和存储引擎层两部分。...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},{"title":"Lambda表达式","uid":"32a652994e7e566383677d79f35d7c59","slug":"Lambda表达式","date":"2023-06-10T07:21:11.000Z","updated":"2023-06-10T15:16:34.349Z","comments":true,"path":"api/articles/Lambda表达式.json","keywords":null,"cover":[],"text":"函数式编程思想函数式编程思想类似于我们数学中的函数，它主要关注的是对数据进行了什么操作。 优点： 代码简洁，开发快速 接近自然语言，易于理解 易于“并发编程” Lambda表达式Lambda是JDK8中一个语法糖，它可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Lambda","slug":"Lambda","count":1,"path":"api/tags/Lambda.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"接口优化技巧","uid":"a4984df6ed448f92b70760ecd7f1272b","slug":"接口优化技巧","date":"2023-06-10T06:32:07.000Z","updated":"2023-06-10T15:19:21.407Z","comments":true,"path":"api/articles/接口优化技巧.json","keywords":null,"cover":[],"text":"接口优化的通用方案 1.批处理批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。 //for循环单笔入库 list.stream().forEatch(msg->&#123; insert(); &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"优化","slug":"优化","count":1,"path":"api/tags/优化.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"进程与线程","uid":"89180d8ad200729090513c1ce4f6ad31","slug":"进程与线程","date":"2023-06-09T12:37:40.000Z","updated":"2023-06-12T16:50:49.421Z","comments":true,"path":"api/articles/进程与线程.json","keywords":null,"cover":[],"text":"进程与线程进程程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"微服务-基础","uid":"cbf42b2f3cbb0eee5de5bbaaf2ed03ea","slug":"微服务-基础","date":"2023-06-09T08:53:51.000Z","updated":"2023-06-10T15:55:32.177Z","comments":true,"path":"api/articles/微服务-基础.json","keywords":null,"cover":[],"text":"Nacos配置管理Nacos除了可以做注册中心，同样可以做配置管理来使用。 统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。 Nacos一方面可以将配置集中管理，另...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"RabbitMQ","uid":"eb3ef2175aab37a16c1ed443702f7a7d","slug":"RabbitMQ-基础","date":"2023-06-08T14:02:31.000Z","updated":"2023-06-10T15:33:25.442Z","comments":true,"path":"api/articles/RabbitMQ-基础.json","keywords":null,"cover":[],"text":"RabbitMQ一篇就够了同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。 同步通讯存在下面的问题： 总结： 同步调用的优点： 时效性较强，可以立即得到结果 同步调用的问题： 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 异步通讯异步...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","count":1,"path":"api/tags/RabbitMQ.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"微服务_入门","uid":"fe3fb8c55b48b7e212cb33aae1728c63","slug":"微服务-入门","date":"2023-06-08T09:44:27.000Z","updated":"2023-06-10T15:48:11.230Z","comments":true,"path":"api/articles/微服务-入门.json","keywords":null,"cover":[],"text":"认识微服务单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2023-06-07T11:42:20.000Z","updated":"2023-06-07T13:31:41.753Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":[],"text":"Executor线程池在Java框架设计中，一般涉及到资源相关的，并且资源具有创建消耗大、可复用的特点时，都采用了池化技术管理资源，形成一个“资源池”，池化技术可以带来以下一般性好处：对外部隐藏了资源的创建与释放的细节、实现资源的复用减少内存或者时间性能开销。常见Java中池化技...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Java集合高频考点","uid":"19e0c7830137ba378427a6cdcb7fc021","slug":"Java集合高频考点","date":"2023-06-06T04:20:49.000Z","updated":"2023-06-07T11:08:27.946Z","comments":true,"path":"api/articles/Java集合高频考点.json","keywords":null,"cover":[],"text":"1. 常见的集合有哪些？Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意：Col...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-用户签到_UV统计","uid":"37c665cf8e0e08ae6a11b540ba094729","slug":"Redis实战-用户签到","date":"2023-06-06T02:48:05.000Z","updated":"2023-06-06T03:25:10.077Z","comments":true,"path":"api/articles/Redis实战-用户签到.json","keywords":null,"cover":[],"text":"用户签到用户签到-BitMap功能演示我们针对签到功能完全可以通过mysql来完成，比如说以下这张表 用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-附近商户","uid":"9da38b0fade8e3816513eac32a87f012","slug":"Redis实战-附近商户","date":"2023-06-06T02:39:30.000Z","updated":"2023-06-06T02:52:37.410Z","comments":true,"path":"api/articles/Redis实战-附近商户.json","keywords":null,"cover":[],"text":"附近商户附近商户-GEO数据结构的基本用法GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有： GEOADD：添加一个地理空间信息，包含：经度（longitude...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-好友关注","uid":"aa18ca8bbe4604cca91aa58ef474fe02","slug":"Redis实战-好友关注","date":"2023-06-06T01:49:53.000Z","updated":"2023-06-06T02:38:59.381Z","comments":true,"path":"api/articles/Redis实战-好友关注.json","keywords":null,"cover":[],"text":"好友关注好友关注-关注和取消关注针对用户的操作：可以对用户进行关注和取消关注功能。 实现思路： 需求：基于该表数据结构，实现两个接口： 关注和取关接口 判断是否关注的接口 关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示： 注意: 这里需要把...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-点赞排行榜","uid":"6b1fcf8efc840ca23645e7afc15b96ff","slug":"Redis实战-点赞排行榜","date":"2023-06-06T01:30:08.000Z","updated":"2023-06-06T01:48:55.161Z","comments":true,"path":"api/articles/Redis实战-点赞排行榜.json","keywords":null,"cover":[],"text":"点赞排行榜点赞功能初始代码 @GetMapping(\"/likes/&#123;id&#125;\") public Result queryBlogLikes(@PathVariable(\"id\") Long id) &#123; //修改点赞数量 blogService.upd...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-消息队列","uid":"4b50e524d6593265b35d48bd112d4791","slug":"Redis实战-消息队列","date":"2023-06-05T14:00:00.000Z","updated":"2023-06-06T01:28:16.788Z","comments":true,"path":"api/articles/Redis实战-消息队列.json","keywords":null,"cover":[],"text":"Redis消息队列认识消息队列什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色： 消息队列：存储和管理消息，也被称为消息代理（Message Broker） 生产者：发送消息到消息队列 消费者：从消息队列获取消息并处理消息 使用队列的好处在于 解耦：所...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-Redission分布式锁","uid":"b241352e87f784e0f5d32e5898f90895","slug":"Redis实战-Redission分布式锁","date":"2023-06-04T14:29:14.000Z","updated":"2023-06-05T15:29:25.207Z","comments":true,"path":"api/articles/Redis实战-Redission分布式锁.json","keywords":null,"cover":[],"text":"分布式锁-redission分布式锁-redission的功能基于setnx实现的分布式锁存在下面的问题： 重入问题：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁 不可重试：是指目前的分布式只能尝试一次，合理的情况是：当线程在获得锁失败后...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-分布式锁","uid":"ccca64486565a23a9fbb5012df3ad7c1","slug":"Redis实战-分布式锁","date":"2023-06-04T10:10:53.000Z","updated":"2023-06-04T15:58:47.426Z","comments":true,"path":"api/articles/Redis实战-分布式锁.json","keywords":null,"cover":[],"text":"4、分布式锁基本原理和实现方式对比分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。 分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路 分布式锁应该满足以下条件： 可见性：...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Redis实战","slug":"Redis实战","count":2,"path":"api/tags/Redis实战.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-秒杀","uid":"a08c023de37b091e96339da5fe4c6318","slug":"Redis实战-秒杀","date":"2023-06-04T08:36:56.000Z","updated":"2023-06-04T15:41:52.733Z","comments":true,"path":"api/articles/Redis实战-秒杀.json","keywords":null,"cover":[],"text":"秒杀全局唯一ID当用户抢购时，就会生成订单并保存到订单表中，而订单表如果使用数据库自增ID就存在一些问题： id的规律性太明显 受单表数据量的限制 场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战-查询缓存","uid":"7d0a0586b751a56e3829bac5576874c8","slug":"Redis实战-查询缓存","date":"2023-06-04T05:51:43.000Z","updated":"2023-06-04T15:53:48.563Z","comments":true,"path":"api/articles/Redis实战-查询缓存.json","keywords":null,"cover":[],"text":"查询缓存缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码 例1:static final ConcurrentHashMap&lt;K,V> map = new ConcurrentHashMap&lt;>(); 本地用于...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis实战_共享Session","uid":"794b81b06cdfd907e7a76dd281a21694","slug":"Redis实战-共享Session","date":"2023-06-04T04:17:12.000Z","updated":"2023-06-04T15:32:34.414Z","comments":true,"path":"api/articles/Redis实战-共享Session.json","keywords":null,"cover":[],"text":"Redis共享Session短信登录案例基于Session实现登录流程发送验证码： 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号 如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户 短信验证码登...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Redis实战","slug":"Redis实战","count":2,"path":"api/tags/Redis实战.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"CompletableFuture原理与实战","uid":"e6ecbb75a271638e27405d472d7b664c","slug":"CompletableFuture原理与实战","date":"2023-06-04T03:03:29.000Z","updated":"2023-06-04T03:03:29.678Z","comments":true,"path":"api/articles/CompletableFuture原理与实战.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Java设计原则中，组合优先于继承","uid":"3790eb53c6264ff24e57195f4b6f77f1","slug":"Java设计原则中，组合优先于继承","date":"2023-06-03T13:35:14.000Z","updated":"2023-06-03T14:13:46.326Z","comments":true,"path":"api/articles/Java设计原则中，组合优先于继承.json","keywords":null,"cover":[],"text":"Java 设计原则中，为什么反复强调组合要优先于继承？在《阿里巴巴Java开发手册》中有一条规定：谨慎使用继承的方式进行扩展，优先使用组合的方式实现。 为什么不推荐使用继承 是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Redis基础","uid":"b6845422ba4775a7cab0c414606e3ecd","slug":"Redis基础","date":"2023-06-02T14:33:03.000Z","updated":"2023-06-03T15:50:35.971Z","comments":true,"path":"api/articles/Redis基础.json","keywords":null,"cover":[],"text":"认识NoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化​ 传统关系型数据库是结构化数据，每一张表都有严格的约束...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MDC实现链路追踪","uid":"4f10da7078fbc31ecbcb9fd541bf0d6b","slug":"MDC实现简单的链路追踪","date":"2023-06-02T12:36:15.000Z","updated":"2023-06-02T14:15:45.078Z","comments":true,"path":"api/articles/MDC实现简单的链路追踪.json","keywords":null,"cover":null,"text":"MDC实现链路追踪先明确Filter、HandlerInterceptor 和 AOP 的执行流程在 Spring Boot 应用程序中，Filter、HandlerInterceptor 和 AOP 切面都是拦截器组件，在请求处理过程中扮演不同的角色，各自负责不同的任务。在一个...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"链路追踪","slug":"链路追踪","count":1,"path":"api/tags/链路追踪.json"},{"name":"日志","slug":"日志","count":1,"path":"api/tags/日志.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"线程池的管理和使用","uid":"b491cfca14c8d6dfd4f8108806508bb6","slug":"线程池的管理和使用","date":"2023-06-01T06:36:07.000Z","updated":"2023-06-03T15:48:57.620Z","comments":true,"path":"api/articles/线程池的管理和使用.json","keywords":null,"cover":[],"text":"线程池的管理和使用​ 频繁的创建、销毁线程和线程池，会给系统带来额外的开销。未经池化及统一管理的线程，则会导致系统内线程数上限不可控。这种情况下，随着访问数增加，系统内线程数持续增长，CPU负载逐步提高。极端情况下，甚至可能会导致CPU资源被吃满，整个服务不可用。 解决方案替换掉...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"SpringTask实现定时任务","uid":"34f154820ac35e3d8f3e9afce6bf7431","slug":"SpringTask实现定时任务","date":"2023-05-31T02:51:56.000Z","updated":"2023-05-31T08:12:18.441Z","comments":true,"path":"api/articles/SpringTask实现定时任务.json","keywords":null,"cover":null,"text":"SpringTask SpringTask是Spring自主研发的轻量级定时任务工具，相比于Quartz更加简单方便，且不需要引入其他依赖即可使用。 Cron表达式 Cron表达式是一个字符串，包括6~7个时间元素，在SpringTask中可以用于指定任务的执行时间。 Cron的...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"SpringTask","slug":"SpringTask","count":1,"path":"api/tags/SpringTask.json"},{"name":"定时任务","slug":"定时任务","count":1,"path":"api/tags/定时任务.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"线程池异常日志处理","uid":"c03c4f80044b1216d3d7a05319a58324","slug":"线程池异常日志处理","date":"2023-05-30T12:43:04.000Z","updated":"2023-05-30T13:13:27.663Z","comments":true,"path":"api/articles/线程池异常日志处理.json","keywords":null,"cover":null,"text":"线程池异常日志处理线程池是作为池化技术的一种常见应用 先定义一个线程池实例 @Bean public ThreadPoolExecutor uncaughtExceptionExecutor() &#123; ThreadFactory threadFactory = new T...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"SpringSecurity和JWT实现认证授权","uid":"2e24c73ebcb94047e46d06be7faec991","slug":"SpringSecurity和JWT实现认证授权","date":"2023-05-30T02:49:20.000Z","updated":"2023-05-31T02:48:51.996Z","comments":true,"path":"api/articles/SpringSecurity和JWT实现认证授权.json","keywords":null,"cover":null,"text":"SpringSecurity和JWT实现认证授权在pom.xml中添加项目依赖&lt;!--SpringSecurity依赖配置--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;ar...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":2,"path":"api/tags/认证授权.json"},{"name":"SpringSecurity","slug":"SpringSecurity","count":1,"path":"api/tags/SpringSecurity.json"},{"name":"JWT","slug":"JWT","count":1,"path":"api/tags/JWT.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"SpringBoot中自定义注解","uid":"d706fd469eec284e90755d9abf2cccf2","slug":"SpringBoot中自定义注解","date":"2023-05-29T14:05:15.000Z","updated":"2023-05-29T14:06:30.891Z","comments":true,"path":"api/articles/SpringBoot中自定义注解.json","keywords":null,"cover":null,"text":"SpringBoot中自定义注解","link":"","photos":[],"count_time":{"symbolsCount":16,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"注解","slug":"注解","count":1,"path":"api/tags/注解.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Netty进阶","uid":"6ee3eede71e00c52eb0546cb31634cea","slug":"Netty进阶","date":"2023-05-27T12:51:09.000Z","updated":"2023-05-27T14:06:53.250Z","comments":true,"path":"api/articles/Netty进阶.json","keywords":null,"cover":[],"text":"粘包与半包服务端代码 public class HelloWorldServer &#123; static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class); void start() &#12...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Netty基础","uid":"50b6ca39b1c5fcfd54bce8129993cbda","slug":"Netty基础","date":"2023-05-26T02:36:45.000Z","updated":"2023-05-26T11:58:35.057Z","comments":true,"path":"api/articles/Netty基础.json","keywords":null,"cover":[],"text":"Netty 概述Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端 Netty 的优势 Netty vs NIO，工作量大，bug 多 需要自己构建协议 解决 TCP 传输问题，如粘包、半包 epoll 空轮询导致 CPU 100...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2023-05-25T02:38:47.000Z","updated":"2023-05-25T15:12:11.103Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"NIO 基础non-blocking io 非阻塞 IO三大组件Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之...","link":"","photos":[],"count_time":{"symbolsCount":"47k","symbolsTime":"43 mins."},"categories":[],"tags":[{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2023-05-24T11:24:04.000Z","updated":"2023-06-14T14:18:07.658Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":[],"text":"Docker的用途Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Dock...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"SQL优化","uid":"f515c75be93536d047fb1ea7dd55160d","slug":"SQL优化","date":"2023-05-23T13:48:45.000Z","updated":"2023-05-23T15:55:25.049Z","comments":true,"path":"api/articles/SQL优化.json","keywords":null,"cover":null,"text":"SQL优化插入数据insert 如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。 优化方案一 批量插入数据 Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerr...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring MVC","uid":"84c6604e94d88eec227a0b74aad54f6e","slug":"Spring-MVC","date":"2023-05-20T12:40:51.000Z","updated":"2023-05-20T12:44:54.770Z","comments":true,"path":"api/articles/Spring-MVC.json","keywords":null,"cover":null,"text":"Spring MVCWebMvcConfigurerWebMvcConfigurer是一个Spring MVC的配置接口，它提供了一些方法来进行各种配置。WebConfig类实现了这个接口，因此可以利用这些方法来配置应用程序。例如：addInterceptors()：用于添加拦截...","link":"","photos":[],"count_time":{"symbolsCount":370,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Spring MVC","slug":"Spring-MVC","count":1,"path":"api/tags/Spring-MVC.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"InnoDB存储引擎_MVCC原理","uid":"12e6f0c825691db3e38970eadda0c57d","slug":"InnoDB存储引擎-MVCC原理","date":"2023-05-20T02:00:56.000Z","updated":"2023-05-20T09:10:10.924Z","comments":true,"path":"api/articles/InnoDB存储引擎-MVCC原理.json","keywords":null,"cover":[],"text":"InnoDB引擎逻辑存储结构InnoDB的逻辑存储结构如下图所示: 表空间 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_锁","uid":"083e3a4ebfcb19d327b53b7d73aaddd3","slug":"MySQL-锁","date":"2023-05-19T01:39:57.000Z","updated":"2023-05-19T15:44:11.108Z","comments":true,"path":"api/articles/MySQL-锁.json","keywords":null,"cover":[],"text":"锁​ 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"基于session实现认证","uid":"7a80ec680e8c46b9ee58692b58f8ab63","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","updated":"2023-05-18T16:15:24.710Z","comments":true,"path":"api/articles/基于session实现认证.json","keywords":null,"cover":[],"text":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。 什么是会话用户认证通过后，为了避免用户的每...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":2,"path":"api/tags/认证授权.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_存储引擎_索引","uid":"ca0fb70bccc39b11cac4043db766085d","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","updated":"2023-05-23T13:47:20.934Z","comments":true,"path":"api/articles/MySQL-存储引擎-索引.json","keywords":null,"cover":[],"text":"MySQL存储引擎MySQL体系结构 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"MySQL-事务","date":"2023-05-17T13:51:38.000Z","updated":"2023-05-18T03:11:52.678Z","comments":true,"path":"api/articles/MySQL-事务.json","keywords":null,"cover":[],"text":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。 事务操作未控制事...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_约束_多表查询","uid":"f293b2fcfae54b8509d50db2914ed7a0","slug":"MySQL-约束-多表联查","date":"2023-05-16T13:40:42.000Z","updated":"2023-05-17T13:50:48.431Z","comments":true,"path":"api/articles/MySQL-约束-多表联查.json","keywords":null,"cover":[],"text":"约束概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。 目的：保证数据库中数据的正确、有效性和完整性。 约束 描述 关键词 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DCL_函数","uid":"8f9e88b96addebc57d8b075bdae2d985","slug":"MySQL-DCL-函数","date":"2023-05-16T08:56:15.000Z","updated":"2023-05-18T02:45:07.908Z","comments":true,"path":"api/articles/MySQL-DCL-函数.json","keywords":null,"cover":[],"text":"DCLData Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。 管理用户查询用户 select * from mysql.user; 其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"状态模式","uid":"b886b366f3cb34006709f66f49ec6b62","slug":"状态模式","date":"2023-05-15T10:11:38.000Z","updated":"2023-05-15T11:53:16.531Z","comments":true,"path":"api/articles/状态模式.json","keywords":null,"cover":null,"text":"状态模式它将对象的行为与其内部状态分离开来，使得对象可以根据其内部状态的变化而改变其行为。状态模式通过将状态的切换封装在状态类中，使得状态转换具有可扩展性和灵活性，并避免了由于状态转换所带来的“if-else”嵌套过多的问题。 状态模式的基本机制是将状态抽象为一个接口或者抽象类，...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"迭代器模式","uid":"ab4a664e2e3638cd67bb057e6ee644aa","slug":"迭代器模式","date":"2023-05-15T09:44:26.000Z","updated":"2023-05-15T10:07:39.257Z","comments":true,"path":"api/articles/迭代器模式.json","keywords":null,"cover":null,"text":"迭代器模式它提供一种方便的方式来访问并遍历集合对象的元素，而无需暴露集合的内部表示。该模式将遍历集合的过程与集合的实现分离开来，使得可以在不影响客户端代码的情况下更改集合的内部实现。 迭代器模式包括以下几个元素： 1.迭代器接口（Iterator）：定义了用于访问和遍历集合元素的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"命令模式","uid":"35b7e7d45f0bf660fac88351c60754e3","slug":"命令模式","date":"2023-05-15T09:17:29.000Z","updated":"2023-05-15T09:43:43.625Z","comments":true,"path":"api/articles/命令模式.json","keywords":null,"cover":null,"text":"命令模式它允许将请求封装为对象，从而使得请求的发送者和接收者解耦，同时可实现请求的队列化、撤销和恢复。 该模式的关键点是将请求与实现解耦并引入命令对象，以便将请求发送给不同的对象，并可随时进行撤销和恢复。通常情况下，命令对象包含执行请求的接收者、请求数据以及实现该请求的方法。 命...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"访问者模式","uid":"d75c20296e97428894e8c62bab0f606e","slug":"访问者模式","date":"2023-05-15T08:21:18.000Z","updated":"2023-05-15T09:16:11.083Z","comments":true,"path":"api/articles/访问者模式.json","keywords":null,"cover":null,"text":"访问者模式它将算法封装到独立的对象中，使其可以在不修改现有对象结构的情况下增加新的操作。访问者模式的核心思想是在被访问的对象上定义一个接受访问者对象的接口，然后访问者对象通过该接口访问被访问对象。这样可以使得被访问对象保持稳定，而访问者对象可以根据需要进行扩展。 访问者模式包含以...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"中介者模式","uid":"ba45023a93415880bd8ff889992600c8","slug":"中介者模式","date":"2023-05-15T07:45:06.000Z","updated":"2023-05-15T08:20:29.485Z","comments":true,"path":"api/articles/中介者模式.json","keywords":null,"cover":null,"text":"中介者模式它的作用是减少对象之间的直接耦合关系，通过引入一个中介者对象来协调多个对象之间的交互行为，从而将系统中复杂的网状关系变为简单的星型结构。 中介者模式的机制基于以下两个关键点： 抽象中介者（Mediator）：为了把各同事类的耦合度降到最低，将对象间通信的控制交给一个中介...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DQL","uid":"4fe76f7b940933ddf5de5f39814faa1c","slug":"MySQL-DQL","date":"2023-05-14T06:22:31.000Z","updated":"2023-05-16T08:55:45.033Z","comments":true,"path":"api/articles/MySQL-DQL.json","keywords":null,"cover":[],"text":"DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录 基本语法DQL 查询语句，语法结构如下： SELET 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DML","uid":"676b4ad0d6495672245716dc73cc8c9e","slug":"MySQL-DML","date":"2023-05-14T01:30:25.000Z","updated":"2023-05-14T08:04:28.656Z","comments":true,"path":"api/articles/MySQL-DML.json","keywords":null,"cover":null,"text":"DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。 添加数据 给指定字段添加数据 INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...); 案例:...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"MySQL_DDL_Linux","uid":"56fbe19991b11dc0bb9030f36adcdf92","slug":"MySQL-DDL","date":"2023-05-13T10:36:19.000Z","updated":"2023-05-14T15:28:23.957Z","comments":true,"path":"api/articles/MySQL-DDL.json","keywords":null,"cover":null,"text":"启动MySQL服务启动mysql服务 systemctl start mysqld 重启mysql服务 systemctl restart mysqld 停止mysql服务 systemctl stop mysqld 查询首次安装数据库自动生成的root密码grep 'tempo...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"},{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring Bean的生命周期","uid":"b847fc9b240aefdbf95225a3e7dc9026","slug":"Spring Bean的生命周期","date":"2023-05-13T04:32:54.000Z","updated":"2023-05-13T08:18:53.223Z","comments":true,"path":"api/articles/Spring Bean的生命周期.json","keywords":null,"cover":null,"text":"Spring Bean的生命周期getBean方法都会调用doGetBean的逻辑 public &lt;T> T getBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object... args)...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring refresh流程","uid":"ec47f8662f4dbcb9ad26f0a7bcc5e407","slug":"Spring-refresh流程","date":"2023-05-13T01:19:52.000Z","updated":"2023-05-18T02:31:56.825Z","comments":true,"path":"api/articles/Spring-refresh流程.json","keywords":null,"cover":[],"text":"refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤： pre...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"Spring如何解决循环依赖","uid":"2846594611fd32071ec8e1a72cd8f17d","slug":"Spring如何解决循环依赖","date":"2023-05-11T13:26:38.000Z","updated":"2023-05-13T09:55:27.202Z","comments":true,"path":"api/articles/Spring如何解决循环依赖.json","keywords":null,"cover":[],"text":"Spring如何解决循环依赖解决Set循环依赖注入Spring一级缓存singletonObjects singletonObjects是一级缓存，用于存储单例Bean的实例对象。也就是说，当Spring容器创建一个单例Bean时，会将该Bean的实例对象放入一级缓存中，在后续使...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"代理的创建时机","uid":"a685b627e4865e5f328e43bd436e0d9e","slug":"代理的创建时机","date":"2023-05-11T12:55:58.000Z","updated":"2023-05-11T13:36:21.626Z","comments":true,"path":"api/articles/代理的创建时机.json","keywords":null,"cover":null,"text":"代理的创建时机代理的创建时机 创建 -&gt; ( * ) 依赖注入 -&gt; 初始化 ( * ) 初始化之后 (无循环依赖时) 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存 public class A17_1 &#123; public static vo...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Proxy","slug":"Proxy","count":2,"path":"api/tags/Proxy.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"从@Aspect到Advisor","uid":"a95318a81b0b3097ed11bab255c7390f","slug":"从@Aspect到Advisor","date":"2023-05-11T12:04:08.000Z","updated":"2023-05-11T13:38:30.919Z","comments":true,"path":"api/articles/从@Aspect到Advisor.json","keywords":null,"cover":null,"text":"@Aspect—&gt;&gt;AdvisorAnnotationAwareAspectJAutoProxyCreator AnnotationAwareAspectJAutoProxyCreator的作用是将高级切面转换成低级切面，使其能够被Spring框架所识别和使用。具体来...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"切点匹配规则","uid":"d3cf2f31cfa6170a433ba0c99bf2326a","slug":"切点匹配规则","date":"2023-05-11T09:35:15.000Z","updated":"2023-05-11T12:02:12.278Z","comments":true,"path":"api/articles/切点匹配规则.json","keywords":null,"cover":null,"text":"切点匹配规则AspectJ使用切点指示器（Pointcut Designator）来描述需要匹配的切点，切点指示器定义了切点的名称、参数、返回类型、标注等信息。切点指示器可以根据需要使用通配符、逻辑运算符、正则表达式等方式来描述切点。 AspectJ中的切点指示符主要分为以下几种...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"JDK和CGlib在Spring中的统一","uid":"42403d33a4a316854760bf766fee144b","slug":"JDK和CGlib在Spring中的统一","date":"2023-05-11T05:01:11.000Z","updated":"2023-05-11T10:00:53.217Z","comments":true,"path":"api/articles/JDK和CGlib在Spring中的统一.json","keywords":null,"cover":null,"text":"JDK和CGlib在Spring中的统一Spring 中对切点、通知、切面的抽象如下 切点：接口 Pointcut，典型实现 AspectJExpressionPointcut 通知：典型接口为 MethodInterceptor 代表环绕通知 切面：Advisor，包含一个 A...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"Proxy","slug":"Proxy","count":2,"path":"api/tags/Proxy.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","updated":"2023-05-11T05:18:39.984Z","comments":true,"path":"api/articles/AOP实现之proxy.json","keywords":null,"cover":[],"text":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags: AOP Spring Java AOP实现之proxyjdk动态代理 动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。 ...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"AOP实现之agent类加载","uid":"d7e2802c58918040c31b14740192f666","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","updated":"2023-05-10T08:39:08.324Z","comments":true,"path":"api/articles/AOP实现之agent类加载.json","keywords":null,"cover":null,"text":"AOP实现之agent类加载","link":"","photos":[],"count_time":{"symbolsCount":14,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"AOP","slug":"AOP","count":1,"path":"api/tags/AOP.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"模板方法的设计模式","uid":"594a23198fd2599edc1d35598ede3148","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","updated":"2023-05-09T14:04:17.842Z","comments":true,"path":"api/articles/模板方法模式.json","keywords":null,"cover":null,"text":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。 模板方法设计模式的优点 将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。 通过把通用方法提取到抽象类中，避免了重复代码的出现，...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"策略模式","uid":"8ced7c3b7dad33d06ee59bde7028cd4a","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","updated":"2023-05-09T13:33:40.042Z","comments":true,"path":"api/articles/策略模式.json","keywords":null,"cover":null,"text":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。 在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。 优点 封装了一系列算法：将一系列...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"观察者模式","uid":"cd55e9d94b94ab2ca447027ce4beeca6","slug":"观察者模式","date":"2023-05-09T12:47:06.000Z","updated":"2023-05-09T13:07:55.500Z","comments":true,"path":"api/articles/观察者模式.json","keywords":null,"cover":null,"text":"观察者模式它允许一个对象（称为被观察者或主题）维护一组依赖于它的对象（称为观察者），当被观察者发生变化时，它会通知所有观察者以便更新它们自己的状态。 优点： 在观察者模式中，被观察者和观察者之间是松耦合的关系，使得它们之间的交互变得简单而灵活。 观察者模式支持广播通信，当一个对象...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"责任链模式","uid":"2b09bf65e737f820cf301fb7434c8c8e","slug":"责任链模式","date":"2023-05-09T12:16:17.000Z","updated":"2023-05-09T12:38:56.430Z","comments":true,"path":"api/articles/责任链模式.json","keywords":null,"cover":null,"text":"责任链模式责任链模式是一种行为设计模式，用于将请求从一个处理程序传递到另一个处理程序，直到找到能够处理请求的处理程序。每个处理程序都将请求传递给下一个处理程序，直到请求被处理为止。 责任链模式的特点 请求发送者不必知道请求在何时、何处以及如何被处理。 可以动态增加或修改请求的处理...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"代理模式","uid":"424f199f6c88af138e76cfdf85fb4fa5","slug":"代理模式","date":"2023-05-09T11:52:50.000Z","updated":"2023-05-09T11:58:21.290Z","comments":true,"path":"api/articles/代理模式.json","keywords":null,"cover":null,"text":"代理模式它为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，可以进行一些附加的工作，例如访问控制、远程访问、缓存等。 以下是一个简单的代理模式的Java例子：interface Image &#123; void display(); &#...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"装饰器模式","uid":"af957b16e3777023cafc3b1e9179b2cd","slug":"装饰器模式","date":"2023-05-09T11:12:05.000Z","updated":"2023-05-09T11:42:05.537Z","comments":true,"path":"api/articles/装饰器模式.json","keywords":null,"cover":null,"text":"装饰器模式装饰者模式（Decorator Pattern） ​ 它允许你向现有对象添加新的功能，同时又不改变其结构。装饰者模式的核心思想是将功能进行分离，让各个类只专注于自己的职责。通过这种方式，我们可以以非常灵活的方式扩展系统的功能，而不必修改原有代码。 ​ 装饰器模式的主要目...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"组合模式","uid":"890198f3e29403fa2d961081f54ed8cd","slug":"组合模式","date":"2023-05-09T10:42:25.000Z","updated":"2023-05-09T11:00:22.048Z","comments":true,"path":"api/articles/组合模式.json","keywords":null,"cover":null,"text":"组合模式组合模式 主要通过将对象组合成树形结构来表示“整体-部分”的关系，让客户端能够以一致的方式对待单个对象和对象合。 下面是一个简单的例子import java.util.ArrayList; import java.util.List; public interface E...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"适配器模式","uid":"a8b2eb4f810dce05fcecb16e8edfd126","slug":"适配器模式","date":"2023-05-09T08:09:59.000Z","updated":"2023-05-09T09:08:48.890Z","comments":true,"path":"api/articles/适配器模式.json","keywords":null,"cover":null,"text":"适配器模式适配器模式（Adapter Pattern）是一种结构型设计模式，它用于将一个类的接口转换成客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作。在适配器模式中，适配器充当了两个不兼容接口之间的桥梁，它负责允许这些接口间能够相互协作。 在Java中，适配器模式常...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"工厂模式","uid":"3dbdc722104d94fc07273118e255f7fd","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","updated":"2023-05-09T07:00:21.428Z","comments":true,"path":"api/articles/工厂模式.json","keywords":null,"cover":[],"text":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数 简单工厂UML类图 适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。 简单工厂的例子: Ca...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"建造者模式","uid":"b00cac0eae3b04411014ea36945005af","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","updated":"2023-05-09T04:53:43.979Z","comments":true,"path":"api/articles/建造者模式.json","keywords":null,"cover":null,"text":"Java建造者模式Java中的建造者模式(Builder Pattern) 主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。 该模式包含以下几个角色： Builder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。 Concrete...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"spring中常见的设计模式","uid":"0c6e8405652937a86cc3782f838cf782","slug":"Spring中的设计模式","date":"2023-05-09T04:00:50.000Z","updated":"2023-05-18T02:32:40.385Z","comments":true,"path":"api/articles/Spring中的设计模式.json","keywords":null,"cover":null,"text":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别 根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it 就是确...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"单例模式","uid":"5e422a9b2c69bd7294ec71b84cbbb53b","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","updated":"2023-05-08T15:15:46.818Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":"/img/5.8.jpg","text":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},{"title":"spring事务失效的情况以及注意事项","uid":"064fd1f961f785b45ddfca5b3ce563ee","slug":"Spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","updated":"2023-05-18T02:32:28.591Z","comments":true,"path":"api/articles/Spring事务失效的情况以及注意事项.json","keywords":null,"cover":"/img/5.7.jpg","text":"什么是spring事务？​ Spring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。 ​ Sp...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":11,"path":"api/tags/Spring.json"},{"name":"面试题","slug":"面试题","count":5,"path":"api/tags/面试题.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}],"categories":0,"tags":0,"word_count":"655k","post_count":73}