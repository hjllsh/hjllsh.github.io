{"title":"MySQL日志系统","uid":"1442087dfdabdc07946399fb7094e2fa","slug":"MySQL日志系统","date":"2023-06-11T04:33:43.000Z","updated":"2023-06-14T07:25:30.255Z","comments":true,"path":"api/articles/MySQL日志系统.json","keywords":null,"cover":[],"content":"<h2 id=\"MySQL的基本架构\"><a href=\"#MySQL的基本架构\" class=\"headerlink\" title=\"MySQL的基本架构\"></a>MySQL的基本架构</h2><p>比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> T <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">10</span>；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"MySQL内部的执行过程\"><a href=\"#MySQL内部的执行过程\" class=\"headerlink\" title=\"MySQL内部的执行过程\"></a>MySQL内部的执行过程</h4><p>MySQL的基本架构示意图</p>\n<p><img src=\"/../assets/images/0d2070e8f84c4801adbfa03bda1f98d9.png\" alt=\"img\"></p>\n<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>\n<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。不同的存储引擎共用一个Server层。</p>\n<h3 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h3><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mysql -h$ip -P$port -u$user -p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n<ul>\n<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>\n<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>\n</ul>\n<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>\n<p>但是全部使用长连接后，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>\n<p>考虑以下两种方案</p>\n<ol>\n<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>\n<li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>\n</ol>\n<h3 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h3><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>\n<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>\n<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>\n<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p>\n<p>MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> SQL_CACHE <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> T <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">10</span>；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>MySQL 8.0版本直接将查询缓存的整块功能删掉了。</p>\n<h3 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h3><p>如果没有命中查询缓存，就开始执行语句。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>\n<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>\n<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>\n<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>\n<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> t1 <span class=\"token keyword\">join</span> t2 <span class=\"token keyword\">using</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">)</span>  <span class=\"token keyword\">where</span> t1<span class=\"token punctuation\">.</span>c<span class=\"token operator\">=</span><span class=\"token number\">10</span> <span class=\"token operator\">and</span> t2<span class=\"token punctuation\">.</span>d<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>\n<li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>\n</ul>\n<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> T <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nERROR <span class=\"token number\">1142</span> <span class=\"token punctuation\">(</span><span class=\"token number\">42000</span><span class=\"token punctuation\">)</span>: <span class=\"token keyword\">SELECT</span> command denied <span class=\"token keyword\">to</span> <span class=\"token keyword\">user</span> <span class=\"token string\">'b'</span><span class=\"token variable\">@'localhost'</span> <span class=\"token keyword\">for</span> <span class=\"token keyword\">table</span> <span class=\"token string\">'T'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>\n<p>这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>\n<ol>\n<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>\n<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>\n<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>\n</ol>\n<p>至此，这个语句就执行完成了。</p>\n<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>\n<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎么做到的？</p>\n<p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> T<span class=\"token punctuation\">(</span>ID <span class=\"token keyword\">int</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span><span class=\"token punctuation\">,</span> c <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">update</span> T <span class=\"token keyword\">set</span> c<span class=\"token operator\">=</span>c<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>SQL语句基本的执行链路，更新语句也是同样会走一遍</p>\n<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。</p>\n<h3 id=\"重要的日志模块：redo-log\"><a href=\"#重要的日志模块：redo-log\" class=\"headerlink\" title=\"重要的日志模块：redo log\"></a>重要的日志模块：redo log</h3><p>在MySQL里有这个问题，如果每一次的更新操作都需要写进磁盘，磁盘要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。MySQL里使用了WAL技术来解决，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>\n<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>\n<p>如果更新操作很频繁，redo log日志是会写满的，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>\n<p><img src=\"/../assets/images/b075250cad8d9f6c791a52b6a600f69c.jpg\" alt=\"img\"></p>\n<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>\n<p>write pos和checkpoint之间的是空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>\n<h3 id=\"重要的日志模块：binlog\"><a href=\"#重要的日志模块：binlog\" class=\"headerlink\" title=\"重要的日志模块：binlog\"></a>重要的日志模块：binlog</h3><p>MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>\n<p>为什么会有两份日志呢？</p>\n<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统也就是redo log来实现crash-safe能力。</p>\n<p>这两种日志有以下三点不同。</p>\n<ol>\n<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>\n<li>redo log是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；binlog是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</li>\n<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>\n</ol>\n<p>再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>\n<ol>\n<li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>\n<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>\n<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>\n<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>\n<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>\n</ol>\n<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p>\n<p><img src=\"/../assets/images/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png\" alt=\"img\"></p>\n<p>将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。这是为了让两份日志之间的逻辑一致。</p>\n<h4 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h4><p>为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>\n<p>假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>\n<p><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p>\n<p><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p>\n<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>\n<p>小结：</p>\n<p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>\n<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>\n","text":"MySQL的基本架构比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时： mysql> select * from T where ID=10； MySQL内部的执行过程MySQL的基本架构示意图 大体来说，MySQL可以分为Server层和存储引擎层两部分。...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">MySQL的基本架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL%E5%86%85%E9%83%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">MySQL内部的执行过程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E5%99%A8\"><span class=\"toc-text\">连接器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">查询缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">分析器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%99%A8\"><span class=\"toc-text\">优化器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E5%99%A8\"><span class=\"toc-text\">执行器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">日志系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%9Aredo-log\"><span class=\"toc-text\">重要的日志模块：redo log</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%9Abinlog\"><span class=\"toc-text\">重要的日志模块：binlog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">两阶段提交</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Mybatis(一)","uid":"9f1c39845db12e0e40a2bf8f9721b61a","slug":"Mybatis(1)","date":"2023-06-14T02:03:59.000Z","updated":"2023-06-14T13:16:35.005Z","comments":true,"path":"api/articles/Mybatis(1).json","keywords":null,"cover":[],"text":"MybatisMyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几 乎所有的 JDBC 代码和手动设置参数以及 获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Lambda表达式","uid":"32a652994e7e566383677d79f35d7c59","slug":"Lambda表达式","date":"2023-06-10T07:21:11.000Z","updated":"2023-06-10T15:16:34.349Z","comments":true,"path":"api/articles/Lambda表达式.json","keywords":null,"cover":[],"text":"函数式编程思想函数式编程思想类似于我们数学中的函数，它主要关注的是对数据进行了什么操作。 优点： 代码简洁，开发快速 接近自然语言，易于理解 易于“并发编程” Lambda表达式Lambda是JDK8中一个语法糖，它可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"},{"name":"Lambda","slug":"Lambda","count":1,"path":"api/tags/Lambda.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}