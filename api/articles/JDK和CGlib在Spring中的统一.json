{"title":"JDK和CGlib在Spring中的统一","uid":"42403d33a4a316854760bf766fee144b","slug":"JDK和CGlib在Spring中的统一","date":"2023-05-11T05:01:11.000Z","updated":"2023-05-11T10:00:53.217Z","comments":true,"path":"api/articles/JDK和CGlib在Spring中的统一.json","keywords":null,"cover":null,"content":"<h2 id=\"JDK和CGlib在Spring中的统一\"><a href=\"#JDK和CGlib在Spring中的统一\" class=\"headerlink\" title=\"JDK和CGlib在Spring中的统一\"></a>JDK和CGlib在Spring中的统一</h2><p>Spring 中对切点、通知、切面的抽象如下</p>\n<ul>\n<li>切点：接口 Pointcut，典型实现 AspectJExpressionPointcut</li>\n<li>通知：典型接口为 MethodInterceptor 代表环绕通知</li>\n<li>切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut</li>\n</ul>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">classDiagram</span>\n\n<span class=\"token keyword\">class</span> Advice\n<span class=\"token keyword\">class</span> MethodInterceptor\n<span class=\"token keyword\">class</span> Advisor\n<span class=\"token keyword\">class</span> PointcutAdvisor\n\nPointcut <span class=\"token arrow operator\">&lt;|--</span> AspectJExpressionPointcut\nAdvice <span class=\"token arrow operator\">&lt;|--</span> MethodInterceptor\nAdvisor <span class=\"token arrow operator\">&lt;|--</span> PointcutAdvisor\nPointcutAdvisor <span class=\"token arrow operator\">o--</span> <span class=\"token string\">\"一\"</span> Pointcut\nPointcutAdvisor <span class=\"token arrow operator\">o--</span> <span class=\"token string\">\"一\"</span> Advice\n\n<span class=\"token annotation important\">&lt;&lt;interface>></span> Advice\n<span class=\"token annotation important\">&lt;&lt;interface>></span> MethodInterceptor\n<span class=\"token annotation important\">&lt;&lt;interface>></span> Pointcut\n<span class=\"token annotation important\">&lt;&lt;interface>></span> Advisor\n<span class=\"token annotation important\">&lt;&lt;interface>></span> PointcutAdvisor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代理相关类图</p>\n<ul>\n<li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li>\n<li>AopProxy 通过 getProxy 创建代理对象</li>\n<li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li>\n<li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li>\n</ul>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">classDiagram</span>\n\nAdvised <span class=\"token arrow operator\">&lt;|--</span> ProxyFactory\nProxyFactory <span class=\"token arrow operator\">o--</span> Target\nProxyFactory <span class=\"token arrow operator\">o--</span> <span class=\"token string\">\"多\"</span> Advisor\n\nProxyFactory <span class=\"token arrow operator\">--></span> AopProxyFactory <span class=\"token operator\">:</span> 使用\nAopProxyFactory <span class=\"token arrow operator\">--></span> AopProxy\nAdvised <span class=\"token arrow operator\">&lt;|--</span> 基于CGLIB的Proxy\n基于CGLIB的Proxy <span class=\"token arrow operator\">&lt;--</span> ObjenesisCglibAopProxy <span class=\"token operator\">:</span> 创建\nAopProxy <span class=\"token arrow operator\">&lt;|--</span> ObjenesisCglibAopProxy\nAopProxy <span class=\"token arrow operator\">&lt;|--</span> JdkDynamicAopProxy\n基于JDK的Proxy <span class=\"token arrow operator\">&lt;--</span> JdkDynamicAopProxy <span class=\"token operator\">:</span> 创建\nAdvised <span class=\"token arrow operator\">&lt;|--</span> 基于JDK的Proxy\n\n<span class=\"token keyword\">class</span> AopProxy <span class=\"token punctuation\">&#123;</span>\n   +getProxy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Object\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> ProxyFactory <span class=\"token punctuation\">&#123;</span>\n\tproxyTargetClass <span class=\"token operator\">:</span> boolean\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> ObjenesisCglibAopProxy <span class=\"token punctuation\">&#123;</span>\n\tadvised <span class=\"token operator\">:</span> ProxyFactory\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> JdkDynamicAopProxy <span class=\"token punctuation\">&#123;</span>\n\tadvised <span class=\"token operator\">:</span> ProxyFactory\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token annotation important\">&lt;&lt;interface>></span> Advised\n<span class=\"token annotation important\">&lt;&lt;interface>></span> AopProxyFactory\n<span class=\"token annotation important\">&lt;&lt;interface>></span> AopProxy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>在 Spring 中，JDK动态代理和CGLIB动态代理会被自动地统一使用。Spring框架会自动选择合适的代理方式，以确保代理对象的正确性和高效性。</p>\n<p>如果我们希望代理的对象实现了接口，那么我们可以选择使用 JDK 动态代理。相比 CGLIB 动态代理，JDK 动态代理的代理对象更加轻量级，因为直接实现了目标对象的接口。</p>\n<p>如果我们希望代理对象没有实现接口，那么我们只能使用 CGLIB 动态代理。CGLIB 动态代理会在运行时生成代理对象的子类，并重写目标对象的方法。所以 CGLIB 动态代理的代理对象比 JDK 动态代理的代理对象更加强大和灵活，但同时也更加重量级。</p>\n<p>总之，在使用 Spring 框架中的 AOP 时，我们只需要关注代理对象是否实现了接口，Spring 会根据情况自动选择使用 JDK 动态代理还是 CGLIB 动态代理。如果我们希望选择特定的代理方式，可以通过在 Spring 配置文件中进行配置来实现。</p>\n<h6 id=\"模拟Spring创建代理的使用jdk或者cglib\"><a href=\"#模拟Spring创建代理的使用jdk或者cglib\" class=\"headerlink\" title=\"模拟Spring创建代理的使用jdk或者cglib\"></a>模拟Spring创建代理的使用jdk或者cglib</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;要注意导包：MethodInterceptor是与 cglib的 MethodInterceptor 同名的\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\n\npublic class TestSpringAop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;*\n            两个切面概念\n            aspect &#x3D;\n                通知1(advice) +  切点1(pointcut)\n                通知2(advice) +  切点2(pointcut)\n                通知3(advice) +  切点3(pointcut)\n                ...\n            advisor &#x3D; 更细粒度的切面，包含一个通知和切点\n         *&#x2F;\n\n        &#x2F;&#x2F; 1. 准备好切点\n        AspectJExpressionPointcut pointcut &#x3D; new AspectJExpressionPointcut();\n        pointcut.setExpression(&quot;execution(* foo())&quot;);\n        &#x2F;&#x2F; 2. 准备好通知  MethodInterceptor与cglib的MethodInterceptor不一样\n        &#x2F;&#x2F;本质上是环绕通知\n        MethodInterceptor advice &#x3D; new MethodInterceptor() &#123;\n            @Override\n            public Object invoke(MethodInvocation invocation) throws Throwable &#123;\n                System.out.println(&quot;before...&quot;);\n                Object result &#x3D; invocation.proceed(); &#x2F;&#x2F; 调用目标\n                System.out.println(&quot;after...&quot;);\n                return result;\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 3. 备好切面\n        DefaultPointcutAdvisor advisor &#x3D; new DefaultPointcutAdvisor(pointcut, advice);\n        &#x2F;&#x2F; 4. 创建代理\n        Target2 target &#x3D; new Target2();\n        ProxyFactory factory &#x3D; new ProxyFactory();\n        factory.setTarget(target);\n        factory.addAdvisor(advisor);\n        &#x2F;&#x2F;获取接口类型 factory无法判断是否实现了接口，需要手动设置\n        factory.setInterfaces(target.getClass().getInterfaces());\n        factory.setProxyTargetClass(false);\n        Target2 proxy &#x3D; (Target2) factory.getProxy();\n        &#x2F;&#x2F;cglib代理\n        System.out.println(proxy.getClass());\n        proxy.foo();\n        proxy.bar();\n        &#x2F;*\n            学到了什么\n                a. Spring 的代理选择规则\n                b. 底层的切点实现\n                c. 底层的通知实现\n                d. ProxyFactory 是用来创建代理的核心实现, 用 AopProxyFactory 选择具体代理实现\n                    - JdkDynamicAopProxy\n                    - ObjenesisCglibAopProxy\n         *&#x2F;\n    &#125;\n\n    interface I1 &#123;\n        void foo();\n\n        void bar();\n    &#125;\n\n    static class Target1 implements I1 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target1 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target1 bar&quot;);\n        &#125;\n    &#125;\n\n    static class Target2 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target2 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target2 bar&quot;);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Spring 的代理选择规：</p>\n<ul>\n<li>proxyTargetClass &#x3D; false, 目标实现了接口, 用 jdk 实现</li>\n<li>proxyTargetClass &#x3D; false,  目标没有实现接口, 用 cglib 实现</li>\n<li>proxyTargetClass &#x3D; true, 总是使用 cglib 实现</li>\n</ul>\n","text":"JDK和CGlib在Spring中的统一Spring 中对切点、通知、切面的抽象如下 切点：接口 Pointcut，典型实现 AspectJExpressionPointcut 通知：典型接口为 MethodInterceptor 代表环绕通知 切面：Advisor，包含一个 A...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":10,"path":"api/tags/Spring.json"},{"name":"Proxy","slug":"Proxy","count":2,"path":"api/tags/Proxy.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JDK%E5%92%8CCGlib%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80\"><span class=\"toc-text\">JDK和CGlib在Spring中的统一</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9FSpring%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8jdk%E6%88%96%E8%80%85cglib\"><span class=\"toc-text\">模拟Spring创建代理的使用jdk或者cglib</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"切点匹配规则","uid":"d3cf2f31cfa6170a433ba0c99bf2326a","slug":"切点匹配规则","date":"2023-05-11T09:35:15.000Z","updated":"2023-05-11T12:02:12.278Z","comments":true,"path":"api/articles/切点匹配规则.json","keywords":null,"cover":null,"text":"切点匹配规则AspectJ使用切点指示器（Pointcut Designator）来描述需要匹配的切点，切点指示器定义了切点的名称、参数、返回类型、标注等信息。切点指示器可以根据需要使用通配符、逻辑运算符、正则表达式等方式来描述切点。 AspectJ中的切点指示符主要分为以下几种...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":25,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":10,"path":"api/tags/Spring.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","updated":"2023-05-11T05:18:39.984Z","comments":true,"path":"api/articles/AOP实现之proxy.json","keywords":null,"cover":[],"text":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags: AOP Spring Java AOP实现之proxyjdk动态代理 动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。 ...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}