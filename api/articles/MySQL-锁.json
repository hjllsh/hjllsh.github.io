{"title":"MySQL_锁","uid":"083e3a4ebfcb19d327b53b7d73aaddd3","slug":"MySQL-锁","date":"2023-05-19T01:39:57.000Z","updated":"2023-05-19T15:44:11.108Z","comments":true,"path":"api/articles/MySQL-锁.json","keywords":null,"cover":[],"content":"<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a><strong>锁</strong></h2><p>​\t\t锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>\n<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>\n<ul>\n<li><p>全局锁：锁定数据库中的所有表。</p>\n</li>\n<li><p>表级锁：每次操作锁住整张表。</p>\n</li>\n<li><p>行级锁：每次操作锁住对应的行数据</p>\n</li>\n</ul>\n<h3 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a><strong>全局锁</strong></h3><p>​\t\t全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>\n<p>​\t\t其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>\n<p>为什么全库逻辑备份，就需要加全就锁呢？</p>\n<p>不加全局锁，可能存在的问题。</p>\n<p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p>\n<p><img src=\"/assets/images/%E5%85%A8%E5%B1%80%E9%94%81.png\" alt=\"全局锁\"></p>\n<p>​\t\t在进行数据备份时，先备份了tb_stock库存表。</p>\n<p>​\t\t然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</p>\n<p>​\t\t然后再执行备份 tb_order表的逻辑。</p>\n<p>​\t\t业务中执行插入订单日志操作。</p>\n<p>最后，又备份了tb_orderlog表。</p>\n<p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)</p>\n<p>此时就可以借助于MySQL的全局锁来解决</p>\n<p><img src=\"/assets/images/%E5%85%A8%E5%B1%80%E9%94%8101.png\" alt=\"全局锁01\"></p>\n<p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p>\n<p><strong>语法</strong></p>\n<p> 加全局锁</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">flush <span class=\"token keyword\">tables</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">read</span> <span class=\"token keyword\">lock</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 数据备份</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysqldump <span class=\"token punctuation\">[</span><span class=\"token comment\">--single-transaction] -uroot –p1234 hj > hj.sql</span>\n<span class=\"token comment\">--   mysqldump: 是MySQL备份工具。</span>\n<span class=\"token comment\">--   -u : 指定连接数据库所用的用户名</span>\n<span class=\"token comment\">--   –p : 指定连接数据库所用的密码</span>\n<span class=\"token comment\">--   hj : 要备份的数据库名称。</span>\n<span class=\"token comment\">--   > hj.sql : 将备份文件输出到itcast.sql文件中，使用\">\"符号是将备份文件的内容导出到指定文件。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>释放锁</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>\n<ul>\n<li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p>\n</li>\n<li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p>\n</li>\n</ul>\n<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。</p>\n<p>该命令执行期间，在备份开始时使用<code>START TRANSACTION</code>语句来开启一个事务，这个事务会在备份期间一直执行，隔离级别默认为“可重复读”级别。在备份完成后，使用<code>COMMIT</code>语句来提交事务，这样就可以保证备份是一致性的，不会受到正在进行的其他事务的影响。</p>\n<p>需要注意的是，使用<code>--single-transaction</code>参数只适用于没有写锁的表。如果有表正在执行DDL语句，或者有使用<code>ALTER TABLE</code>，<code>OPTIMIZE TABLE</code>等语句的话，这些表仍然会被加锁，备份也会受到影响。</p>\n<h4 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a><strong>表级锁</strong></h4><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>\n<p>对于表级锁，主要分为以下三类：</p>\n<ul>\n<li>表锁</li>\n</ul>\n<p>​\t\t- 表共享读锁（read lock）</p>\n<p>​\t\t- 表独占写锁（write lock）</p>\n<ul>\n<li><p>元数据锁（meta data lock，MDL）</p>\n</li>\n<li><p>意向锁</p>\n</li>\n</ul>\n<p><strong>表锁语法：</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 加锁：</span>\n<span class=\"token keyword\">lock</span> <span class=\"token keyword\">tables</span> 表名<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">read</span><span class=\"token operator\">/</span><span class=\"token keyword\">write</span>\n<span class=\"token comment\">-- 释放锁</span>\n<span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span> <span class=\"token operator\">/</span> 客户端断开连接<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 读锁</p>\n<p><img src=\"/assets/images/%E8%AF%BB%E9%94%81.png\" alt=\"读锁\"></p>\n<p>读写演示：</p>\n<p><img src=\"/assets/images/%E8%AF%BB%E9%94%81%E6%BC%94%E7%A4%BA1.png\" alt=\"读锁演示\"></p>\n<p>对指定表加了读锁，加锁的会话未解锁时执行DML&#x2F;DDL会报错；</p>\n<p><img src=\"/assets/images/%E8%AF%BB%E9%94%81%E6%BC%94%E7%A4%BA2.png\" alt=\"读锁演示\"></p>\n<p>读锁不会影响其他会话的读，但是会阻塞（不是报错）其他会话的写。</p>\n<p>写锁</p>\n<p><img src=\"/assets/images/%E5%86%99%E9%94%81.png\" alt=\"写锁\"></p>\n<p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p>\n<p><strong>结论:</strong> 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>\n<p><strong>元数据锁</strong>\t</p>\n<p>meta data lock , 元数据锁，简写MDL。</p>\n<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>\n<p>MDL锁能够确保在进行表结构修改时，不会同时存在其他读和写操作，避免并发操作导致的数据冲突和错误。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>\n<p>常见的SQL操作时，所添加的元数据锁：</p>\n<table>\n<thead>\n<tr>\n<th>对应SQL</th>\n<th><strong>锁类型</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock tables xxx read &#x2F; write</td>\n<td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td>\n<td></td>\n</tr>\n<tr>\n<td>select 、select … lock in share mode</td>\n<td>SHARED_READ</td>\n<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>\n</tr>\n<tr>\n<td>insert 、update、delete、select … for update</td>\n<td>SHARED_WRITE</td>\n<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>\n</tr>\n<tr>\n<td>alter table …</td>\n<td>EXCLUSIVE</td>\n<td>与其他的MDL都互斥</td>\n</tr>\n</tbody></table>\n<p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> object_type<span class=\"token punctuation\">,</span>object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_duration <span class=\"token keyword\">from</span> performance_schema<span class=\"token punctuation\">.</span>metadata_locks <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>锁的兼容演示</p>\n<p><img src=\"/assets/images/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E7%9A%84%E6%BC%94%E7%A4%BA1.png\" alt=\"元数据锁\"></p>\n<p><img src=\"/assets/images/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E7%9A%84%E6%BC%94%E7%A4%BA2.png\" alt=\"元数据锁\"></p>\n<p>SHARED_READ与SHARED_WRITE兼容</p>\n<p><img src=\"/assets/images/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E7%9A%84%E6%BC%94%E7%A4%BA3.png\" alt=\"元数据锁\"></p>\n<p><img src=\"/assets/images/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E7%9A%84%E6%BC%94%E7%A4%BA4.png\" alt=\"元数据锁\"></p>\n<p>SHARED_READ与EXCLUSIVE互斥</p>\n<p><strong>意向锁</strong></p>\n<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>\n<p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p>\n<p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%811.png\" alt=\"元数据锁\"></p>\n<p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%812.png\" alt=\"元数据锁\"></p>\n<p>有了意向锁之后 :</p>\n<p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%813.png\" alt=\"元数据锁\"></p>\n<p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%814.png\" alt=\"元数据锁\"></p>\n<p> <strong>分类</strong></p>\n<p>意向共享锁(IS): 由语句select … lock in share mode添加 。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p>\n<p>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p>\n<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>\n<p>查看意向锁及行锁的加锁情况：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span> performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>意向锁演示</p>\n<p>意向共享锁(IS)与表锁共享锁兼容，与表锁排他锁互斥</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%815.png\" alt=\"元数据锁\"></p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%816.png\" alt=\"元数据锁\"></p>\n<p> 意向排他锁(IX)与表读锁、写锁都是互斥的</p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%817.png\" alt=\"元数据锁\"></p>\n<p><img src=\"/assets/images/%E6%84%8F%E5%90%91%E9%94%818.png\" alt=\"元数据锁\"></p>\n<h4 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a><strong>行级锁</strong></h4><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中.</p>\n<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的</p>\n<p>锁。对于行级锁，主要分为以下三类：</p>\n<ul>\n<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持</li>\n</ul>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%811.png\" alt=\"行锁\"></p>\n<ul>\n<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</li>\n</ul>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%812.png\" alt=\"行锁\"></p>\n<ul>\n<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li>\n</ul>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%813.png\" alt=\"行锁\"></p>\n<p><strong>行锁</strong></p>\n<p>InnoDB实现了以下两种类型的行锁：</p>\n<ul>\n<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>\n</li>\n<li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>\n</li>\n</ul>\n<p>两种行锁的兼容情况如下:</p>\n<table>\n<thead>\n<tr>\n<th>当前锁的类型</th>\n<th>请求锁的类型</th>\n<th>兼容情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S(共享锁)</td>\n<td>S(共享锁)</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>S(共享锁)</td>\n<td>X(排他锁)</td>\n<td>冲突</td>\n</tr>\n<tr>\n<td>X(排他锁)</td>\n<td>X(排他锁)</td>\n<td>冲突</td>\n</tr>\n<tr>\n<td>X(排他锁)</td>\n<td>S(共享锁)</td>\n<td>冲突</td>\n</tr>\n</tbody></table>\n<p>常见的SQL语句，在执行时，所加的行锁如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>SQL</strong></th>\n<th><strong>行锁类型</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>INSERT …</td>\n<td>排他锁</td>\n<td>自动加锁</td>\n</tr>\n<tr>\n<td>UPDATE …</td>\n<td>排他锁</td>\n<td>自动加锁</td>\n</tr>\n<tr>\n<td>DELETE …</td>\n<td>排他锁</td>\n<td>自动加锁</td>\n</tr>\n<tr>\n<td>SELECT（正常）</td>\n<td>不加任何锁</td>\n<td></td>\n</tr>\n<tr>\n<td>SELECT … LOCK IN SHARE MODE</td>\n<td>共享锁</td>\n<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>\n</tr>\n<tr>\n<td>SELECT … FOR UPDATE</td>\n<td>排他锁</td>\n<td>需要手动在SELECT之后加FOR UPDATE</td>\n</tr>\n</tbody></table>\n<p>默认情况下，InnoDB使用next-key 锁来实现 REPEATABLE READ 隔离级别，它是一种组合锁，包含索引记录锁和间隙锁。该锁的主要作用是在执行索引扫描时，对于所查找的每条记录，都要获取记录锁以及对应的间隙锁，以保证事务在读取数据时不会出现幻读问题。</p>\n<ul>\n<li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p>\n</li>\n<li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</p>\n</li>\n</ul>\n<p>查看意向锁及行锁的加锁情况：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> object_schema<span class=\"token punctuation\">,</span>object_name<span class=\"token punctuation\">,</span>index_name<span class=\"token punctuation\">,</span>lock_type<span class=\"token punctuation\">,</span>lock_mode<span class=\"token punctuation\">,</span>lock_data <span class=\"token keyword\">from</span> performance_schema<span class=\"token punctuation\">.</span>data_locks<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 演示：表结构如下</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>stu<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n<span class=\"token identifier\"><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n<span class=\"token identifier\"><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n<span class=\"token identifier\"><span class=\"token punctuation\">`</span>age<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">CHARACTER</span> <span class=\"token keyword\">SET</span> <span class=\"token operator\">=</span> utf8mb4<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%814.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%815.png\" alt=\"行锁\"></p>\n<p>共享锁与排他锁之间互斥。</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%816.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%817.png\" alt=\"行锁\"></p>\n<p>无索引行锁升级为表锁</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%818.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%819.png\" alt=\"行锁\"></p>\n<p>开启事务，并执行update语句，更新name为tom的数据 。然后在另一个会话中更新name为rose的记录，却不能直接执行，会处于阻塞状态。原因就是，会话一根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁（因为行锁是对索引项加的锁，而name没有索引）</p>\n<p>再针对name字段建立索引，索引建立之后，再次做一个测试：</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8110.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8111.png\" alt=\"行锁\"></p>\n<p>这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</p>\n<p><strong>间隙锁&amp;临键锁</strong></p>\n<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。临键锁（Next-Key Lock）是InnoDB引擎在实现间隙锁（Gap Lock）时所加的锁，其作用是锁定间隙并保护间隙内的下一个记录，以防止其他事务在间隙内插入记录。</p>\n<ul>\n<li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p>\n</li>\n<li><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key锁退化为间隙锁。</p>\n</li>\n<li><p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>\n</li>\n</ul>\n<p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>\n<p><strong>示例演示</strong></p>\n<p> 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8112.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8113.png\" alt=\"行锁\"></p>\n<p>查询（加共享锁）或者更新不存在的记录时，行锁（S或者X）会优化成间隙锁（GAP）,当在加了间隙锁的范围内insert插入数据时会阻塞，update&#x2F;delete不会阻塞。</p>\n<p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key锁退化为间隙锁。 </p>\n<p>InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%81.png\" alt=\"行锁\"></p>\n<p>假设我们有一个索引列a，对于值1到5之间的区间，如果我们设置了临键锁，那么除了a&#x3D;1和a&#x3D;5两条索引记录上的锁，还会锁住1&lt;a&lt;2, 2&lt;a&lt;3, 3&lt;a&lt;4和4&lt;a&lt;5这四个间隙上，以保护在该区间范围内下一个可能插入的记录不被其他事务插入。</p>\n<p><strong>示例</strong></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8114.png\" alt=\"行锁\"></p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8115.png\" alt=\"行锁\"></p>\n<p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止</p>\n<p><img src=\"/assets/images/%E8%A1%8C%E9%94%8116.png\" alt=\"行锁\"></p>\n<p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p>\n<p>[19]</p>\n<p>(19,25]</p>\n<p>(25,+∞]</p>\n<p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p>\n","feature":true,"text":"锁​ 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%81\"><span class=\"toc-text\">锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E9%94%81\"><span class=\"toc-text\">全局锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">表级锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">行级锁</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"InnoDB存储引擎_MVCC原理","uid":"12e6f0c825691db3e38970eadda0c57d","slug":"InnoDB存储引擎-MVCC原理","date":"2023-05-20T02:00:56.000Z","updated":"2023-05-20T09:10:10.924Z","comments":true,"path":"api/articles/InnoDB存储引擎-MVCC原理.json","keywords":null,"cover":[],"text":"InnoDB引擎逻辑存储结构InnoDB的逻辑存储结构如下图所示: 表空间 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"基于session实现认证","uid":"7a80ec680e8c46b9ee58692b58f8ab63","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","updated":"2023-05-18T16:15:24.710Z","comments":true,"path":"api/articles/基于session实现认证.json","keywords":null,"cover":[],"text":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。 什么是会话用户认证通过后，为了避免用户的每...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":1,"path":"api/tags/认证授权.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}