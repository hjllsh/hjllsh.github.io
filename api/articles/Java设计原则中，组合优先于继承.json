{"title":"Java设计原则中，组合优先于继承","uid":"3790eb53c6264ff24e57195f4b6f77f1","slug":"Java设计原则中，组合优先于继承","date":"2023-06-03T13:35:14.000Z","updated":"2023-06-03T14:13:46.326Z","comments":true,"path":"api/articles/Java设计原则中，组合优先于继承.json","keywords":null,"cover":[],"content":"<h3 id=\"Java-设计原则中，为什么反复强调组合要优先于继承？\"><a href=\"#Java-设计原则中，为什么反复强调组合要优先于继承？\" class=\"headerlink\" title=\"Java 设计原则中，为什么反复强调组合要优先于继承？\"></a>Java 设计原则中，为什么反复强调组合要优先于继承？</h3><p>在《阿里巴巴Java开发手册》中有一条规定：<strong>谨慎使用继承的方式进行扩展，优先使用组合的方式实现。</strong></p>\n<p><strong>为什么不推荐使用继承</strong></p>\n<p>是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。</p>\n<p>假设我们要设计一个关于鸟的类。我们将“鸟”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird抽象类中，定义一个fly()方法呢？</p>\n<p>答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有fly()方法的父类，那鸵鸟就具有“飞”这样的行为，虽然它可以独自抛出异常，但不优雅。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractBird</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//...省略其他属性和方法...</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ostrich</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractBird</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//鸵鸟</span>\n  <span class=\"token comment\">//...省略其他属性和方法...</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnSupportedMethodException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I can't fly.'\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，全部都去重写fly()方法，抛出异常，完全属于代码重复。理论上这些不会飞的鸟根本就不应该拥有fly()方法，让不会飞的鸟暴露fly()接口给外部，增加了被误用的概率。</p>\n<p>要解决上面的问题，就得让AbstractBird类派生出两个更加细分的抽象类：会飞的鸟类AbstractFlyableBird和不会飞的鸟类AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类。</p>\n<p>具体的继承关系如下图所示：</p>\n<p><img src=\"/../assets/images/%E9%B8%9F%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png\"></p>\n<p>这样一来，继承关系变成了三层。但是如果我们不只关注“鸟会不会飞”，还要继续关注“鸟会不会叫”，将鸟划分得更加细致时呢？两个关注行为自由搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果继续沿用刚才的设计思路，继承层次会再次加深。</p>\n<p>类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p>\n<p><strong>组合相比继承有哪些优势</strong></p>\n<p>复用性是面向对象技术带来的很棒的潜在好处，代码复用是Java引人注意的功能之一。</p>\n<p>Java代码的复用有继承、组合以及委托三种具体的实现形式。</p>\n<p>对于上面提到的继承带来的问题，可以利用组合（composition）、接口、委托（delegation）三个技术手段一块儿来解决。</p>\n<p>接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个Flyable接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义Tweetable接口、EggLayable接口。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Flyable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Tweetable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ostrich</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Tweetable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//鸵鸟</span>\n  <span class=\"token comment\">//... 省略其他属性和方法...</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sparrow</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Flayable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Tweetable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//麻雀</span>\n  <span class=\"token comment\">//... 省略其他属性和方法...</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//... &#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不过，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑几乎是一样的（可能极少场景下会不一样），这就会导致代码重复的问题。那这个问题又该如何解决呢？有以下两种方法。</p>\n<p><strong>使用委托</strong></p>\n<p>针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的 FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的 EggLayAbility类。然后，通过组合和委托技术来消除代码重复。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Flyable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>；\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FlyAbility</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Flyable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ostrich</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Tweetable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//鸵鸟</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">TweetAbility</span> tweetAbility <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TweetAbility</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//组合</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">EggLayAbility</span> eggLayAbility <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EggLayAbility</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//组合</span>\n  <span class=\"token comment\">//... 省略其他属性和方法...</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    tweetAbility<span class=\"token punctuation\">.</span><span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 委托</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    eggLayAbility<span class=\"token punctuation\">.</span><span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 委托</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>使用Java8的接口默认方法</strong></p>\n<p>在Java8中，我们可以在接口中写默认实现方法。使用关键字default定义默认接口实现，当然这个默认的方法也可以重写。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Flyable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">default</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//默认实现...</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Flyable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">default</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//默认实现...</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Tweetable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">default</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tweet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//默认实现...</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">default</span> <span class=\"token keyword\">void</span> <span class=\"token function\">layEgg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//默认实现...</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ostrich</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Tweetable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//鸵鸟</span>\n  <span class=\"token comment\">//... 省略其他属性和方法...</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sparrow</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Flayable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Tweetable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">EggLayable</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//麻雀</span>\n  <span class=\"token comment\">//... 省略其他属性和方法...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>继承主要有三个作用：表示is-a关系、支持多态特性、代码复用。</p>\n<p>而这三个作用都可以通过其他技术手段来达成，比如：</p>\n<ul>\n<li>is-a关系，我们可以通过组合和接口的has-a关系来替代</li>\n<li>多态特性我们也可以利用接口来实现</li>\n<li>代码复用我们可以通过组合和委托来实现。</li>\n</ul>\n<p>从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>\n<p><strong>如何判断该用组合还是继承</strong></p>\n<p>尽管鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。</p>\n<p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p>\n<p>文章来源：<br><a href=\"https://www.toutiao.com/article/7236761866775560737?wid=1685799375173\">「后端」Java 设计原则中，为什么反复强调组合要优先于继承？-今日头条 (toutiao.com)</a></p>\n","text":"Java 设计原则中，为什么反复强调组合要优先于继承？在《阿里巴巴Java开发手册》中有一条规定：谨慎使用继承的方式进行扩展，优先使用组合的方式实现。 为什么不推荐使用继承 是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":18,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8D%E5%A4%8D%E5%BC%BA%E8%B0%83%E7%BB%84%E5%90%88%E8%A6%81%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF%EF%BC%9F\"><span class=\"toc-text\">Java 设计原则中，为什么反复强调组合要优先于继承？</span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CompletableFuture原理与实战","uid":"e6ecbb75a271638e27405d472d7b664c","slug":"CompletableFuture原理与实战","date":"2023-06-04T03:03:29.000Z","updated":"2023-06-04T03:03:29.678Z","comments":true,"path":"api/articles/CompletableFuture原理与实战.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Redis基础","uid":"b6845422ba4775a7cab0c414606e3ecd","slug":"Redis基础","date":"2023-06-02T14:33:03.000Z","updated":"2023-06-03T15:50:35.971Z","comments":true,"path":"api/articles/Redis基础.json","keywords":null,"cover":[],"text":"认识NoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化​ 传统关系型数据库是结构化数据，每一张表都有严格的约束...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}