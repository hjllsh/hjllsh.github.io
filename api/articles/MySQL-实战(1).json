{"title":"MySQL实战","uid":"11fe232dbef934e03d9537a3a12675e0","slug":"MySQL-实战(1)","date":"2023-06-14T07:25:58.000Z","updated":"2023-06-14T13:13:20.284Z","comments":true,"path":"api/articles/MySQL-实战(1).json","keywords":null,"cover":[],"content":"<h3 id=\"不建议使用长事务\"><a href=\"#不建议使用长事务\" class=\"headerlink\" title=\"不建议使用长事务\"></a>不建议使用长事务</h3><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录</p>\n<p><img src=\"/../assets/mysql/image-20230614152902572.png\" alt=\"image-20230614152902572\"></p>\n<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>\n<p>即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>\n<p>回滚日志总不能一直保留吧，什么时候删除呢？</p>\n<p>答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>\n<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>\n<h3 id=\"事务的启动方式\"><a href=\"#事务的启动方式\" class=\"headerlink\" title=\"事务的启动方式\"></a>事务的启动方式</h3><p>长事务有这些潜在风险，当然是建议尽量避免。其实很多时候并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>\n<ol>\n<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li>\n<li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li>\n</ol>\n<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>\n<p>因此，建议总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p>\n<p>对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你有这个顾虑，我建议你使用commit work and chain语法。在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>\n<p>可以在information_schema库的innodb_trx这个表中查询长事务</p>\n<p>比如下面这个语句，用于查找持续时间超过60s的事务。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> information_schema<span class=\"token punctuation\">.</span>innodb_trx <span class=\"token keyword\">where</span> TIME_TO_SEC<span class=\"token punctuation\">(</span>timediff<span class=\"token punctuation\">(</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>trx_started<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">60</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><h3 id=\"索引的常见模型\"><a href=\"#索引的常见模型\" class=\"headerlink\" title=\"索引的常见模型\"></a>索引的常见模型</h3><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种。常见、也比较简单的数据结构索引，它们分别是哈希表、有序数组和搜索树</p>\n<p>哈希表是一种以键-值（key-value）存储数据的结构，不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况，处理方法是，拉出一个链表。哈希表这种结构适用于只有<strong>等值查询</strong>的场景。</p>\n<p>有序数组，在等值查询和范围查询场景中的性能就都非常优秀，用二分法就可以快速得到，这个时间复杂度是O(log(N))。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。有序数组索引只适用于静态存储引擎，</p>\n<p>二叉搜索树，每个节点的左儿子小于父节点，父节点又小于右儿子，时间复杂度是O(log(N))，为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>\n<h3 id=\"InnoDB-的索引模型\"><a href=\"#InnoDB-的索引模型\" class=\"headerlink\" title=\"InnoDB 的索引模型\"></a>InnoDB 的索引模型</h3><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。</p>\n<p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p>\n<ul>\n<li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li>\n<li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li>\n</ul>\n<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>\n<h3 id=\"索引维护\"><a href=\"#索引维护\" class=\"headerlink\" title=\"索引维护\"></a>索引维护</h3><p><img src=\"/../assets/mysql/image-20230614164337432.png\" alt=\"image-20230614164337432\"></p>\n<p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>\n<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p>\n<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>\n<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>\n<p>分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>\n<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>\n<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>\n<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>\n<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>\n<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>\n<p>适合用业务字段直接做主键的场景：典型的KV场景</p>\n<ol>\n<li>只有一个索引；</li>\n<li>该索引必须是唯一索引。</li>\n</ol>\n<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题</p>\n<h3 id=\"有没有可能经过索引优化，避免回表过程呢？\"><a href=\"#有没有可能经过索引优化，避免回表过程呢？\" class=\"headerlink\" title=\"有没有可能经过索引优化，避免回表过程呢？\"></a>有没有可能经过索引优化，避免回表过程呢？</h3><h4 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h4><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>\n<h5 id=\"在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？\"><a href=\"#在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？\" class=\"headerlink\" title=\"在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？\"></a>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</h5><p>身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>\n<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，身份证号、姓名的联合索引可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>\n<h4 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h4><p>要按照市民的身份证号去查他的家庭地址，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>\n<p>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录</p>\n<p><img src=\"/../assets/mysql/image-20230614174219671.png\" alt=\"image-20230614174219671\"></p>\n<p>索引项是按照索引定义里面出现的字段顺序排序的</p>\n<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>\n<p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p>\n<p>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>\n<p>在建立联合索引的时候，如何安排索引内的字段顺序？</p>\n<p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>\n<p>如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。这时候，我们要考虑的原则就是空间了。比如name字段是比age字段大的，建议创建一个（name,age)的联合索引和一个(age)的单字段索引。</p>\n<h4 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h4><p>以联合索引（name, age）为例，检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tuser <span class=\"token keyword\">where</span> name <span class=\"token operator\">like</span> <span class=\"token string\">'张%'</span> <span class=\"token operator\">and</span> age<span class=\"token operator\">=</span><span class=\"token number\">10</span> <span class=\"token operator\">and</span> ismale<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3，然后判断其他条件是否满足</p>\n<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>\n<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<p><img src=\"/../assets/mysql/image-20230614181457578.png\" alt=\"image-20230614181457578\"></p>\n<p>在(name,age)索引里面没有age的where条件，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p>\n<p><img src=\"/../assets/mysql/image-20230614181507549.png\" alt=\"image-20230614181507549\"></p>\n<p>InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>\n<h3 id=\"主键索引也是可以使用多个字段的\"><a href=\"#主键索引也是可以使用多个字段的\" class=\"headerlink\" title=\"主键索引也是可以使用多个字段的\"></a>主键索引也是可以使用多个字段的</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>geek<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>a<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>b<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>c<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token identifier\"><span class=\"token punctuation\">`</span>d<span class=\"token punctuation\">`</span></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>a<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>b<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>c<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>c<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>ca<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>c<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>a<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token identifier\"><span class=\"token punctuation\">`</span>cb<span class=\"token punctuation\">`</span></span> <span class=\"token punctuation\">(</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>c<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">,</span><span class=\"token identifier\"><span class=\"token punctuation\">`</span>b<span class=\"token punctuation\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了。为什么要创建“ca”，“cb”这两个索引？</p>\n<p>看这样的两种语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> geek <span class=\"token keyword\">where</span> c<span class=\"token operator\">=</span> N <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> a <span class=\"token keyword\">limit</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> geek <span class=\"token keyword\">where</span> c<span class=\"token operator\">=</span> N <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> b <span class=\"token keyword\">limit</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>表记录<br>–a–|–b–|–c–|–d–<br>1 2 3 d<br>1 3 2 d<br>1 4 3 d<br>2 1 3 d<br>2 2 2 d<br>2 3 4 d<br>主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。</p>\n<p>索引 ca 的组织是先按c排序，再按a排序，同时记录主键<br>–c–|–a–|–主键部分b– （注意，这里不是ab，而是只有b）<br>2 1 3<br>2 2 2<br>3 1 2<br>3 1 4<br>3 2 1<br>4 2 3<br><strong>这个跟索引c的数据是一模一样的。</strong></p>\n<p>索引 cb 的组织是先按c排序，在按b排序，同时记录主键<br>–c–|–b–|–主键部分a– （同上）<br>2 2 2<br>2 3 1<br>3 1 2<br>3 2 1<br>3 4 1<br>4 3 2</p>\n<p>所以，结论是ca可以去掉，cb需要保留。</p>\n","feature":true,"text":"不建议使用长事务假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":12,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E9%95%BF%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">不建议使用长事务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">事务的启动方式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">索引的常见模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InnoDB-%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">InnoDB 的索引模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">索引维护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E7%BB%8F%E8%BF%87%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8C%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%E8%BF%87%E7%A8%8B%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">有没有可能经过索引优化，避免回表过程呢？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">覆盖索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B8%82%E6%B0%91%E4%BF%A1%E6%81%AF%E8%A1%A8%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E5%B0%86%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E5%92%8C%E5%90%8D%E5%AD%97%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F\"><span class=\"toc-text\">在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">最左前缀原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8\"><span class=\"toc-text\">索引下推</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B9%9F%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84\"><span class=\"toc-text\">主键索引也是可以使用多个字段的</span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Git经典场景操作","uid":"a23f2d002fc146791ed8e3604cc7ab69","slug":"Git经典场景操作","date":"2023-06-14T14:29:11.000Z","updated":"2023-06-15T09:24:45.887Z","comments":true,"path":"api/articles/Git经典场景操作.json","keywords":null,"cover":[],"text":"Git常用命令 命令名称 作用 git config –global user.name 用户名 设置用户签名 git config –global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Mybatis(一)","uid":"9f1c39845db12e0e40a2bf8f9721b61a","slug":"Mybatis(1)","date":"2023-06-14T02:03:59.000Z","updated":"2023-06-14T13:16:35.005Z","comments":true,"path":"api/articles/Mybatis(1).json","keywords":null,"cover":[],"text":"MybatisMyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几 乎所有的 JDBC 代码和手动设置参数以及 获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}