{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-06-18T11:35:24.000Z","updated":"2023-06-19T11:59:30.726Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"content":"<h2 id=\"JVM-内存结构\"><a href=\"#JVM-内存结构\" class=\"headerlink\" title=\"JVM 内存结构\"></a>JVM 内存结构</h2><p><img src=\"/../assets/JVM/image-20210831165728217.png\" alt=\"image-20210831165728217\"></p>\n<ul>\n<li>执行 javac 命令编译源代码为字节码</li>\n<li>执行 java 命令<ol>\n<li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li>\n<li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li>\n<li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li>\n<li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li>\n<li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li>\n<li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li>\n<li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li>\n<li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li>\n<li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li>\n<li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li>\n</ol>\n</li>\n</ul>\n<p>说明</p>\n<ul>\n<li>加粗字体代表了 JVM 虚拟机组件</li>\n<li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li>\n</ul>\n<p><strong>会发生内存溢出的区域</strong></p>\n<ul>\n<li>不会出现内存溢出的区域 – 程序计数器</li>\n<li>出现 OutOfMemoryError 的情况<ul>\n<li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li>\n<li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li>\n<li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li>\n</ul>\n</li>\n<li>出现 StackOverflowError 的区域<ul>\n<li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li>\n</ul>\n</li>\n</ul>\n<p><strong>方法区、永久代、元空间</strong></p>\n<ul>\n<li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li>\n<li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li>\n<li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li>\n</ul>\n<p><img src=\"/../assets/JVM/image-20210831170457337.png\" alt=\"image-20210831170457337\"></p>\n<p>从这张图学到三点</p>\n<ul>\n<li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li>\n<li>X，Y 的类元信息是存储于元空间中，无法直接访问</li>\n<li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li>\n</ul>\n<p><img src=\"/../assets/JVM/image-20210831170512418.png\" alt=\"image-20210831170512418\"></p>\n<p>从这张图可以学到</p>\n<ul>\n<li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li>\n<li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li>\n</ul>\n<h2 id=\"JVM-内存参数\"><a href=\"#JVM-内存参数\" class=\"headerlink\" title=\"JVM 内存参数\"></a>JVM 内存参数</h2><h3 id=\"堆内存，按大小设置\"><a href=\"#堆内存，按大小设置\" class=\"headerlink\" title=\"堆内存，按大小设置\"></a>堆内存，按大小设置</h3><p><img src=\"/../assets/JVM/image-20210831173130717.png\" alt=\"image-20210831173130717\"></p>\n<p>解释：</p>\n<ul>\n<li>-Xms 最小堆内存（包括新生代和老年代）</li>\n<li>-Xmx 最大堆内存（包括新生代和老年代）</li>\n<li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li>\n<li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li>\n<li>-Xmn 设置<strong>新生代</strong>大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li>\n<li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li>\n</ul>\n<h3 id=\"堆内存，按比例设置\"><a href=\"#堆内存，按比例设置\" class=\"headerlink\" title=\"堆内存，按比例设置\"></a>堆内存，按比例设置</h3><p><img src=\"/../assets/JVM/image-20210831173045700.png\" alt=\"image-20210831173045700\"></p>\n<p>解释：</p>\n<ul>\n<li>-XX:NewRatio&#x3D;2:1 表示老年代占两份，新生代占一份</li>\n<li>-XX:SurvivorRatio&#x3D;4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li>\n</ul>\n<h3 id=\"元空间内存设置\"><a href=\"#元空间内存设置\" class=\"headerlink\" title=\"元空间内存设置\"></a>元空间内存设置</h3><p><img src=\"/../assets/JVM/image-20210831173118634.png\" alt=\"image-20210831173118634\"></p>\n<p>解释：</p>\n<ul>\n<li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li>\n<li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li>\n<li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li>\n</ul>\n<p><strong>代码缓存内存设置</strong></p>\n<p><img src=\"/../assets/JVM/image-20210831173148816.png\" alt=\"image-20210831173148816\"></p>\n<p>解释：</p>\n<ul>\n<li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li>\n<li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul>\n<li>non-nmethods - JVM 自己用的代码</li>\n<li>profiled nmethods - 部分优化的机器码</li>\n<li>non-profiled nmethods - 完全优化的机器码</li>\n</ul>\n</li>\n</ul>\n<p><strong>线程内存设置</strong></p>\n<p><img src=\"/../assets/JVM/image-20210831173155481.png\" alt=\"image-20210831173155481\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><em><strong>官方参考文档</strong></em></p>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE\">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li>\n</ul></blockquote>\n<h2 id=\"JVM-垃圾回收\"><a href=\"#JVM-垃圾回收\" class=\"headerlink\" title=\"JVM 垃圾回收\"></a>JVM 垃圾回收</h2><h3 id=\"三种垃圾回收算法\"><a href=\"#三种垃圾回收算法\" class=\"headerlink\" title=\"三种垃圾回收算法\"></a>三种垃圾回收算法</h3><h4 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h4><p><img src=\"/../assets/JVM/image-20210831211008162.png\" alt=\"image-20210831211008162\"></p>\n<p>解释：</p>\n<ol>\n<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>\n<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>\n<li>清除阶段：释放未加标记的对象占用的内存</li>\n</ol>\n<p>要点：</p>\n<ul>\n<li>标记速度与存活对象线性关系</li>\n<li>清除速度与内存大小线性关系</li>\n<li>缺点是会产生内存碎片</li>\n</ul>\n<h4 id=\"标记整理法\"><a href=\"#标记整理法\" class=\"headerlink\" title=\"标记整理法\"></a>标记整理法</h4><p><img src=\"/../assets/JVM/image-20210831211641241.png\" alt=\"image-20210831211641241\"></p>\n<p>解释：</p>\n<ol>\n<li>前面的标记阶段、清理阶段与标记清除法类似</li>\n<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li><p>标记速度与存活对象线性关系</p>\n</li>\n<li><p>清除与整理速度与内存大小成线性关系</p>\n</li>\n<li><p>缺点是性能上<strong>较慢</strong></p>\n</li>\n</ul>\n<h4 id=\"标记复制法\"><a href=\"#标记复制法\" class=\"headerlink\" title=\"标记复制法\"></a>标记复制法</h4><p><img src=\"/../assets/JVM/image-20210831212125813.png\" alt=\"image-20210831212125813\"></p>\n<p>解释：</p>\n<ol>\n<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>\n<li>标记阶段与前面的算法类似</li>\n<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>\n<li>复制完成后，交换 from 和 to 的位置即可</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li>标记与复制速度与存活对象成线性关系</li>\n<li>缺点是会占用成倍的空间</li>\n</ul>\n<h3 id=\"GC-与分代回收算法\"><a href=\"#GC-与分代回收算法\" class=\"headerlink\" title=\"GC 与分代回收算法\"></a>GC 与分代回收算法</h3><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p>\n<p>GC 要点：</p>\n<ul>\n<li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li>\n<li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>\n<li>GC 具体的实现称为<strong>垃圾回收器</strong></li>\n<li>GC 大都采用了<strong>分代回收思想</strong><ul>\n<li>理论依据是大部分对象用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li>\n<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用<strong>标记复制法</strong>、老年代一般采用<strong>标记整理法</strong></li>\n</ul>\n</li>\n<li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li>\n</ul>\n<h4 id=\"分代回收\"><a href=\"#分代回收\" class=\"headerlink\" title=\"分代回收\"></a>分代回收</h4><ol>\n<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213622704.png\" alt=\"image-20210831213622704\"></p>\n<ol start=\"2\">\n<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213640110.png\" alt=\"image-20210831213640110\"></p>\n<ol start=\"3\">\n<li>将存活对象采用复制算法复制到 <strong>to</strong> 中，复制完毕后，伊甸园和 from 内存都得到释放</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213657861.png\" alt=\"image-20210831213657861\"></p>\n<ol start=\"4\">\n<li>将 from 和 to 交换位置</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213708776.png\" alt=\"image-20210831213708776\"></p>\n<ol start=\"5\">\n<li>经过一段时间后伊甸园的内存又出现不足</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213724858.png\" alt=\"image-20210831213724858\"></p>\n<ol start=\"6\">\n<li>标记伊甸园与 from（现阶段没有）的存活对象</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213737669.png\" alt=\"image-20210831213737669\"></p>\n<ol start=\"7\">\n<li>将存活对象采用复制算法复制到 to 中</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213804315.png\" alt=\"image-20210831213804315\"></p>\n<ol start=\"8\">\n<li>复制完毕后，伊甸园和 from 内存都得到释放</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213815371.png\" alt=\"image-20210831213815371\"></p>\n<ol start=\"9\">\n<li>将 from 和 to 交换位置</li>\n</ol>\n<p><img src=\"/../assets/JVM/image-20210831213826017.png\" alt=\"image-20210831213826017\"></p>\n<ol start=\"10\">\n<li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>\n</ol>\n<p><strong>GC 规模</strong></p>\n<ul>\n<li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>\n</li>\n<li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>\n</li>\n<li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>\n</li>\n</ul>\n<p>·</p>\n<h4 id=\"三色标记\"><a href=\"#三色标记\" class=\"headerlink\" title=\"三色标记\"></a>三色标记</h4><p>即用三种颜色记录对象的标记状态</p>\n<ul>\n<li>黑色 – 已标记</li>\n<li>灰色 – 标记中</li>\n<li>白色 – 还未标记</li>\n</ul>\n<ol>\n<li>起始的三个对象还未处理完成，用灰色表示</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215016566.png\" alt=\"image-20210831215016566\" style=\"zoom:50%;\" />\n\n<ol start=\"2\">\n<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215033510.png\" alt=\"image-20210831215033510\" style=\"zoom:50%;\" />\n\n<ol start=\"3\">\n<li>依次类推</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215105280.png\" alt=\"image-20210831215105280\" style=\"zoom:50%;\" />\n\n<ol start=\"4\">\n<li>沿着引用链都标记了一遍</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215146276.png\" alt=\"image-20210831215146276\" style=\"zoom:50%;\" />\n\n<ol start=\"5\">\n<li>最后为标记的白色对象，即为垃圾</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215158311.png\" alt=\"image-20210831215158311\" style=\"zoom:50%;\" />\n\n<p><strong>并发漏标问题</strong></p>\n<p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>\n<ol>\n<li>如图所示标记工作尚未完成</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215846876.png\" alt=\"image-20210831215846876\" style=\"zoom:50%;\" />\n\n<ol start=\"2\">\n<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215904073.png\" alt=\"image-20210831215904073\" style=\"zoom:50%;\" />\n\n<ol start=\"3\">\n<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831215919493.png\" alt=\"image-20210831215919493\" style=\"zoom:50%;\" />\n\n<ol start=\"4\">\n<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831220004062.png\" alt=\"image-20210831220004062\" style=\"zoom:50%;\" />\n\n<p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p>\n<ol>\n<li>Incremental Update <strong>增量更新法</strong>，CMS 垃圾回收器采用<ul>\n<li>思路是拦截每次赋值动作，只要<strong>赋值发生</strong>，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li>\n</ul>\n</li>\n<li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul>\n<li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li>\n<li>新加对象会被记录</li>\n<li>被删除引用关系的对象也被记录</li>\n</ul>\n</li>\n</ol>\n<p><strong>垃圾回收器 - Parallel GC</strong></p>\n<ul>\n<li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p>\n</li>\n<li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p>\n</li>\n<li><p><strong>注重吞吐量</strong></p>\n</li>\n</ul>\n<p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p>\n<ul>\n<li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p>\n<ul>\n<li>并发标记时不需暂停用户线程</li>\n<li>重新标记时仍需暂停用户线程</li>\n</ul>\n</li>\n<li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p>\n</li>\n<li><p><strong>注重响应时间</strong></p>\n</li>\n</ul>\n<p><strong>垃圾回收器 - G1 GC</strong></p>\n<ul>\n<li><strong>响应时间与吞吐量兼顾</strong></li>\n<li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li>\n<li>分成三个阶段：新生代回收、并发标记、混合收集</li>\n<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>\n</ul>\n<p><strong>G1 回收阶段 - 新生代回收</strong></p>\n<ol>\n<li>初始时，所有区域都处于空闲状态</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222639754.png\" alt=\"image-20210831222639754\" style=\"zoom:50%;\" />\n\n<ol start=\"2\">\n<li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222653802.png\" alt=\"image-20210831222653802\" style=\"zoom:50%;\" />\n\n<ol start=\"3\">\n<li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222705814.png\" alt=\"image-20210831222705814\" style=\"zoom:50%;\" />\n\n<ol start=\"4\">\n<li>复制完成，将之前的伊甸园内存释放</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222724999.png\" alt=\"image-20210831222724999\" style=\"zoom:50%;\" />\n\n<ol start=\"5\">\n<li>随着时间流逝，伊甸园的内存又有不足</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222737928.png\" alt=\"image-20210831222737928\" style=\"zoom:50%;\" />\n\n<ol start=\"6\">\n<li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222752787.png\" alt=\"image-20210831222752787\" style=\"zoom:50%;\" />\n\n<ol start=\"7\">\n<li>释放伊甸园以及之前幸存区的内存</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222803281.png\" alt=\"image-20210831222803281\" style=\"zoom:50%;\" />\n\n<p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p>\n<ol>\n<li>当老年代占用内存超过阈值后，触发并发标记，这时<strong>无需暂停用户线程</strong></li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222813959.png\" alt=\"image-20210831222813959\" style=\"zoom:50%;\" />\n\n<ol start=\"2\">\n<li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222828104.png\" alt=\"image-20210831222828104\" style=\"zoom:50%;\" />\n\n<ol start=\"3\">\n<li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222841096.png\" alt=\"image-20210831222841096\" style=\"zoom:50%;\" />\n\n<ol start=\"4\">\n<li>下图显示了老年代和幸存区晋升的存活对象的复制</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222859760.png\" alt=\"image-20210831222859760\" style=\"zoom:50%;\" />\n\n<ol start=\"5\">\n<li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li>\n</ol>\n<img src=\"../assets/JVM/image-20210831222919182.png\" alt=\"image-20210831222919182\" style=\"zoom:50%;\" />\n\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h5 id=\"类加载过程的三个阶段\"><a href=\"#类加载过程的三个阶段\" class=\"headerlink\" title=\"类加载过程的三个阶段\"></a>类加载过程的三个阶段</h5><ol>\n<li><p>加载</p>\n<ol>\n<li><p>将类的字节码载入方法区，并创建类.class 对象</p>\n</li>\n<li><p>如果此类的父类没有加载，先加载父类</p>\n</li>\n<li><p>加载是懒惰执行</p>\n</li>\n</ol>\n</li>\n<li><p>链接</p>\n<ol>\n<li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li>\n<li>准备 – 为 static 变量分配空间，设置默认值</li>\n<li>解析 – 将常量池的符号引用解析为直接引用</li>\n</ol>\n</li>\n<li><p>初始化</p>\n<ol>\n<li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li>\n<li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li>\n<li>初始化是懒惰执行</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h5><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p>\n<ul>\n<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li>\n<li>找不到这个类，则下级类加载器才有资格执行加载</li>\n</ul>\n<p>双亲委派的目的有两点</p>\n<ol>\n<li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p>\n</li>\n<li><p>让类的加载有优先次序，保证核心类优先加载</p>\n</li>\n</ol>\n<p><strong>jdk 8 的类加载器</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>加载哪的类</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bootstrap ClassLoader</td>\n<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>\n<td>无法直接访问</td>\n</tr>\n<tr>\n<td>Extension ClassLoader</td>\n<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>\n<td>上级为 Bootstrap，显示为  null</td>\n</tr>\n<tr>\n<td>Application ClassLoader</td>\n<td>classpath</td>\n<td>上级为 Extension</td>\n</tr>\n<tr>\n<td>自定义类加载器</td>\n<td>自定义</td>\n<td>上级为 Application</td>\n</tr>\n</tbody></table>\n<p><strong>对双亲委派的误解</strong></p>\n<p>下面面试题的回答是错误的</p>\n<p><img src=\"/../assets/JVM/image-20210901110910016.png\" alt=\"image-20210901110910016\"></p>\n<p>错在哪了？</p>\n<ul>\n<li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p>\n</li>\n<li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p>\n</li>\n<li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p>\n</li>\n<li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p>\n</li>\n</ul>\n<h2 id=\"四种引用\"><a href=\"#四种引用\" class=\"headerlink\" title=\"四种引用\"></a>四种引用</h2><p><strong>强引用</strong></p>\n<ol>\n<li><p>普通变量赋值即为强引用，如 A a &#x3D; new A();</p>\n</li>\n<li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p>\n</li>\n</ol>\n<img src=\"../assets/JVM/image-20210901111903574.png\" alt=\"image-20210901111903574\" style=\"zoom:80%;\" />\n\n<p><strong>软引用（SoftReference）</strong></p>\n<ol>\n<li><p>例如：SoftReference a &#x3D; new SoftReference(new A());</p>\n</li>\n<li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p>\n</li>\n<li><p>软引用自身需要配合<strong>引用队列</strong>来释放</p>\n</li>\n<li><p>典型例子是反射数据</p>\n</li>\n</ol>\n<img src=\"../assets/JVM/image-20210901111957328.png\" alt=\"image-20210901111957328\" style=\"zoom:80%;\" />\n\n\n\n<p><strong>弱引用（WeakReference）</strong></p>\n<ol>\n<li><p>例如：WeakReference a &#x3D; new WeakReference(new A());</p>\n</li>\n<li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p>\n</li>\n<li><p>弱引用自身需要配合引用队列来释放</p>\n</li>\n<li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p>\n</li>\n</ol>\n<img src=\"../assets/JVM/image-20210901112107707.png\" alt=\"image-20210901112107707\" style=\"zoom:80%;\" />\n\n\n\n<p><strong>虚引用（PhantomReference）</strong></p>\n<ol>\n<li><p>例如： PhantomReference a &#x3D; new PhantomReference(new A(), referenceQueue);</p>\n</li>\n<li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p>\n</li>\n<li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p>\n</li>\n</ol>\n<img src=\"../assets/JVM/image-20210901112157901.png\" alt=\"image-20210901112157901\" style=\"zoom:80%;\" />\n\n<h3 id=\"JDK与JVM有什么区别？\"><a href=\"#JDK与JVM有什么区别？\" class=\"headerlink\" title=\"JDK与JVM有什么区别？\"></a>JDK与JVM有什么区别？</h3><p>现在的JDK、JRE和JVM一般是整套出现的。</p>\n<p>JDK &#x3D; JRE + 开发调试诊断工具</p>\n<p>JRE &#x3D; JVM + Java标准库</p>\n<h3 id=\"JVM厂商\"><a href=\"#JVM厂商\" class=\"headerlink\" title=\"JVM厂商\"></a>JVM厂商</h3><p>常见的JDK厂商包括：Oracle公司，包括 Hotspot虚拟机、GraalVM；分为OpenJDK和OracleJDK两种</p>\n","feature":true,"text":"JVM 内存结构 执行 javac 命令编译源代码为字节码 执行 java 命令 创建 JVM，调用类加载子系统加载 class，将类的信息存入方法区 创建 main 线程，使用的内存区域是 JVM 虚拟机栈，开始执行 main 方法代码 如果遇到了未见过的类，会继续触发类加载过...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":29,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">JVM 内存结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM-%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">JVM 内存参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%8C%E6%8C%89%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">堆内存，按大小设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%8C%E6%8C%89%E6%AF%94%E4%BE%8B%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">堆内存，按比例设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">元空间内存设置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">JVM 垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">三种垃圾回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">标记清除法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95\"><span class=\"toc-text\">标记整理法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E6%B3%95\"><span class=\"toc-text\">标记复制法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GC-%E4%B8%8E%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">GC 与分代回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">分代回收</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">三色标记</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">类加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">类加载过程的三个阶段</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">双亲委派机制</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">四种引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK%E4%B8%8EJVM%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">JDK与JVM有什么区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM%E5%8E%82%E5%95%86\"><span class=\"toc-text\">JVM厂商</span></a></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot实现限制接口访问频率","uid":"b3bf94fa19061188c47e8cc343ee56e4","slug":"SpringBoot实现限制接口访问频率","date":"2023-06-19T04:07:44.000Z","updated":"2023-06-19T04:07:44.467Z","comments":true,"path":"api/articles/SpringBoot实现限制接口访问频率.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"论坛学习笔记(1)","uid":"20f41e298540726590150ca54cb0ec96","slug":"论坛学习笔记-1","date":"2023-06-17T14:02:04.000Z","updated":"2023-06-17T14:16:46.548Z","comments":true,"path":"api/articles/论坛学习笔记-1.json","keywords":null,"cover":null,"text":"mybatis篇mybatis的配置 数据库不区分大小写，配置mysql表字段的下划线映射java实体的驼峰命名 配置自增主键的表，自动生成主键并返回主键给实体，在插入的标签上添加keyproperties属性 配置mapper.xml的路径 配置实体类的包名 在mapper接口...","link":"","photos":[],"count_time":{"symbolsCount":169,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","count":1,"path":"api/tags/学习笔记.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}