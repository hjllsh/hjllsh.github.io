{"title":"Java I/O","uid":"2c570c14ab50f79f35e97f38eeea9026","slug":"Java-IO","date":"2023-06-17T09:45:56.000Z","updated":"2023-06-17T10:15:17.802Z","comments":true,"path":"api/articles/Java-IO.json","keywords":null,"cover":null,"content":"<h3 id=\"I-x2F-O-流的分类\"><a href=\"#I-x2F-O-流的分类\" class=\"headerlink\" title=\"I&#x2F;O 流的分类\"></a>I&#x2F;O 流的分类</h3><p><strong>按照读写的单位大小来分：</strong></p>\n<ul>\n<li><p>字符流：以字符为单位，每次次读入或读出是 16 位数据。其只能读取字符类型数据。(Java 代码接收数据一般为 char 数组，也可以是别的)</p>\n</li>\n<li><p>字节流：以字节为单位，每次读入或读出是 8 位数据。可以读任何类型数据，图片、文件、音乐视频等(Java 代码接收数据只能为 byte 数组)</p>\n</li>\n</ul>\n<p><strong>按照实际 IO 操作来分：</strong></p>\n<ul>\n<li><p>输出流：从内存读出到文件。只能进行写操作。</p>\n</li>\n<li><p>输入流：从文件读入到内存。只能进行读操作。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：输出流可以帮助我们创建文件，而输入流不会。</p></blockquote>\n<p><strong>按照读写时是否直接与硬盘，内存等节点连接分：</strong></p>\n<ul>\n<li><p>节点流：直接与数据源相连，读入或读出。</p>\n</li>\n<li><p>处理流：也叫包装流，是对一个对于已存在的流的连接进行封装，通过所封装的流的功能调用实现数据读写。如添加个 Buffering 缓冲区。（意思就是有个缓存区）</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：为什么要有处理流？主要作用是在读入或写出时，对数据进行缓存，以减少 I&#x2F;O 的次数，以便下次更好更快的读写文件，才有了处理流。</p></blockquote>\n<h3 id=\"字节流如何转为字符流\"><a href=\"#字节流如何转为字符流\" class=\"headerlink\" title=\"字节流如何转为字符流\"></a>字节流如何转为字符流</h3><ul>\n<li><p>字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入InputStream 对象。</p>\n</li>\n<li><p>字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入OutputStream 对象。</p>\n</li>\n</ul>\n<h3 id=\"有哪些可用的-Filter-流\"><a href=\"#有哪些可用的-Filter-流\" class=\"headerlink\" title=\"有哪些可用的 Filter 流?\"></a>有哪些可用的 Filter 流?</h3><p>Filter Stream 是一种 IO 流主要作用是用来对存在的流增加一些额外的功能，像给目标文</p>\n<p>件增加源文件中不存在的行数，或者增加拷贝的性能。在 java.io 包中主要由 4 个可用的 filter Stream。两个字节 filter stream，两个字符 filter stream. 分别是 FilterInputStream, FilterOutputStream, FilterReader and FilterWriter.这些类是抽象类，不能被实例化的。</p>\n<h3 id=\"有哪些-Filter-流的子类？\"><a href=\"#有哪些-Filter-流的子类？\" class=\"headerlink\" title=\"有哪些 Filter 流的子类？\"></a>有哪些 Filter 流的子类？</h3><ul>\n<li><p>LineNumberInputStream 给目标文件增加行号</p>\n</li>\n<li><p>DataInputStream 有些特殊的方法如 readInt(), readDouble()和 readLine() 等可以读取一个 int, double 和一个 string 一次性的,</p>\n</li>\n<li><p>BufferedInputStream 增加性能</p>\n</li>\n<li><p>PushbackInputStream 推送要求的字节到系统中</p>\n</li>\n</ul>\n<h3 id=\"NIO-和-I-x2F-O-的主要区别\"><a href=\"#NIO-和-I-x2F-O-的主要区别\" class=\"headerlink\" title=\"NIO 和 I&#x2F;O 的主要区别\"></a>NIO 和 I&#x2F;O 的主要区别</h3><p><strong>面向流与面向缓冲</strong></p>\n<p>Java IO 和 NIO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO 的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>\n<p><strong>阻塞与非阻塞 IO</strong> </p>\n<p>Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>\n<p><strong>选择器（Selectors）</strong></p>\n<p>Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>\n<p><strong>NIO 提供了与标准 IO 不同的 IO 工作方式：</strong></p>\n<p>Channels and Buffers（通道和缓冲区）：标准的 IO 基于字节流和字符流进行操作的，而 NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Asynchronous IO（异步 IO）：Java NIO 可以让你异步的使用 IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。Selectors（选择器）：Java NIO 引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</p>\n<p><strong>BIO、NIO、AIO 有什么区别？</strong></p>\n<p>**BIO (Blocking I&#x2F;O)**：同步阻塞 I&#x2F;O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>\n<p>**NIO (New I&#x2F;O)**： NIO 是一种同步非阻塞的 I&#x2F;O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应 de 的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I&#x2F;O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>\n<p>**AIO (Asynchronous I&#x2F;O)**： AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>\n<h3 id=\"NIO-有哪些核心组件？\"><a href=\"#NIO-有哪些核心组件？\" class=\"headerlink\" title=\"NIO 有哪些核心组件？\"></a>NIO 有哪些核心组件？</h3><p>Channel Buffer Selector</p>\n<p>Channel 和流有点类似。通过 Channel，我们即可以从 Channel 把数据写到 Buffer 中，也可以把数据冲 Buffer 写入到 Channel，每个 Channel 对应一个 Buffer 缓冲区，Channel会注册到 Selector。Selector 根据 Channel 上发生的读写事件，将请求交由某个空闲的线程处理，Selector 对应一个或多个线程，Channnel 和 Buffer 是可读可写的。</p>\n<h3 id=\"select、poll-和-epoll-什么区别\"><a href=\"#select、poll-和-epoll-什么区别\" class=\"headerlink\" title=\"select、poll 和 epoll 什么区别\"></a>select、poll 和 epoll 什么区别</h3><p>它们是 NIO 多路复用的三种实现机制，是有 Linux 系统提供。</p>\n<ul>\n<li><p>select：无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作，会维护一个文件描述符 FD 的集合 fd_set，将 fd_set 从用户空间复制到内核空间。x86 fd_set 是数组结构</p>\n</li>\n<li><p>poll：与 select 机制相似，fd_set 结构进行优化，突破操作系统限制，pollfd 代替fd_set，链表结构</p>\n</li>\n<li><p>epoll：不再扫描所以 fd，只将用户关心的事件放在内核的一个事件表中，减少用户空间和内核空间的数据拷贝。epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I&#x2F;O 事件通知我们。</p>\n</li>\n</ul>\n<h3 id=\"什么是-Java-序列化，如何实现-Java-序列化？\"><a href=\"#什么是-Java-序列化，如何实现-Java-序列化？\" class=\"headerlink\" title=\"什么是 Java 序列化，如何实现 Java 序列化？\"></a>什么是 Java 序列化，如何实现 Java 序列化？</h3><ul>\n<li><p>序列化就是一种用来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络之间。</p>\n</li>\n<li><p>序列化是为了解决在对象流读写操作时所引发的问题 序列化的实现：将需要被序列化的类实现 Serialize 接口，没有需要实现的方法，此接口只是为了标注对象可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个 ObjectOutputStream(对象流)对象，再使用 ObjectOutputStream 对象的 write(Object obj)方法就可以将参数 obj 的对象写出。</p>\n</li>\n</ul>\n<h3 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h3><ul>\n<li><p>实现 Cloneable 接口并重写 Object 类中的 clone()方法；</p>\n</li>\n<li><p>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</p>\n</li>\n</ul>\n<h3 id=\"什么是缓冲区？有什么作用？\"><a href=\"#什么是缓冲区？有什么作用？\" class=\"headerlink\" title=\"什么是缓冲区？有什么作用？\"></a><strong>什么是缓冲区？有什么作用？</strong></h3><ul>\n<li><p>缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就可以显著的提升性能。</p>\n</li>\n<li><p>对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。</p>\n</li>\n</ul>\n<p><strong>什么是阻塞 IO？什么是非阻塞 IO？</strong></p>\n<p>IO 操作包括：对硬盘的读写、对 socket 的读写以及外设的读写。</p>\n<p>当用户线程发起一个 IO 请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞 IO 来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞 IO 来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的 IO 读请求操作，也就是说一个完整的 IO 读请求操作包括两个阶段：</p>\n<ul>\n<li><p>查看数据是否就绪；</p>\n</li>\n<li><p>进数据拷贝（内核将数据拷贝到用户线程）</p>\n</li>\n</ul>\n<p>那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。Java 中传统的 IO 都是阻塞 IO，比如通过 socket 来读数据，调用 read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在 read 方法调用那里，直到有数据才返回；而如果是非阻塞 IO 的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p>\n<h3 id=\"PrintStream、BufferedWriter、PrintWriter-有什么不同？\"><a href=\"#PrintStream、BufferedWriter、PrintWriter-有什么不同？\" class=\"headerlink\" title=\"PrintStream、BufferedWriter、PrintWriter 有什么不同？\"></a><strong>PrintStream、BufferedWriter、PrintWriter 有什么不同？</strong></h3><p>PrintStream 类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成 PrintStream 后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStream</p>\n<p>BufferedWriter:将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write()方法可以将获取到的字符输出，然后通过 newLine()进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用BufferedInputStream。</p>\n<p>PrintWriter 的 println 方法自动添加换行，不会抛异常，若关心异常，需要调用checkError 方法看是否有异常发生，PrintWriter 构造方法可指定参数，实现自动刷新缓存（autoflush）。</p>\n","feature":true,"text":"I&#x2F;O 流的分类按照读写的单位大小来分： 字符流：以字符为单位，每次次读入或读出是 16 位数据。其只能读取字符类型数据。(Java 代码接收数据一般为 char 数组，也可以是别的) 字节流：以字节为单位，每次读入或读出是 8 位数据。可以读任何类型数据，图片、文件、...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":28,"path":"api/tags/Java.json"},{"name":"IO","slug":"IO","count":2,"path":"api/tags/IO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#I-x2F-O-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">I&#x2F;O 流的分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A6%82%E4%BD%95%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">字节流如何转为字符流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E7%94%A8%E7%9A%84-Filter-%E6%B5%81\"><span class=\"toc-text\">有哪些可用的 Filter 流?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B-Filter-%E6%B5%81%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">有哪些 Filter 流的子类？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NIO-%E5%92%8C-I-x2F-O-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">NIO 和 I&#x2F;O 的主要区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NIO-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">NIO 有哪些核心组件？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#select%E3%80%81poll-%E5%92%8C-epoll-%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">select、poll 和 epoll 什么区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">什么是 Java 序列化，如何实现 Java 序列化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F\"><span class=\"toc-text\">如何实现对象克隆？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">什么是缓冲区？有什么作用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PrintStream%E3%80%81BufferedWriter%E3%80%81PrintWriter-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">PrintStream、BufferedWriter、PrintWriter 有什么不同？</span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"论坛学习笔记(1)","uid":"20f41e298540726590150ca54cb0ec96","slug":"论坛学习笔记-1","date":"2023-06-17T14:02:04.000Z","updated":"2023-06-17T14:16:46.548Z","comments":true,"path":"api/articles/论坛学习笔记-1.json","keywords":null,"cover":null,"text":"mybatis篇mybatis的配置 数据库不区分大小写，配置mysql表字段的下划线映射java实体的驼峰命名 配置自增主键的表，自动生成主键并返回主键给实体，在插入的标签上添加keyproperties属性 配置mapper.xml的路径 配置实体类的包名 在mapper接口...","link":"","photos":[],"count_time":{"symbolsCount":169,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","count":1,"path":"api/tags/学习笔记.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Redis数据结构","uid":"95d031e6876e8ced445f4faed1bda7eb","slug":"Redis数据结构","date":"2023-06-16T13:30:38.000Z","updated":"2023-06-17T14:17:40.240Z","comments":true,"path":"api/articles/Redis数据结构.json","keywords":null,"cover":[],"text":"Redis数据结构-动态字符串SDSRedis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题： 获取字符串长度的需要通过运算 非二进制安全 不可修改 Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。 R...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}