{"title":"Redis主从-哨兵-分片集群","uid":"e17bf8cdf59871b374971436072adfe0","slug":"Redis主从-哨兵-分片集群","date":"2023-06-15T09:27:23.000Z","updated":"2023-06-15T12:49:23.964Z","comments":true,"path":"api/articles/Redis主从-哨兵-分片集群.json","keywords":null,"cover":[],"content":"<h2 id=\"Redis主从\"><a href=\"#Redis主从\" class=\"headerlink\" title=\"Redis主从\"></a>Redis主从</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>\n<p><img src=\"/../assets/redis-git/image-20210725152037611.png\" alt=\"image-20210725152037611\"></p>\n<h3 id=\"主从数据同步原理\"><a href=\"#主从数据同步原理\" class=\"headerlink\" title=\"主从数据同步原理\"></a>主从数据同步原理</h3><h4 id=\"全量同步\"><a href=\"#全量同步\" class=\"headerlink\" title=\"全量同步\"></a>全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>\n<p><img src=\"/../assets/redis-git/image-20210725152222497.png\" alt=\"image-20210725152222497\"></p>\n<p>master如何得知salve是第一次来连接呢？</p>\n<p>判断依据：</p>\n<ul>\n<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>\n<li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li>\n</ul>\n<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>\n<p>如图：</p>\n<p><img src=\"/../assets/redis-git/image-20210725152700914.png\" alt=\"image-20210725152700914\"></p>\n<p>完整流程描述：</p>\n<ul>\n<li>slave节点请求增量同步</li>\n<li>master节点判断replid，发现不一致，拒绝增量同步</li>\n<li>master将完整内存数据生成RDB，发送RDB到slave</li>\n<li>slave清空本地数据，加载master的RDB</li>\n<li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li>\n<li>slave执行接收到的命令，保持与master之间的同步</li>\n</ul>\n<h4 id=\"增量同步\"><a href=\"#增量同步\" class=\"headerlink\" title=\"增量同步\"></a>增量同步</h4><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做增量同步。</p>\n<p><img src=\"/../assets/redis-git/image-20210725153201086.png\" alt=\"image-20210725153201086\"></p>\n<h3 id=\"repl-backlog原理\"><a href=\"#repl-backlog原理\" class=\"headerlink\" title=\"repl_backlog原理\"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p>\n<p>这就要说到<strong>全量同步</strong>时的repl_baklog文件了。</p>\n<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说角标到达数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。</p>\n<p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>\n<p><img src=\"/../assets/redis-git/image-20210725153359022.png\" alt=\"image-20210725153359022\"> </p>\n<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p>\n<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>\n<p><img src=\"/../assets/redis-git/image-20210725153524190.png\" alt=\"image-20210725153524190\"> </p>\n<p>直到数组被填满：</p>\n<p><img src=\"/../assets/redis-git/image-20210725153715910.png\" alt=\"image-20210725153715910\"> </p>\n<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>\n<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p>\n<p><img src=\"/../assets/redis-git/image-20210725153937031.png\" alt=\"image-20210725153937031\"> </p>\n<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>\n<p><img src=\"/../assets/redis-git/image-20210725154155984.png\" alt=\"image-20210725154155984\"> </p>\n<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>\n<p><img src=\"/../assets/redis-git/image-20210725154216392.png\" alt=\"image-20210725154216392\"></p>\n<h4 id=\"主从同步优化\"><a href=\"#主从同步优化\" class=\"headerlink\" title=\"主从同步优化\"></a>主从同步优化</h4><p>主从同步可以保证主从数据的一致性，非常重要。</p>\n<p>可以从以下几个方面来优化Redis主从就集群：</p>\n<ul>\n<li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li>\n<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>\n<li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>\n<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li>\n</ul>\n<p>主从从架构图：</p>\n<p><img src=\"/../assets/redis-git/image-20210725154405899.png\" alt=\"image-20210725154405899\"></p>\n<h2 id=\"Redis哨兵\"><a href=\"#Redis哨兵\" class=\"headerlink\" title=\"Redis哨兵\"></a>Redis哨兵</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>\n<p>哨兵的结构如图：</p>\n<p><img src=\"/../assets/redis-git/image-20210725154528072.png\" alt=\"image-20210725154528072\"></p>\n<p>哨兵的作用如下：</p>\n<ul>\n<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li>\n<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li>\n<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>\n</ul>\n<h4 id=\"集群监控原理\"><a href=\"#集群监控原理\" class=\"headerlink\" title=\"集群监控原理\"></a>集群监控原理</h4><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>\n<ul>\n<li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>\n</li>\n<li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>\n</li>\n</ul>\n<h4 id=\"集群故障恢复原理\"><a href=\"#集群故障恢复原理\" class=\"headerlink\" title=\"集群故障恢复原理\"></a>集群故障恢复原理</h4><p>master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>\n<ul>\n<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>\n<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>\n<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>\n<li>最后是判断slave节点的运行id大小，越小优先级越高。</li>\n</ul>\n<p>选出一个新的master后，当前slave变成master节点的步骤：</p>\n<ul>\n<li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li>\n<li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据（全量）。</li>\n<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>\n</ul>\n<p><img src=\"/../assets/redis-git/image-20210725154816841.png\" alt=\"image-20210725154816841\"></p>\n<h2 id=\"Redis分片集群\"><a href=\"#Redis分片集群\" class=\"headerlink\" title=\"Redis分片集群\"></a>Redis分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>\n<ul>\n<li><p>海量数据存储问题</p>\n</li>\n<li><p>高并发<strong>写</strong>的问题</p>\n</li>\n</ul>\n<p>使用分片集群可以解决上述问题，如图:</p>\n<p><img src=\"/../assets/redis-git/image-20210725155747294.png\" alt=\"image-20210725155747294\"></p>\n<p>分片集群特征：</p>\n<ul>\n<li><p>集群中有多个master，每个master保存不同数据</p>\n</li>\n<li><p>每个master都可以有多个slave节点</p>\n</li>\n<li><p>master之间通过ping监测彼此健康状态</p>\n</li>\n<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>\n</li>\n</ul>\n<h4 id=\"散列插槽\"><a href=\"#散列插槽\" class=\"headerlink\" title=\"散列插槽\"></a>散列插槽</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>\n<p><img src=\"/../assets/redis-git/image-20210725155820320.png\" alt=\"image-20210725155820320\"></p>\n<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>\n<ul>\n<li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li>\n<li>key中不包含“{}”，整个key都是有效部分</li>\n</ul>\n<p>如何将同一类数据固定的保存在同一个Redis实例？</p>\n<p>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</p>\n<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用<strong>CRC16</strong>算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>\n<p><img src=\"/../assets/redis-git/image-20210725155850200.png\" alt=\"image-20210725155850200\"> </p>\n<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>\n<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>\n<h4 id=\"集群伸缩\"><a href=\"#集群伸缩\" class=\"headerlink\" title=\"集群伸缩\"></a>集群伸缩</h4><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p>\n<ul>\n<li>启动一个新的redis实例，端口为7004</li>\n<li>添加7004到之前的集群，并作为一个master节点</li>\n<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>\n</ul>\n<h5 id=\"添加新节点到redis\"><a href=\"#添加新节点到redis\" class=\"headerlink\" title=\"添加新节点到redis\"></a>添加新节点到redis</h5><p>执行添加命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis-cli <span class=\"token parameter variable\">--cluster</span> add-node  <span class=\"token number\">192.168</span>.150.101:7004 <span class=\"token number\">192.168</span>.150.101:7001<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>查看集群状态：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis-cli <span class=\"token parameter variable\">-p</span> <span class=\"token number\">7001</span> cluster nodes<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>7004加入了集群，并且默认是一个master节点：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161007099.png\" alt=\"image-20210725161007099\"></p>\n<p>可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>\n<h5 id=\"转移插槽\"><a href=\"#转移插槽\" class=\"headerlink\" title=\"转移插槽\"></a>转移插槽</h5><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161241793.png\" alt=\"image-20210725161241793\"></p>\n<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161401925.png\" alt=\"image-20210725161401925\"></p>\n<p>具体命令如下：</p>\n<p>建立连接：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161506241.png\" alt=\"image-20210725161506241\"></p>\n<p>得到下面的反馈：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161540841.png\" alt=\"image-20210725161540841\"></p>\n<p>询问要移动多少个插槽，我们计划是3000个：</p>\n<p>新的问题来了：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161637152.png\" alt=\"image-20210725161637152\"></p>\n<p>哪个node来接收这些插槽？？</p>\n<p><img src=\"/../assets/redis-git/image-20210725161731738.png\" alt=\"image-20210725161731738\"></p>\n<p>复制7004节点的id，然后拷贝到刚才的控制台后：</p>\n<p><img src=\"/../assets/redis-git/image-20210725161817642.png\" alt=\"image-20210725161817642\"></p>\n<p>这里询问，你的插槽是从哪里移动过来的？</p>\n<ul>\n<li>all：代表全部，也就是三个节点各转移一部分</li>\n<li>具体的id：目标节点的id</li>\n<li>done：没有了</li>\n</ul>\n<p>这里我们要从7001获取，因此填写7001的id：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162030478.png\" alt=\"image-20210725162030478\"></p>\n<p>填完后，点击done，这样插槽转移就准备好了：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162101228.png\" alt=\"image-20210725162101228\"></p>\n<p>确认要转移吗？输入yes：</p>\n<p>通过命令查看结果：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162145497.png\" alt=\"image-20210725162145497\"> </p>\n<p>可以看到： </p>\n<p><img src=\"/../assets/redis-git/image-20210725162224058.png\" alt=\"image-20210725162224058\"></p>\n<h4 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a>故障转移</h4><h5 id=\"自动故障转移\"><a href=\"#自动故障转移\" class=\"headerlink\" title=\"自动故障转移\"></a>自动故障转移</h5><p>当分片集群中有一个master宕机会发生什么呢？</p>\n<p>1）首先是该实例与其它实例失去连接</p>\n<p>2）然后是疑似宕机：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162319490.png\" alt=\"image-20210725162319490\"></p>\n<p>3）最后是确定下线，自动提升一个slave为新的master：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162408979.png\" alt=\"image-20210725162408979\"></p>\n<p>4）当7002再次启动，就会变为一个slave节点了：</p>\n<p><img src=\"/../assets/redis-git/image-20210727160803386.png\" alt=\"image-20210727160803386\"></p>\n<h5 id=\"手动故障转移\"><a href=\"#手动故障转移\" class=\"headerlink\" title=\"手动故障转移\"></a>手动故障转移</h5><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>\n<p><img src=\"/../assets/redis-git/image-20210725162441407.png\" alt=\"image-20210725162441407\"></p>\n<p>这种failover命令可以指定三种模式：</p>\n<ul>\n<li>缺省：默认的流程，如图1~6歩</li>\n<li>force：省略了对offset的一致性校验</li>\n<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>\n</ul>\n<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>\n<p>步骤如下：</p>\n<p>1）利用redis-cli连接7002这个节点</p>\n<p>2）执行cluster failover命令</p>\n<p>如图：</p>\n<p><img src=\"/../assets/redis-git/image-20210727160037766.png\" alt=\"image-20210727160037766\"></p>\n<p>效果：</p>\n<p><img src=\"/../assets/redis-git/image-20210727161152065.png\" alt=\"image-20210727161152065\"></p>\n","feature":true,"text":"Redis主从单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 主从数据同步原理全量同步主从第一次建立连接时，会执行全量同步，将master节点的所有数据都拷贝给slave节点，流程： master如何得知salve是第一...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E4%B8%BB%E4%BB%8E\"><span class=\"toc-text\">Redis主从</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">主从数据同步原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">全量同步</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">增量同步</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#repl-backlog%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">repl_backlog原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">主从同步优化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E5%93%A8%E5%85%B5\"><span class=\"toc-text\">Redis哨兵</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">集群监控原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">集群故障恢复原理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">Redis分片集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD\"><span class=\"toc-text\">散列插槽</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9\"><span class=\"toc-text\">集群伸缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9%E5%88%B0redis\"><span class=\"toc-text\">添加新节点到redis</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E7%A7%BB%E6%8F%92%E6%A7%BD\"><span class=\"toc-text\">转移插槽</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB\"><span class=\"toc-text\">故障转移</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB\"><span class=\"toc-text\">自动故障转移</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB\"><span class=\"toc-text\">手动故障转移</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Linux实战操作","uid":"1259182ad65f322df495428ef17055e6","slug":"Linux实战操作","date":"2023-06-16T04:22:35.000Z","updated":"2023-06-16T13:25:14.926Z","comments":true,"path":"api/articles/Linux实战操作.json","keywords":null,"cover":[],"text":"一个开源的中文查Linux命令的网站：https://wangchujiang.com/linux-command/list.html Linux目录结构 &#x2F;bin 是Binary的缩写，这个目录存放着最经典的常用命令 &#x2F;Sbin s是Super User的意...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Shell","slug":"Shell","count":1,"path":"api/tags/Shell.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Redis持久化","uid":"25530e52ab0638e424f51939c49f1051","slug":"Redis持久化","date":"2023-06-15T08:51:33.000Z","updated":"2023-06-15T09:24:04.798Z","comments":true,"path":"api/articles/Redis持久化.json","keywords":null,"cover":[],"text":"Redis持久化RDB持久化RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}