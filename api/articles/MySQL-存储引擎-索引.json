{"title":"MySQL_存储引擎_索引","uid":"ca0fb70bccc39b11cac4043db766085d","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","updated":"2023-05-18T10:31:31.846Z","comments":true,"path":"api/articles/MySQL-存储引擎-索引.json","keywords":null,"cover":[],"content":"<h2 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h2><h4 id=\"MySQL体系结构\"><a href=\"#MySQL体系结构\" class=\"headerlink\" title=\"MySQL体系结构\"></a>MySQL体系结构</h4><p><img src=\"/assets/images/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" alt=\"mysql体系结构\"></p>\n<p><strong>连接层</strong></p>\n<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于</p>\n<p>TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程</p>\n<p>池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务</p>\n<p>器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n<p><strong>服务层</strong></p>\n<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部</p>\n<p>分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解</p>\n<p>析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，</p>\n<p>最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，</p>\n<p>这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>\n<p><strong>引擎层</strong></p>\n<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通</p>\n<p>信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库</p>\n<p>中的索引是在存储引擎层实现的</p>\n<p><strong>存储层</strong></p>\n<p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询</p>\n<p>日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>\n<p><strong>其他数据库相比</strong></p>\n<p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p>\n<h4 id=\"存储引擎介绍\"><a href=\"#存储引擎介绍\" class=\"headerlink\" title=\"存储引擎介绍\"></a>存储引擎介绍</h4><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是</p>\n<p>基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果</p>\n<p>没有指定将自动选择默认的存储引擎。\tMySQL默认存储引擎: InnoDB</p>\n<p> <strong>建表时指定存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名<span class=\"token punctuation\">(</span>\n字段<span class=\"token number\">1</span> 字段<span class=\"token number\">1</span>类型 <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 字段<span class=\"token number\">1</span>注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n字段n 字段n类型 <span class=\"token punctuation\">[</span><span class=\"token keyword\">COMMENT</span> 字段n注释 <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">INNODB</span> <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 表注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>查询当前数据库支持的存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"存储引擎特点\"><a href=\"#存储引擎特点\" class=\"headerlink\" title=\"存储引擎特点\"></a><strong>存储引擎特点</strong></h4><p><strong>InnoDB</strong></p>\n<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>DML操作遵循ACID模型，支持事务；</p>\n</li>\n<li><p>行级锁，提高并发访问性能；</p>\n</li>\n<li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p>\n</li>\n</ul>\n<p><strong>文件</strong></p>\n<p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p>\n<p>查看参数：innodb_file_per_table</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_file_per_table'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 </p>\n<p>每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表show variables like ‘innodb_file_per_table’; </p>\n<p> <strong>逻辑存储结构</strong></p>\n<p><img src=\"/assets/images/logicalConstruct.png\" alt=\"mysql体系结构\"></p>\n<p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以</p>\n<p>包含多个Segment段。</p>\n<p>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管</p>\n<p>理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p>\n<p>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为</p>\n<p>16K， 即一个区中一共有64个连续的页。</p>\n<p>页 : 页是组成区的最小单元，<strong>页也是InnoDB存储引擎磁盘管理的最小单元</strong>，每个页的大小默</p>\n<p>认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>\n<p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时</p>\n<p>所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)</p>\n<p><strong>MyISAM</strong></p>\n<p>MyISAM是MySQL早期的默认存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>不支持事务，不支持外键</p>\n</li>\n<li><p>支持表锁，不支持行锁</p>\n</li>\n<li><p>访问速度快</p>\n</li>\n</ul>\n<p> <strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<p>xxx.MYD：存储数据</p>\n<p>xxx.MYI：存储索引</p>\n<p><strong>Memory</strong></p>\n<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用</p>\n<p><strong>特点</strong></p>\n<p>内存存放</p>\n<p> hash索引（默认）</p>\n<p><strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<h4 id=\"区别及特点\"><a href=\"#区别及特点\" class=\"headerlink\" title=\"区别及特点\"></a>区别及特点</h4><table>\n<thead>\n<tr>\n<th>特点</th>\n<th><strong>InnoDB</strong></th>\n<th><strong>MyISAM</strong></th>\n<th><strong>Memory</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>存在受限</td>\n<td>存在受限</td>\n</tr>\n<tr>\n<td>事务安全</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>表锁，行锁</td>\n<td>表锁</td>\n<td>表锁</td>\n</tr>\n<tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持(5.6版本之后)</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>高</td>\n<td>低</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>高</td>\n<td>低</td>\n<td>中等</td>\n</tr>\n<tr>\n<td>批量插入速度</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p><strong>存储引擎选择</strong></p>\n<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>\n<p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>\n<p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p>\n<p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a><strong>索引</strong></h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法这种数据结构就是索引。</p>\n<p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。</p>\n<p><strong>索引的优略</strong> </p>\n<p>优势</p>\n<ul>\n<li>提高数据检索的效率，降低数据库的IO成本</li>\n<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>\n</ul>\n<p>劣势</p>\n<ul>\n<li>索引列也是要占用空间的。</li>\n<li>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</li>\n</ul>\n<p><strong>索引结构</strong></p>\n<p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引结构</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+Tree索引</td>\n<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td>\n</tr>\n<tr>\n<td>R-tree(空间索引）</td>\n<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>\n</tr>\n<tr>\n<td>Full-text(全文索引)</td>\n<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td>\n</tr>\n</tbody></table>\n<p>不同的存储引擎对于索引结构的支持情况。</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引</strong></th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>Memory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash 索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>R-tree 索引</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>Full-text</td>\n<td>5.6版本之后支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p>\n<p><strong>二叉树</strong></p>\n<p>​\t假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>\n<p><img src=\"/assets/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"二叉树\"></p>\n<p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p>\n<p><img src=\"/assets/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\n<p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>\n<ul>\n<li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p>\n</li>\n<li><p>大数据量情况下，层级较深，检索速度慢。</p>\n</li>\n</ul>\n<p>我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p>\n<p><img src=\"/assets/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png\" alt=\"红黑树\"></p>\n<p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p>\n<ul>\n<li>大数据量情况下，层级较深，检索速度慢</li>\n</ul>\n<p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。</p>\n<p><strong>B-Tree</strong></p>\n<p>​\tB树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（树的度数指的是一个节点的子节点个数）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p>\n<p><img src=\"/assets/images/B-Tree.png\" alt=\"B-Tree\"></p>\n<p><strong>特点：</strong></p>\n<ul>\n<li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p>\n</li>\n<li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p>\n</li>\n<li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree</strong></p>\n<p>​\tB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p>\n<p><img src=\"/assets/images/B+Tree.png\" alt=\"B+Tree\"></p>\n<p>我们可以看到，两部分：</p>\n<ul>\n<li><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p>\n</li>\n<li><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree 与 B-Tree相比主要有以下三点区别：</strong></p>\n<ul>\n<li><p>所有的数据都会出现在叶子节点。</p>\n</li>\n<li><p>叶子节点形成一个单向链表。</p>\n</li>\n<li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p>\n</li>\n</ul>\n<p><strong>MySQL中优化之后的B+Tree</strong></p>\n<p>​\tMySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>\n<p><img src=\"/assets/images/MySQL-B+Tree.png\" alt=\"MySQL-B+Tree\"></p>\n<p><strong>Hash</strong></p>\n<p>​\tMySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p>\n<p> 结构</p>\n<p>​\t哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>\n<p><img src=\"/assets/images/hash.png\" alt=\"hash\"></p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）</p>\n</li>\n<li><p>无法利用索引完成排序操作</p>\n</li>\n<li><p>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p>\n</li>\n</ul>\n<p> <strong>支持hash的存储引擎</strong></p>\n<p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>\n<p><strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p>\n<ul>\n<li><p>相对于二叉树，层级更少，搜索效率高；</p>\n</li>\n<li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</p>\n</li>\n<li><p>的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>\n</li>\n<li><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p>\n</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>特点</strong></th>\n<th><strong>关键字</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键索引</td>\n<td>针对于表中主键创建的索引</td>\n<td>默认自动创建, 只能有一个</td>\n<td>PRIMARY</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>避免同一个表中某数据列中的值重复</td>\n<td>可以有多个</td>\n<td>UNIQUE</td>\n</tr>\n<tr>\n<td>常规索引</td>\n<td>快速定位特定数据</td>\n<td>可以有多个</td>\n<td></td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>\n<td>可以有多个</td>\n<td>FULLTEXT</td>\n</tr>\n</tbody></table>\n<p><strong>聚集索引&amp;二级索引</strong></p>\n<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>聚集索引(Clustered Index)</td>\n<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>\n<td>必须有,而且只有一个</td>\n</tr>\n<tr>\n<td>二级索引(Secondary Index)</td>\n<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>\n<td>可以存在多个</td>\n</tr>\n</tbody></table>\n<p>聚集索引选取规则:</p>\n<ul>\n<li><p>如果存在主键，主键索引就是聚集索引。</p>\n</li>\n<li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p>\n</li>\n<li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>\n</li>\n</ul>\n<p>聚集索引和二级索引的具体结构如下：</p>\n<p><img src=\"/assets/images/index.png\" alt=\"index\"></p>\n<p>聚集索引的叶子节点下挂的是这一行的数据 。</p>\n<p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p>\n","feature":true,"text":"MySQL存储引擎MySQL体系结构 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":7,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">MySQL存储引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">MySQL体系结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">存储引擎介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">存储引擎特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">区别及特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">索引分类</span></a></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"MySQL事务","date":"2023-05-17T13:51:38.000Z","updated":"2023-05-18T03:11:52.678Z","comments":true,"path":"api/articles/MySQL事务.json","keywords":null,"cover":[],"text":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。 事务操作未控制事...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":7,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}