{"title":"MySQL_存储引擎_索引","uid":"ca0fb70bccc39b11cac4043db766085d","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","updated":"2023-05-18T14:03:28.514Z","comments":true,"path":"api/articles/MySQL-存储引擎-索引.json","keywords":null,"cover":[],"content":"<h2 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h2><h4 id=\"MySQL体系结构\"><a href=\"#MySQL体系结构\" class=\"headerlink\" title=\"MySQL体系结构\"></a>MySQL体系结构</h4><p><img src=\"/assets/images/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" alt=\"mysql体系结构\"></p>\n<p><strong>连接层</strong></p>\n<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于</p>\n<p>TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程</p>\n<p>池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务</p>\n<p>器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n<p><strong>服务层</strong></p>\n<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部</p>\n<p>分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解</p>\n<p>析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，</p>\n<p>最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，</p>\n<p>这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>\n<p><strong>引擎层</strong></p>\n<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通</p>\n<p>信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库</p>\n<p>中的索引是在存储引擎层实现的</p>\n<p><strong>存储层</strong></p>\n<p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询</p>\n<p>日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>\n<p><strong>其他数据库相比</strong></p>\n<p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p>\n<h4 id=\"存储引擎介绍\"><a href=\"#存储引擎介绍\" class=\"headerlink\" title=\"存储引擎介绍\"></a>存储引擎介绍</h4><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是</p>\n<p>基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果</p>\n<p>没有指定将自动选择默认的存储引擎。\tMySQL默认存储引擎: InnoDB</p>\n<p> <strong>建表时指定存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名<span class=\"token punctuation\">(</span>\n字段<span class=\"token number\">1</span> 字段<span class=\"token number\">1</span>类型 <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 字段<span class=\"token number\">1</span>注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n字段n 字段n类型 <span class=\"token punctuation\">[</span><span class=\"token keyword\">COMMENT</span> 字段n注释 <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">INNODB</span> <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 表注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>查询当前数据库支持的存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"存储引擎特点\"><a href=\"#存储引擎特点\" class=\"headerlink\" title=\"存储引擎特点\"></a><strong>存储引擎特点</strong></h4><p><strong>InnoDB</strong></p>\n<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>DML操作遵循ACID模型，支持事务；</p>\n</li>\n<li><p>行级锁，提高并发访问性能；</p>\n</li>\n<li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p>\n</li>\n</ul>\n<p><strong>文件</strong></p>\n<p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p>\n<p>查看参数：innodb_file_per_table</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_file_per_table'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 </p>\n<p>每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表show variables like ‘innodb_file_per_table’; </p>\n<p> <strong>逻辑存储结构</strong></p>\n<p><img src=\"/assets/images/logicalConstruct.png\" alt=\"mysql体系结构\"></p>\n<p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以</p>\n<p>包含多个Segment段。</p>\n<p>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管</p>\n<p>理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p>\n<p>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为</p>\n<p>16K， 即一个区中一共有64个连续的页。</p>\n<p>页 : 页是组成区的最小单元，<strong>页也是InnoDB存储引擎磁盘管理的最小单元</strong>，每个页的大小默</p>\n<p>认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>\n<p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时</p>\n<p>所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)</p>\n<p><strong>MyISAM</strong></p>\n<p>MyISAM是MySQL早期的默认存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>不支持事务，不支持外键</p>\n</li>\n<li><p>支持表锁，不支持行锁</p>\n</li>\n<li><p>访问速度快</p>\n</li>\n</ul>\n<p> <strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<p>xxx.MYD：存储数据</p>\n<p>xxx.MYI：存储索引</p>\n<p><strong>Memory</strong></p>\n<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用</p>\n<p><strong>特点</strong></p>\n<p>内存存放</p>\n<p> hash索引（默认）</p>\n<p><strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<h4 id=\"区别及特点\"><a href=\"#区别及特点\" class=\"headerlink\" title=\"区别及特点\"></a>区别及特点</h4><table>\n<thead>\n<tr>\n<th>特点</th>\n<th><strong>InnoDB</strong></th>\n<th><strong>MyISAM</strong></th>\n<th><strong>Memory</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>存在受限</td>\n<td>存在受限</td>\n</tr>\n<tr>\n<td>事务安全</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>表锁，行锁</td>\n<td>表锁</td>\n<td>表锁</td>\n</tr>\n<tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持(5.6版本之后)</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>高</td>\n<td>低</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>高</td>\n<td>低</td>\n<td>中等</td>\n</tr>\n<tr>\n<td>批量插入速度</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p><strong>存储引擎选择</strong></p>\n<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>\n<p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>\n<p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p>\n<p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a><strong>索引</strong></h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法这种数据结构就是索引。</p>\n<p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。</p>\n<p><strong>索引的优略</strong> </p>\n<p>优势</p>\n<ul>\n<li>提高数据检索的效率，降低数据库的IO成本</li>\n<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>\n</ul>\n<p>劣势</p>\n<ul>\n<li>索引列也是要占用空间的。</li>\n<li>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</li>\n</ul>\n<p><strong>索引结构</strong></p>\n<p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引结构</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+Tree索引</td>\n<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td>\n</tr>\n<tr>\n<td>R-tree(空间索引）</td>\n<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>\n</tr>\n<tr>\n<td>Full-text(全文索引)</td>\n<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td>\n</tr>\n</tbody></table>\n<p>不同的存储引擎对于索引结构的支持情况。</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引</strong></th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>Memory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash 索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>R-tree 索引</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>Full-text</td>\n<td>5.6版本之后支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p>\n<p><strong>二叉树</strong></p>\n<p>​\t假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>\n<p><img src=\"/assets/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"二叉树\"></p>\n<p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p>\n<p><img src=\"/assets/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\n<p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>\n<ul>\n<li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p>\n</li>\n<li><p>大数据量情况下，层级较深，检索速度慢。</p>\n</li>\n</ul>\n<p>我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p>\n<p><img src=\"/assets/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png\" alt=\"红黑树\"></p>\n<p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p>\n<ul>\n<li>大数据量情况下，层级较深，检索速度慢</li>\n</ul>\n<p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。</p>\n<p><strong>B-Tree</strong></p>\n<p>​\tB树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（树的度数指的是一个节点的子节点个数）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p>\n<p><img src=\"/assets/images/B-Tree.png\" alt=\"B-Tree\"></p>\n<p><strong>特点：</strong></p>\n<ul>\n<li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p>\n</li>\n<li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p>\n</li>\n<li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree</strong></p>\n<p>​\tB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p>\n<p><img src=\"/assets/images/B+Tree.png\" alt=\"B+Tree\"></p>\n<p>我们可以看到，两部分：</p>\n<ul>\n<li><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p>\n</li>\n<li><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree 与 B-Tree相比主要有以下三点区别：</strong></p>\n<ul>\n<li><p>所有的数据都会出现在叶子节点。</p>\n</li>\n<li><p>叶子节点形成一个单向链表。</p>\n</li>\n<li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p>\n</li>\n</ul>\n<p><strong>MySQL中优化之后的B+Tree</strong></p>\n<p>​\tMySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>\n<p><img src=\"/assets/images/MySQL-B+Tree.png\" alt=\"MySQL-B+Tree\"></p>\n<p><strong>Hash</strong></p>\n<p>​\tMySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p>\n<p> 结构</p>\n<p>​\t哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>\n<p><img src=\"/assets/images/hash.png\" alt=\"hash\"></p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）</p>\n</li>\n<li><p>无法利用索引完成排序操作</p>\n</li>\n<li><p>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p>\n</li>\n</ul>\n<p> <strong>支持hash的存储引擎</strong></p>\n<p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>\n<p><strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p>\n<ul>\n<li><p>相对于二叉树，层级更少，搜索效率高；</p>\n</li>\n<li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</p>\n</li>\n<li><p>的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>\n</li>\n<li><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p>\n</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>特点</strong></th>\n<th><strong>关键字</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键索引</td>\n<td>针对于表中主键创建的索引</td>\n<td>默认自动创建, 只能有一个</td>\n<td>PRIMARY</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>避免同一个表中某数据列中的值重复</td>\n<td>可以有多个</td>\n<td>UNIQUE</td>\n</tr>\n<tr>\n<td>常规索引</td>\n<td>快速定位特定数据</td>\n<td>可以有多个</td>\n<td></td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>\n<td>可以有多个</td>\n<td>FULLTEXT</td>\n</tr>\n</tbody></table>\n<p><strong>聚集索引&amp;二级索引</strong></p>\n<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>聚集索引(Clustered Index)</td>\n<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>\n<td>必须有,而且只有一个</td>\n</tr>\n<tr>\n<td>二级索引(Secondary Index)</td>\n<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>\n<td>可以存在多个</td>\n</tr>\n</tbody></table>\n<p>聚集索引选取规则:</p>\n<ul>\n<li><p>如果存在主键，主键索引就是聚集索引。</p>\n</li>\n<li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p>\n</li>\n<li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>\n</li>\n</ul>\n<p>聚集索引和二级索引的具体结构如下：</p>\n<p><img src=\"/assets/images/index.png\" alt=\"index\"></p>\n<p>聚集索引的叶子节点下挂的是这一行的数据 。</p>\n<p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p>\n<p>当我们执行如下的SQL语句时，具体的查找过程是这样子的：</p>\n<p><img src=\"/assets/images/index-process.png\" alt=\"index-process\"></p>\n<ul>\n<li><p>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p>\n</li>\n<li><p>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</p>\n</li>\n<li><p>最终拿到这一行的数据，直接返回即可。</p>\n</li>\n</ul>\n<p><strong>回表查询</strong>： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>\n<p><strong>InnoDB主键索引的B+tree高度为多高呢?</strong></p>\n<p>一般是三层，如果树的高度为3，则可以存储 2200w 左右的记录</p>\n<h4 id=\"索引语法\"><a href=\"#索引语法\" class=\"headerlink\" title=\"索引语法\"></a><strong>索引语法</strong></h4><p>创建索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token punctuation\">[</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">|</span> FULLTEXT <span class=\"token punctuation\">]</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">(</span>index_col_name<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>查看索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">FROM</span> table_name <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 删除索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 小案例：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> tb_user<span class=\"token punctuation\">(</span>\nid <span class=\"token keyword\">int</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span> <span class=\"token keyword\">auto_increment</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'主键'</span><span class=\"token punctuation\">,</span>\nname <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span>\nphone <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'手机号'</span><span class=\"token punctuation\">,</span>\nemail <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'邮箱'</span><span class=\"token punctuation\">,</span>\nprofession <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'专业'</span><span class=\"token punctuation\">,</span>\nage <span class=\"token keyword\">tinyint</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'年龄'</span><span class=\"token punctuation\">,</span>\ngender <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'性别 , 1: 男, 2: 女'</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">status</span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'状态'</span><span class=\"token punctuation\">,</span>\ncreatetime <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'创建时间'</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'系统用户表'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_user_name <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- phone手机号是非空，且唯一，为该字段创建唯一索引</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">unique</span> <span class=\"token keyword\">index</span> idx_user_phone <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">--  为profession、age、status创建联合索引。</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_user_pro_age_sta <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>profession<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span><span class=\"token keyword\">status</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 为email建立合适的索引来提升查询效率</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_email <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"SQL性能分析\"><a href=\"#SQL性能分析\" class=\"headerlink\" title=\"SQL性能分析\"></a>SQL性能分析</h4><p><strong>SQL执行频率</strong></p>\n<p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- session 是查看当前会话 ;</span>\n<span class=\"token comment\">-- global 是查询全局数据 ;</span>\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Com_______'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- Com_delete: 删除次数</span>\n<span class=\"token comment\">-- Com_select: 查询次数</span>\n<span class=\"token comment\">-- Com_update: 更新次数</span>\n<span class=\"token comment\">-- Com_insert: 插入次数</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>\n<p><strong>慢查询日志</strong></p>\n<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p>\n<p>MySQL的慢查询日志默认没有开启，可以查看一下系统变量 slow_query_log</p>\n<p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\"># 开启MySQL慢日志查询开关</span>\nslow_query_log<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span>\nlong_query_time<span class=\"token operator\">=</span><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><strong>profile详情</strong></p>\n<p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@have_profiling</span> <span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 可以通过set语句在session/global级别开启profiling</span>\n<span class=\"token keyword\">set</span> profiling <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>开关已经打开了，接下来所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'白起'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tb_sku<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">-- 查看每一条SQL的耗时基本情况</span>\n<span class=\"token keyword\">show</span> profiles<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span>\n<span class=\"token keyword\">show</span> profile <span class=\"token keyword\">for</span> query query_id<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 查看指定query_id的SQL语句CPU的使用情况</span>\n<span class=\"token keyword\">show</span> profile cpu <span class=\"token keyword\">for</span> query query_id<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>explain</strong></p>\n<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>\n<p>语法:</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 直接在select语句之前加上关键字 explain / desc</span>\n<span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> 字段列表 <span class=\"token keyword\">FROM</span> 表名 <span class=\"token keyword\">WHERE</span> 条件 <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Explain 执行计划中各个字段的含义:</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td>\n</tr>\n<tr>\n<td>possible_key</td>\n<td>显示可能应用在这张表上的索引，一个或多个。</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际使用的索引，如果为NULL，则没有使用索引。</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>\n</tr>\n</tbody></table>\n<h4 id=\"索引使用\"><a href=\"#索引使用\" class=\"headerlink\" title=\"索引使用\"></a>索引使用</h4><p><strong>验证索引效率</strong></p>\n","feature":true,"text":"MySQL存储引擎MySQL体系结构 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":8,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">MySQL存储引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">MySQL体系结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">存储引擎介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">存储引擎特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">区别及特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">索引分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">索引语法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">SQL性能分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">索引使用</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"基于session实现认证","uid":"7a80ec680e8c46b9ee58692b58f8ab63","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","updated":"2023-05-18T16:15:24.710Z","comments":true,"path":"api/articles/基于session实现认证.json","keywords":null,"cover":[],"text":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。 什么是会话用户认证通过后，为了避免用户的每...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":1,"path":"api/tags/认证授权.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"MySQL-事务","date":"2023-05-17T13:51:38.000Z","updated":"2023-05-18T03:11:52.678Z","comments":true,"path":"api/articles/MySQL-事务.json","keywords":null,"cover":[],"text":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。 事务操作未控制事...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":8,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}