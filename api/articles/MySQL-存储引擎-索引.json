{"title":"MySQL_存储引擎_索引","uid":"ca0fb70bccc39b11cac4043db766085d","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","updated":"2023-05-23T13:47:20.934Z","comments":true,"path":"api/articles/MySQL-存储引擎-索引.json","keywords":null,"cover":[],"content":"<h2 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h2><h4 id=\"MySQL体系结构\"><a href=\"#MySQL体系结构\" class=\"headerlink\" title=\"MySQL体系结构\"></a>MySQL体系结构</h4><p><img src=\"/assets/images/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" alt=\"mysql体系结构\"></p>\n<p><strong>连接层</strong></p>\n<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于</p>\n<p>TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程</p>\n<p>池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务</p>\n<p>器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n<p><strong>服务层</strong></p>\n<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部</p>\n<p>分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解</p>\n<p>析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，</p>\n<p>最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，</p>\n<p>这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>\n<p><strong>引擎层</strong></p>\n<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通</p>\n<p>信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库</p>\n<p>中的索引是在存储引擎层实现的</p>\n<p><strong>存储层</strong></p>\n<p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询</p>\n<p>日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>\n<p><strong>其他数据库相比</strong></p>\n<p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p>\n<h4 id=\"存储引擎介绍\"><a href=\"#存储引擎介绍\" class=\"headerlink\" title=\"存储引擎介绍\"></a>存储引擎介绍</h4><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是</p>\n<p>基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果</p>\n<p>没有指定将自动选择默认的存储引擎。\tMySQL默认存储引擎: InnoDB</p>\n<p> <strong>建表时指定存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> 表名<span class=\"token punctuation\">(</span>\n字段<span class=\"token number\">1</span> 字段<span class=\"token number\">1</span>类型 <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 字段<span class=\"token number\">1</span>注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n字段n 字段n类型 <span class=\"token punctuation\">[</span><span class=\"token keyword\">COMMENT</span> 字段n注释 <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">INNODB</span> <span class=\"token punctuation\">[</span> <span class=\"token keyword\">COMMENT</span> 表注释 <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>查询当前数据库支持的存储引擎</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"存储引擎特点\"><a href=\"#存储引擎特点\" class=\"headerlink\" title=\"存储引擎特点\"></a><strong>存储引擎特点</strong></h4><p><strong>InnoDB</strong></p>\n<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>DML操作遵循ACID模型，支持事务；</p>\n</li>\n<li><p>行级锁，提高并发访问性能；</p>\n</li>\n<li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p>\n</li>\n</ul>\n<p><strong>文件</strong></p>\n<p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p>\n<p>查看参数：innodb_file_per_table</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_file_per_table'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 </p>\n<p>每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表show variables like ‘innodb_file_per_table’; </p>\n<p> <strong>逻辑存储结构</strong></p>\n<p><img src=\"/assets/images/logicalConstruct.png\" alt=\"mysql体系结构\"></p>\n<p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以</p>\n<p>包含多个Segment段。</p>\n<p>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管</p>\n<p>理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p>\n<p>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为</p>\n<p>16K， 即一个区中一共有64个连续的页。</p>\n<p>页 : 页是组成区的最小单元，<strong>页也是InnoDB存储引擎磁盘管理的最小单元</strong>，每个页的大小默</p>\n<p>认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>\n<p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时</p>\n<p>所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)</p>\n<p><strong>MyISAM</strong></p>\n<p>MyISAM是MySQL早期的默认存储引擎。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>不支持事务，不支持外键</p>\n</li>\n<li><p>支持表锁，不支持行锁</p>\n</li>\n<li><p>访问速度快</p>\n</li>\n</ul>\n<p> <strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<p>xxx.MYD：存储数据</p>\n<p>xxx.MYI：存储索引</p>\n<p><strong>Memory</strong></p>\n<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用</p>\n<p><strong>特点</strong></p>\n<p>内存存放</p>\n<p> hash索引（默认）</p>\n<p><strong>文件</strong></p>\n<p>xxx.sdi：存储表结构信息</p>\n<h4 id=\"区别及特点\"><a href=\"#区别及特点\" class=\"headerlink\" title=\"区别及特点\"></a>区别及特点</h4><table>\n<thead>\n<tr>\n<th>特点</th>\n<th><strong>InnoDB</strong></th>\n<th><strong>MyISAM</strong></th>\n<th><strong>Memory</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>存在受限</td>\n<td>存在受限</td>\n</tr>\n<tr>\n<td>事务安全</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>表锁，行锁</td>\n<td>表锁</td>\n<td>表锁</td>\n</tr>\n<tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持(5.6版本之后)</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>高</td>\n<td>低</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>高</td>\n<td>低</td>\n<td>中等</td>\n</tr>\n<tr>\n<td>批量插入速度</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p><strong>存储引擎选择</strong></p>\n<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>\n<p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>\n<p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p>\n<p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a><strong>索引</strong></h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法这种数据结构就是索引。</p>\n<p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。</p>\n<p><strong>索引的优略</strong> </p>\n<p>优势</p>\n<ul>\n<li>提高数据检索的效率，降低数据库的IO成本</li>\n<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>\n</ul>\n<p>劣势</p>\n<ul>\n<li>索引列也是要占用空间的。</li>\n<li>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</li>\n</ul>\n<p><strong>索引结构</strong></p>\n<p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引结构</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+Tree索引</td>\n<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>\n</tr>\n<tr>\n<td>Hash索引</td>\n<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td>\n</tr>\n<tr>\n<td>R-tree(空间索引）</td>\n<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>\n</tr>\n<tr>\n<td>Full-text(全文索引)</td>\n<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td>\n</tr>\n</tbody></table>\n<p>不同的存储引擎对于索引结构的支持情况。</p>\n<table>\n<thead>\n<tr>\n<th><strong>索引</strong></th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>Memory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B+tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>Hash 索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>R-tree 索引</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>Full-text</td>\n<td>5.6版本之后支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody></table>\n<p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p>\n<p><strong>二叉树</strong></p>\n<p>​\t假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>\n<p><img src=\"/assets/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"二叉树\"></p>\n<p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p>\n<p><img src=\"/assets/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\n<p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>\n<ul>\n<li><p>顺序插入时，会形成一个链表，查询性能大大降低。</p>\n</li>\n<li><p>大数据量情况下，层级较深，检索速度慢。</p>\n</li>\n</ul>\n<p>我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p>\n<p><img src=\"/assets/images/%E7%BA%A2%E9%BB%91%E6%A0%91.png\" alt=\"红黑树\"></p>\n<p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p>\n<ul>\n<li>大数据量情况下，层级较深，检索速度慢</li>\n</ul>\n<p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。</p>\n<p><strong>B-Tree</strong></p>\n<p>​\tB树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（树的度数指的是一个节点的子节点个数）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p>\n<p><img src=\"/assets/images/B-Tree.png\" alt=\"B-Tree\"></p>\n<p><strong>特点：</strong></p>\n<ul>\n<li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p>\n</li>\n<li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p>\n</li>\n<li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree</strong></p>\n<p>​\tB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p>\n<p><img src=\"/assets/images/B+Tree.png\" alt=\"B+Tree\"></p>\n<p>我们可以看到，两部分：</p>\n<ul>\n<li><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p>\n</li>\n<li><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p>\n</li>\n</ul>\n<p><strong>B+Tree 与 B-Tree相比主要有以下三点区别：</strong></p>\n<ul>\n<li><p>所有的数据都会出现在叶子节点。</p>\n</li>\n<li><p>叶子节点形成一个单向链表。</p>\n</li>\n<li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p>\n</li>\n</ul>\n<p><strong>MySQL中优化之后的B+Tree</strong></p>\n<p>​\tMySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>\n<p><img src=\"/assets/images/MySQL-B+Tree.png\" alt=\"MySQL-B+Tree\"></p>\n<p><strong>Hash</strong></p>\n<p>​\tMySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p>\n<p> 结构</p>\n<p>​\t哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>\n<p><img src=\"/assets/images/hash.png\" alt=\"hash\"></p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）</p>\n</li>\n<li><p>无法利用索引完成排序操作</p>\n</li>\n<li><p>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p>\n</li>\n</ul>\n<p> <strong>支持hash的存储引擎</strong></p>\n<p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>\n<p><strong>为什么InnoDB存储引擎选择使用B+tree索引结构?</strong></p>\n<ul>\n<li><p>相对于二叉树，层级更少，搜索效率高；</p>\n</li>\n<li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</p>\n</li>\n<li><p>的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>\n</li>\n<li><p>相对Hash索引，B+tree支持范围匹配及排序操作；</p>\n</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th><strong>特点</strong></th>\n<th><strong>关键字</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键索引</td>\n<td>针对于表中主键创建的索引</td>\n<td>默认自动创建, 只能有一个</td>\n<td>PRIMARY</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>避免同一个表中某数据列中的值重复</td>\n<td>可以有多个</td>\n<td>UNIQUE</td>\n</tr>\n<tr>\n<td>常规索引</td>\n<td>快速定位特定数据</td>\n<td>可以有多个</td>\n<td></td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>\n<td>可以有多个</td>\n<td>FULLTEXT</td>\n</tr>\n</tbody></table>\n<p><strong>聚集索引&amp;二级索引</strong></p>\n<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>含义</strong></th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>聚集索引(Clustered Index)</td>\n<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>\n<td>必须有,而且只有一个</td>\n</tr>\n<tr>\n<td>二级索引(Secondary Index)</td>\n<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>\n<td>可以存在多个</td>\n</tr>\n</tbody></table>\n<p>聚集索引选取规则:</p>\n<ul>\n<li><p>如果存在主键，主键索引就是聚集索引。</p>\n</li>\n<li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p>\n</li>\n<li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>\n</li>\n</ul>\n<p>聚集索引和二级索引的具体结构如下：</p>\n<p><img src=\"/assets/images/index.png\" alt=\"index\"></p>\n<p>聚集索引的叶子节点下挂的是这一行的数据 。</p>\n<p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p>\n<p>当我们执行如下的SQL语句时，具体的查找过程是这样子的：</p>\n<p><img src=\"/assets/images/index-process.png\" alt=\"index-process\"></p>\n<ul>\n<li><p>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p>\n</li>\n<li><p>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</p>\n</li>\n<li><p>最终拿到这一行的数据，直接返回即可。</p>\n</li>\n</ul>\n<p><strong>回表查询</strong>： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>\n<p><strong>InnoDB主键索引的B+tree高度为多高呢?</strong></p>\n<p>一般是三层，如果树的高度为3，则可以存储 2200w 左右的记录</p>\n<h4 id=\"索引语法\"><a href=\"#索引语法\" class=\"headerlink\" title=\"索引语法\"></a><strong>索引语法</strong></h4><p>创建索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token punctuation\">[</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">|</span> FULLTEXT <span class=\"token punctuation\">]</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">(</span>index_col_name<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>查看索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">FROM</span> table_name <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 删除索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 小案例：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> tb_user<span class=\"token punctuation\">(</span>\nid <span class=\"token keyword\">int</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span> <span class=\"token keyword\">auto_increment</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'主键'</span><span class=\"token punctuation\">,</span>\nname <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'用户名'</span><span class=\"token punctuation\">,</span>\nphone <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'手机号'</span><span class=\"token punctuation\">,</span>\nemail <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'邮箱'</span><span class=\"token punctuation\">,</span>\nprofession <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'专业'</span><span class=\"token punctuation\">,</span>\nage <span class=\"token keyword\">tinyint</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'年龄'</span><span class=\"token punctuation\">,</span>\ngender <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'性别 , 1: 男, 2: 女'</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">status</span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'状态'</span><span class=\"token punctuation\">,</span>\ncreatetime <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'创建时间'</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">comment</span> <span class=\"token string\">'系统用户表'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_user_name <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- phone手机号是非空，且唯一，为该字段创建唯一索引</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">unique</span> <span class=\"token keyword\">index</span> idx_user_phone <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">--  为profession、age、status创建联合索引。</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_user_pro_age_sta <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>profession<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span><span class=\"token keyword\">status</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 为email建立合适的索引来提升查询效率</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_email <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"SQL性能分析\"><a href=\"#SQL性能分析\" class=\"headerlink\" title=\"SQL性能分析\"></a>SQL性能分析</h4><p><strong>SQL执行频率</strong></p>\n<p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- session 是查看当前会话 ;</span>\n<span class=\"token comment\">-- global 是查询全局数据 ;</span>\n<span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Com_______'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- Com_delete: 删除次数</span>\n<span class=\"token comment\">-- Com_select: 查询次数</span>\n<span class=\"token comment\">-- Com_update: 更新次数</span>\n<span class=\"token comment\">-- Com_insert: 插入次数</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>\n<p><strong>慢查询日志</strong></p>\n<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p>\n<p>MySQL的慢查询日志默认没有开启，可以查看一下系统变量 slow_query_log</p>\n<p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\"># 开启MySQL慢日志查询开关</span>\nslow_query_log<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span>\nlong_query_time<span class=\"token operator\">=</span><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><strong>profile详情</strong></p>\n<p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@have_profiling</span> <span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 可以通过set语句在session/global级别开启profiling</span>\n<span class=\"token keyword\">set</span> profiling <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>开关已经打开了，接下来所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'白起'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tb_sku<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">-- 查看每一条SQL的耗时基本情况</span>\n<span class=\"token keyword\">show</span> profiles<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span>\n<span class=\"token keyword\">show</span> profile <span class=\"token keyword\">for</span> query query_id<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 查看指定query_id的SQL语句CPU的使用情况</span>\n<span class=\"token keyword\">show</span> profile cpu <span class=\"token keyword\">for</span> query query_id<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>explain</strong></p>\n<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>\n<p>语法:</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 直接在select语句之前加上关键字 explain / desc</span>\n<span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> 字段列表 <span class=\"token keyword\">FROM</span> 表名 <span class=\"token keyword\">WHERE</span> 条件 <span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Explain 执行计划中各个字段的含义:</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td>\n</tr>\n<tr>\n<td>possible_key</td>\n<td>显示可能应用在这张表上的索引，一个或多个。</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际使用的索引，如果为NULL，则没有使用索引。</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>\n</tr>\n</tbody></table>\n<h4 id=\"索引使用\"><a href=\"#索引使用\" class=\"headerlink\" title=\"索引使用\"></a>索引使用</h4><p>tb_user 表所创建的索引</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%951.png\" alt=\"index\"></p>\n<p><strong>最左前缀法则</strong></p>\n<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)</p>\n<p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 </p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span><span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%952.png\" alt=\"index\"></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%953.png\" alt=\"index\"></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%954.png\" alt=\"index\"></p>\n<p>只要联合索引最左边的字段 profession存在，索引就生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%955.png\" alt=\"index\"></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%956.png\" alt=\"index\"></p>\n<p>上面的这两组测试，索引并没有生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%957.png\" alt=\"index\"></p>\n<p>存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 打乱顺序测试</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">and</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span>；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%958.png\" alt=\"index\"></p>\n<p>是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p>\n<p>最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p>\n<p><strong>范围查询</strong></p>\n<p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">></span> <span class=\"token number\">30</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%959.png\" alt=\"index\"></p>\n<p>范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，说明范围查询右边的status字段是没有走索引。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">>=</span> <span class=\"token number\">30</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9510.png\" alt=\"index\"></p>\n<p>当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。</p>\n<p>所以，尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt;</p>\n<p><strong>索引失效情况</strong></p>\n<p>在索引列上进行运算操作， 索引将失效。</p>\n<p>在tb_user表中，还有一个phone字段的单列索引。</p>\n<p>当根据phone字段进行等值匹配查询时, 索引生效。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'17799990015'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9511.png\" alt=\"index\"></p>\n<p> 当根据phone字段进行函数运算操作之后，索引失效。·</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> substring<span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token string\">'15'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9512.png\" alt=\"index\"></p>\n<p><strong>字符串不加引号</strong></p>\n<p>字符串类型字段使用时，不加引号，索引将失效。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9513.png\" alt=\"index\"></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'17799990015'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">=</span> <span class=\"token number\">17799990015</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9514.png\" alt=\"index\"></p>\n<p>如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效</p>\n<p><strong>模糊查询</strong></p>\n<p>仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p>\n<p>根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">like</span> <span class=\"token string\">'软件%'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">like</span> <span class=\"token string\">'%工程'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">like</span> <span class=\"token string\">'%工%'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9515.png\" alt=\"index\"></p>\n<p>在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效</p>\n<p> <strong>or连接条件</strong></p>\n<p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">or</span> age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'17799990017'</span> <span class=\"token operator\">or</span> age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9516.png\" alt=\"index\"></p>\n<p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p>\n<p>然后，我们可以对age字段建立索引。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_user_age <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>我们再次执行上述的SQL语句，看看前后执行计划的变化。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">or</span> age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'17799990017'</span> <span class=\"token operator\">or</span> age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9517.png\" alt=\"index\"></p>\n<p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p>\n<p> <strong>数据分布影响</strong></p>\n<p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">>=</span> <span class=\"token string\">'17799990005'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> phone <span class=\"token operator\">>=</span> <span class=\"token string\">'17799990015'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9518.png\" alt=\"index\"></p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9519.png\" alt=\"index\"></p>\n<p>相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样。</p>\n<p>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p>\n<p>is null 与 is not null 操作</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9520.png\" alt=\"index\"></p>\n<p>将profession字段值全部更新为null，再次执行上述的两条SQL，查看SQL语句的执行计划。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">update</span> tb_user <span class=\"token keyword\">set</span> profession <span class=\"token operator\">=</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9521.png\" alt=\"index\"></p>\n<p>一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。</p>\n<h4 id=\"SQL提示\"><a href=\"#SQL提示\" class=\"headerlink\" title=\"SQL提示\"></a><strong>SQL提示</strong></h4><p>目前tb_user表索引情况如下</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9522.png\" alt=\"index\"></p>\n<p>idx_user_age, idx_email 这两个索引直接删除</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">drop</span> <span class=\"token keyword\">index</span> idx_user_age <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">drop</span> <span class=\"token keyword\">index</span> idx_email <span class=\"token keyword\">on</span> tb_user<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>执行SQL，查询走了联合索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9523.png\" alt=\"index\"></p>\n<p>创建profession的单列索引</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">create index idx_user_pro on tb_user(profession);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>再次执行SQL语句，查看执行计划，看看到底走哪个索引</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">explain select * from tb_user where profession &#x3D; &#39;软件工程&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9524.png\" alt=\"index\"></p>\n<p>我们可以看到，possible_keys中 idx_user_pro_age_sta，idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p>\n<p>此时就可以借助于MySQL的SQL提示来完成来指定使用哪个索引</p>\n<p> use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">explain select * from tb_user use index(idx_user_pro) where profession &#x3D; &#39;软件工程&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9525.png\" alt=\"index\"></p>\n<p> ignore index ： 忽略指定的索引。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">explain select * from tb_user ignore index(idx_user_pro) where profession &#x3D; &#39;软件工程&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9526.png\" alt=\"index\"></p>\n<p> force index ： 强制使用索引。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">explain select * from tb_user force index(idx_user_pro_age_sta) where profession &#x3D;\n&#39;软件工程&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9527.png\" alt=\"index\"></p>\n<p><strong>覆盖索引</strong></p>\n<p>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p>\n<p>尽量使用覆盖索引，减少select *</p>\n<p>查看一组SQL的执行计划</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> profession <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span>\n<span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span>profession<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span> <span class=\"token keyword\">status</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span>\n<span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span>profession<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span> <span class=\"token keyword\">status</span><span class=\"token punctuation\">,</span> name <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软\n件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'0'</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tb_user <span class=\"token keyword\">where</span> profession <span class=\"token operator\">=</span> <span class=\"token string\">'软件工程'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">and</span> <span class=\"token keyword\">status</span>\n<span class=\"token operator\">=</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果为:</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9528.png\" alt=\"index\"></p>\n<p>这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Extra</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Using where; Using Index</td>\n<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td>\n</tr>\n<tr>\n<td>Using index condition</td>\n<td>查找使用了索引，但是需要回表查询数据</td>\n</tr>\n</tbody></table>\n<p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）</p>\n<p><strong>什么是覆盖索引，什么是回表查询</strong></p>\n<p> 表结构及索引示意图</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9529.png\" alt=\"index\"></p>\n<p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p>\n<p>执行SQL :</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">select * from tb_user where id &#x3D; 2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9530.png\" alt=\"index\"></p>\n<p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>\n<p>执行SQL</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">selet id,name from tb_user where name &#x3D; &#39;Arm&#39;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9531.png\" alt=\"index\"></p>\n<p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p>\n<p>执行SQL</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">selet id,name,gender from tb_user where name &#x3D; &#39;Arm&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9532.png\" alt=\"index\"></p>\n<p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点</p>\n<p><strong>前缀索引</strong></p>\n<p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>\n<p>语法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">create index idx_xxxx on table_name(column(n)) ;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>为tb_user表的email字段，建立长度为5的前缀索引。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">create index idx_email_5 on tb_user(email(5));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9533.png\" alt=\"index\"></p>\n<p>前缀长度</p>\n<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">select count(distinct email) &#x2F; count(*) from tb_user ;\nselect count(distinct substring(email,1,5)) &#x2F; count(*) from tb_user ;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>前缀索引的查询流程</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9534.png\" alt=\"index\"></p>\n<p><strong>单列索引与联合索引</strong></p>\n<p>单列索引：即一个索引只包含单个列。</p>\n<p>联合索引：即一个索引包含了多个列。</p>\n<p>tb_user 表中的索引情况</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9535.png\" alt=\"index\"></p>\n<p>执行一条SQL语句，看看其执行计划：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">explain select id,phone,name from tb_stu where phone &#x3D; &#39;17799990010&#39; and name &#x3D; &#39;韩信&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p>\n<p>再创建一个phone和name字段的联合索引来查询一下执行计划</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">create unique index idx_user_phone_name on tb_user(phone,name);\n\nexplain select id,phone,name from tb_stu where phone &#x3D; &#39;17799990010&#39; and name &#x3D; &#39;韩信&#39;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9536.png\" alt=\"index\"></p>\n<p>如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>\n<p>联合索引具体的结构示意图如下：</p>\n<p><img src=\"/assets/images/%E7%B4%A2%E5%BC%9537.png\" alt=\"index\"></p>\n<h4 id=\"索引设计原则\"><a href=\"#索引设计原则\" class=\"headerlink\" title=\"索引设计原则\"></a>索引设计原则</h4><ul>\n<li><p>针对于数据量较大，且查询比较频繁的表建立索引。</p>\n</li>\n<li><p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>\n</li>\n<li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>\n</li>\n<li><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>\n</li>\n<li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>\n</li>\n<li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>\n</li>\n<li><p>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>\n</li>\n</ul>\n","text":"MySQL存储引擎MySQL体系结构 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">MySQL存储引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">MySQL体系结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">存储引擎介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">存储引擎特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">区别及特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">索引分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">索引语法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">SQL性能分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">索引使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SQL%E6%8F%90%E7%A4%BA\"><span class=\"toc-text\">SQL提示</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">索引设计原则</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"基于session实现认证","uid":"7a80ec680e8c46b9ee58692b58f8ab63","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","updated":"2023-05-18T16:15:24.710Z","comments":true,"path":"api/articles/基于session实现认证.json","keywords":null,"cover":[],"text":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。 什么是会话用户认证通过后，为了避免用户的每...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"认证授权","slug":"认证授权","count":1,"path":"api/tags/认证授权.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"MySQL-事务","date":"2023-05-17T13:51:38.000Z","updated":"2023-05-18T03:11:52.678Z","comments":true,"path":"api/articles/MySQL-事务.json","keywords":null,"cover":[],"text":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。 事务操作未控制事...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}