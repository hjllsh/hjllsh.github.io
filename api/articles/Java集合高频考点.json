{"title":"Java集合高频考点","uid":"19e0c7830137ba378427a6cdcb7fc021","slug":"Java集合高频考点","date":"2023-06-06T04:20:49.000Z","updated":"2023-06-07T11:08:27.946Z","comments":true,"path":"api/articles/Java集合高频考点.json","keywords":null,"cover":[],"content":"<h2 id=\"1-常见的集合有哪些？\"><a href=\"#1-常见的集合有哪些？\" class=\"headerlink\" title=\"1. 常见的集合有哪些？\"></a>1. 常见的集合有哪些？</h2><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。</p>\n<p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p>\n<p>Java集合框架图如下：</p>\n<p><a href=\"https://camo.githubusercontent.com/52b958a5bc3272449398d3a56835f509ae0ffb7e8d08ec4528200150d87f0c23/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333733333536392e706e67\"><img src=\"https://camo.githubusercontent.com/52b958a5bc3272449398d3a56835f509ae0ffb7e8d08ec4528200150d87f0c23/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333733333536392e706e67\" alt=\"img\"></a></p>\n<p><a href=\"https://camo.githubusercontent.com/1c17e24adbb0486039d5a8e3ea30a29a5ec382266ab8bb1bf8584f038aa0aa16/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333735313530312e706e67\"><img src=\"https://camo.githubusercontent.com/1c17e24adbb0486039d5a8e3ea30a29a5ec382266ab8bb1bf8584f038aa0aa16/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333735313530312e706e67\" alt=\"img\"></a></p>\n<p>图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</p>\n<p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>\n<p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p>\n<h2 id=\"2-线程安全的集合有哪些？线程不安全的呢？\"><a href=\"#2-线程安全的集合有哪些？线程不安全的呢？\" class=\"headerlink\" title=\"2. 线程安全的集合有哪些？线程不安全的呢？\"></a>2. 线程安全的集合有哪些？线程不安全的呢？</h2><p>线程安全的：</p>\n<ul>\n<li>Hashtable：比HashMap多了个线程安全。</li>\n<li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li>\n<li>Vector：比Arraylist多了个同步化机制。</li>\n<li>Stack：栈，也是线程安全的，继承于Vector。</li>\n</ul>\n<p>线性不安全的：</p>\n<ul>\n<li>HashMap</li>\n<li>Arraylist</li>\n<li>LinkedList</li>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>TreeMap</li>\n</ul>\n<h2 id=\"3-Arraylist与-LinkedList-异同点？\"><a href=\"#3-Arraylist与-LinkedList-异同点？\" class=\"headerlink\" title=\"3. Arraylist与 LinkedList 异同点？\"></a>3. Arraylist与 LinkedList 异同点？</h2><ul>\n<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>\n<li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间；LinkedList 由于需要存储指向前驱和后继节点的指针，因此占用内存较多。</li>\n<li><strong>性能方面</strong>：<ul>\n<li><strong>ArrayList</strong> 是基于数组实现的，它在内存中是连续存储的。当我们访问 ArrayList 中的一个元素时，CPU 缓存会将这个元素所在的内存块缓存起来。由于局部性原理，我们很可能在不久的将来再次访问这个内存块中的其他元素。此时，由于这些元素已经被缓存在 CPU 缓存中，我们可以快速访问它们。 </li>\n<li><strong>LinkedList</strong> 是基于链表实现的，它的节点在内存中不是连续存储的。当我们访问 LinkedList 中的一个元素时，CPU 缓存会将这个元素所在的内存块缓存起来。但由于链表节点在内存中不是连续存储的，这个内存块中的其他数据很可能与当前访问的元素无关。因此，即使这个内存块被缓存在 CPU 缓存中，我们也无法利用它来加快对其他元素的访问速度。总之，由于 LinkedList 的节点在内存中不是连续存储的，它不能像 ArrayList 那样有效地利用 CPU 缓存。</li>\n<li>总之，由于 LinkedList 的节点在内存中不是连续存储的，它不能像 ArrayList 那样有效地利用 CPU 缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-ArrayList-与-Vector-区别？\"><a href=\"#4-ArrayList-与-Vector-区别？\" class=\"headerlink\" title=\"4. ArrayList 与 Vector 区别？\"></a>4. ArrayList 与 Vector 区别？</h2><ul>\n<li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li>\n<li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li>\n</ul>\n<h2 id=\"5-说一说ArrayList-的扩容机制？\"><a href=\"#5-说一说ArrayList-的扩容机制？\" class=\"headerlink\" title=\"5. 说一说ArrayList 的扩容机制？\"></a>5. 说一说ArrayList 的扩容机制？</h2><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍</strong>。</p>\n<p>有以下扩容规则：</p>\n<ol>\n<li><p>ArrayList() 会使用长度为零的数组</p>\n</li>\n<li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p>\n</li>\n<li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p>\n</li>\n<li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p>\n</li>\n<li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p>\n</li>\n</ol>\n<p>以JDK1.8为例说明:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span>\n    <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Increments modCount!!</span>\n    <span class=\"token comment\">//将e添加到数组末尾</span>\n    elementData<span class=\"token punctuation\">[</span>size<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">ensureExplicitCapacity</span><span class=\"token punctuation\">(</span><span class=\"token function\">calculateCapacity</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculateCapacity</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elementData<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>elementData <span class=\"token operator\">==</span> <span class=\"token constant\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token constant\">DEFAULT_CAPACITY</span><span class=\"token punctuation\">,</span> minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> minCapacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    \n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ensureExplicitCapacity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minCapacity <span class=\"token operator\">-</span> elementData<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取elementData数组的内存空间长度</span>\n        <span class=\"token keyword\">int</span> oldCapacity <span class=\"token operator\">=</span> elementData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 扩容至原来的1.5倍</span>\n        <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> oldCapacity <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//校验容量是否够</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> minCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            newCapacity <span class=\"token operator\">=</span> minCapacity<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//若预设值大于默认的最大值，检查是否溢出</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> <span class=\"token constant\">MAX_ARRAY_SIZE</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            newCapacity <span class=\"token operator\">=</span> <span class=\"token function\">hugeCapacity</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间</span>\n         <span class=\"token comment\">//并将elementData的数据复制到新的内存空间</span>\n        elementData <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"6-Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\"><a href=\"#6-Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\" class=\"headerlink\" title=\"6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？\"></a>6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h2><ul>\n<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>\n<li>Array 是一种静态数据结构，它在创建时就确定了大小，之后不能再改变。而 ArrayList 是一种动态数据结构，它可以根据需要自动扩容，ArrayList 底层是使用 Array 实现的。</li>\n<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>\n</ul>\n<p>在选择使用 Array 还是 ArrayList 时，需要根据实际情况进行判断。如果你需要存储基本数据类型，或者你知道数组的大小不会改变，那么使用 Array 可能是一个更好的选择。如果你需要存储对象类型，并且数组的大小可能会改变，那么使用 ArrayList 可能更方便。</p>\n<h2 id=\"7-HashMap\"><a href=\"#7-HashMap\" class=\"headerlink\" title=\"7. HashMap\"></a>7. HashMap</h2><h3 id=\"1）基本数据结构\"><a href=\"#1）基本数据结构\" class=\"headerlink\" title=\"1）基本数据结构\"></a>1）基本数据结构</h3><ul>\n<li>1.7 数组 + 链表</li>\n<li>1.8 数组 + （链表 | 红黑树）</li>\n</ul>\n<h3 id=\"2）树化与退化\"><a href=\"#2）树化与退化\" class=\"headerlink\" title=\"2）树化与退化\"></a>2）树化与退化</h3><p><strong>树化意义</strong></p>\n<ul>\n<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li>\n<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 $O(\\log_2 n)$ ，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>\n<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>\n</ul>\n<p><strong>树化规则</strong></p>\n<ul>\n<li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>\n</ul>\n<p><strong>退化规则</strong></p>\n<ul>\n<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li>\n<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表，即使退化后链表的长度仍然大于 8，链表不会再次树化。因为树化的条件是在添加元素时链表长度超过阈值，而不是在删除元素时。</li>\n</ul>\n<h3 id=\"3）索引计算\"><a href=\"#3）索引计算\" class=\"headerlink\" title=\"3）索引计算\"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p>\n<ul>\n<li>首先，计算对象的 hashCode()</li>\n<li>再进行调用 HashMap 的 hash() 方法进行<strong>二次哈希</strong>，二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>\n<li>将哈希值与 (capacity - 1) 进行按位与运算，得到索引</li>\n</ul>\n<p><strong>数组容量为何是 2 的 n 次幂</strong></p>\n<ol>\n<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li>\n<li>扩容时重新计算索引效率更高。当容量扩大一倍时，原来的元素可以直接留在原来的位置，或者移动到旧位置加上旧容量的位置。</li>\n</ol>\n<p><strong>注意</strong></p>\n<ul>\n<li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>\n<li><strong>容量是 2 的 n 次幂</strong> 这一设计可以提高计算索引的效率，但会降低哈希的分散性，因此需要二次哈希来作为补偿。一个没有采用这一设计的典型例子是 Hashtable。</li>\n</ul>\n<h3 id=\"4）put-与扩容\"><a href=\"#4）put-与扩容\" class=\"headerlink\" title=\"4）put 与扩容\"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p>\n<ol>\n<li><p>首先，检查数组是否已经创建。如果还没有创建，则创建一个新的数组。如果你使用无参构造函数创建 HashMap，那么在首次调用 put 方法时，会创建一个长度为 16 的数组。这个值是 HashMap 类中定义的默认初始容量。如果你使用带参构造函数创建 HashMap，并指定了初始容量，那么在首次调用 put 方法时，会创建一个长度为大于等于指定初始容量且最小的 2 的 n 次幂的数组。例如，如果你指定初始容量为 20，那么首次调用 put 方法时会创建一个长度为 32 的数组。</p>\n</li>\n<li><p>计算键的哈希值，并根据哈希值计算键在数组中的索引（桶下标）。</p>\n</li>\n<li><p>检查桶下标是否已经有元素占用。如果没有，则创建一个新的 Node 占位，并返回。</p>\n</li>\n<li><p>如果桶下标已经有元素占用，则需要进行进一步处理。如果这个位置已经是 TreeNode，则走红黑树的添加或更新逻辑；如果这个位置是普通 Node，则走链表的添加或更新逻辑。如果链表长度超过树化阈值，则进行树化。在添加元素前，还会先检查是否需要扩容，如果需要，则进行扩容。扩容后，再将新元素添加到扩容后的HashMap 中。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：在添加元素时，如果发现数组容量已经超过阈值，则会进行扩容。会创建一个新的数组，并将原来的元素重新分配到新的数组中，再插入新的元素。这个过程中，元素会被重新计算索引，并根据新的索引分配到新的位置。如果原来的位置是链表或红黑树，则会进行拆分，将元素分配到新的位置。</p></blockquote>\n</li>\n</ol>\n<p><strong>1.7 与 1.8 的区别</strong></p>\n<ul>\n<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>\n</li>\n<li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p>\n</li>\n<li><p>1.8 在扩容计算 Node 索引时，会优化</p>\n</li>\n</ul>\n<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>\n<ol>\n<li>在空间占用与查询时间之间取得较好的权衡</li>\n<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>\n<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>\n</ol>\n<h3 id=\"5）并发问题\"><a href=\"#5）并发问题\" class=\"headerlink\" title=\"5）并发问题\"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p>\n<p>1.7 源码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> rehash<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">:</span> table<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">!=</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rehash<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">.</span>key <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n            e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li>\n<li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084325075.png\" alt=\"image-20210831084325075\"></p>\n<ul>\n<li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084723383.png\" alt=\"image-20210831084723383\"></p>\n<ul>\n<li>第一次循环<ul>\n<li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li>\n<li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li>\n<li>当循环结束是 e 会指向 next 也就是 b 节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084855348.png\" alt=\"image-20210831084855348\"></p>\n<ul>\n<li>第二次循环<ul>\n<li>next 指向了节点 a</li>\n<li>e 头插节点 b</li>\n<li>当循环结束时，e 指向 next 也就是节点 a</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831085329449.png\" alt=\"image-20210831085329449\"></p>\n<ul>\n<li>第三次循环<ul>\n<li>next 指向了 null</li>\n<li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li>\n<li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831085543224.png\" alt=\"image-20210831085543224\"></p>\n<p><strong>数据错乱（1.7，1.8 都会存在）</strong></p>\n<h3 id=\"6）key-的设计\"><a href=\"#6）key-的设计\" class=\"headerlink\" title=\"6）key 的设计\"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p>\n<ol>\n<li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li>\n<li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li>\n<li>key 的 hashCode 应该有良好的散列性</li>\n</ol>\n<p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HashMapMutableKey</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Student</span> stu <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        stu<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">19</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> o<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> age <span class=\"token operator\">==</span> student<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> student<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>String 对象的 hashCode() 设计</strong></p>\n<ul>\n<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>\n<li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li>\n<li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li>\n<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul>\n<li>即 $32 ∗h -h $</li>\n<li>即 $2^5  ∗h -h$</li>\n<li>即 $h≪5  -h$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-解决hash冲突的办法有哪些？HashMap用的哪种？\"><a href=\"#8-解决hash冲突的办法有哪些？HashMap用的哪种？\" class=\"headerlink\" title=\"8. 解决hash冲突的办法有哪些？HashMap用的哪种？\"></a>8. 解决hash冲突的办法有哪些？HashMap用的哪种？</h2><p>解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。</p>\n<ul>\n<li>开放定址法也称为<code>再散列法</code>，基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code></li>\n<li>再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li>\n<li>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li>\n<li>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</li>\n</ul>\n<h2 id=\"9-为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树\"><a href=\"#9-为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树\" class=\"headerlink\" title=\"9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?\"></a>9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h2><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p>\n<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>\n<h2 id=\"10-HashMap默认加载因子为什么是-0-75，不是-0-6-或者-0-8-？\"><a href=\"#10-HashMap默认加载因子为什么是-0-75，不是-0-6-或者-0-8-？\" class=\"headerlink\" title=\"10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？\"></a>10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？</h2><p>回答这个问题前，我们来先看下HashMap的默认构造函数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// 容纳键值对的最大值</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 负载因子</span>\n<span class=\"token keyword\">int</span> modCount<span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold &#x3D; length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>\n<p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p>\n<ul>\n<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li>\n<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li>\n</ul>\n<p>我们来追溯下作者在源码中的注释（JDK1.7）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>\n<h2 id=\"11-HashMap-中-key-的存储索引是怎么计算的？\"><a href=\"#11-HashMap-中-key-的存储索引是怎么计算的？\" class=\"headerlink\" title=\"11. HashMap 中 key 的存储索引是怎么计算的？\"></a>11. HashMap 中 key 的存储索引是怎么计算的？</h2><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。看看源码的实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// jdk1.7</span>\n<span class=\"token comment\">//方法一：</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> hashSeed<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> <span class=\"token operator\">!=</span> h <span class=\"token operator\">&amp;&amp;</span> k <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>Hashing</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringHash32</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n    h <span class=\"token operator\">^=</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 为第一步：取hashCode值</span>\n    h <span class=\"token operator\">^=</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> h <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//方法二：</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样</span>\n     <span class=\"token keyword\">return</span> h <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//第三步：取模运算</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// jdk1.8</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n     <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/* \n     h = key.hashCode() 为第一步：取hashCode值\n     h ^ (h >>> 16)  为第二步：高位参与运算\n    */</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>这里的 Hash 算法本质上就是三步：<strong>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</strong>。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。</p>\n<p><a href=\"https://camo.githubusercontent.com/f75a09581111489d3c496582c8b5676919957d4e30edcf64ac933beb5e01716e/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303131323139313932303131312e706e67\"><img src=\"https://camo.githubusercontent.com/f75a09581111489d3c496582c8b5676919957d4e30edcf64ac933beb5e01716e/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303131323139313932303131312e706e67\" alt=\"image-20210112191920111\"></a></p>\n<h2 id=\"12-HashMap-的put方法流程？\"><a href=\"#12-HashMap-的put方法流程？\" class=\"headerlink\" title=\"12. HashMap 的put方法流程？\"></a>12. HashMap 的put方法流程？</h2><p>简要流程如下：</p>\n<ol>\n<li><p>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</p>\n</li>\n<li><p>如果数组是空的，则调用 resize 进行初始化；</p>\n</li>\n<li><p>如果没有哈希冲突直接放在对应的数组下标里；</p>\n</li>\n<li><p>如果冲突了，且 key 已经存在，就覆盖掉 value；</p>\n</li>\n<li><p>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</p>\n</li>\n<li><p>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</p>\n<p><a href=\"https://camo.githubusercontent.com/5db65c891539d37f7b4fc65014969487be3d2f80a3462f19eb0ac772bf82ac0a/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f686173686d61702545342542392538427075742545362539362542392545362542332539352e6a7067\"><img src=\"https://camo.githubusercontent.com/5db65c891539d37f7b4fc65014969487be3d2f80a3462f19eb0ac772bf82ac0a/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f686173686d61702545342542392538427075742545362539362542392545362542332539352e6a7067\" alt=\"hashmap之put方法(JDK1.8)\"></a></p>\n</li>\n</ol>\n<h2 id=\"13-HashMap-的扩容方式？\"><a href=\"#13-HashMap-的扩容方式？\" class=\"headerlink\" title=\"13. HashMap 的扩容方式？\"></a>13. HashMap 的扩容方式？</h2><p>那扩容的具体步骤是什么？让我们看看源码。</p>\n<p>先来看下JDK1.7 的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   <span class=\"token comment\">//传入新的容量</span>\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> oldTable <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//引用扩容前的Entry数组</span>\n        <span class=\"token keyword\">int</span> oldCapacity <span class=\"token operator\">=</span> oldTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">==</span> <span class=\"token constant\">MAXIMUM_CAPACITY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//扩容前的数组大小如果已经达到最大(2^30)了</span>\n            threshold <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span>newCapacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//初始化一个新的Entry数组</span>\n        <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>newTable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                         <span class=\"token comment\">//！！将数据转移到新的Entry数组里</span>\n        table <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">;</span>                           <span class=\"token comment\">//HashMap的table属性引用新的Entry数组</span>\n        threshold <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">*</span> loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//修改阈值</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> src <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">//src引用了旧的Entry数组</span>\n        <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> src<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//遍历旧的Entry数组</span>\n            <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">=</span> src<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">//取得旧Entry数组的每个元素</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n              src<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//！！重新计算每个元素在数组中的位置</span>\n                    e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//标记[1]</span>\n                    newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//将元素放在数组上</span>\n                    e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>             <span class=\"token comment\">//访问下一个Entry链上的元素</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p>\n<h2 id=\"14-一般用什么作为HashMap的key\"><a href=\"#14-一般用什么作为HashMap的key\" class=\"headerlink\" title=\"14. 一般用什么作为HashMap的key?\"></a>14. 一般用什么作为HashMap的key?</h2><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>\n<ul>\n<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li>\n<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>\n<li>缓存了-128到127之间的所有整数，这是用于提高性能的一种优化技巧。在创建 Integer 对象时，如果它表示的是缓存中的一个整数，那么会直接返回缓存中的实例，而不是新建一个对象。这意味着这些整数的对象只有一个，不同的变量都引用的是同一个对象实例，这也就保证了这些对象是不可变的。</li>\n</ul>\n<h2 id=\"15-HashMap为什么线程不安全？\"><a href=\"#15-HashMap为什么线程不安全？\" class=\"headerlink\" title=\"15. HashMap为什么线程不安全？\"></a>15. HashMap为什么线程不安全？</h2><p><a href=\"https://camo.githubusercontent.com/78693ffd4f81e9013fbe07993a7db303965e4d22dea647efb215e19bfdf5be3b/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f486173684d61702545342542382542412545342542422538302545342542392538382545372542412542462545372541382538422545342542382538442545352541452538392545352538352541382e706e67\"><img src=\"https://camo.githubusercontent.com/78693ffd4f81e9013fbe07993a7db303965e4d22dea647efb215e19bfdf5be3b/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f486173684d61702545342542382542412545342542422538302545342542392538382545372542412542462545372541382538422545342542382538442545352541452538392545352538352541382e706e67\" alt=\"img\"></a></p>\n<ul>\n<li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>\n<li>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n<li>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n</ul>\n<p>具体分析可见大佬的这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjUxMTI4NA==&mid=2247484436&idx=1&sn=eb677611e2ba1d10e3eb3ceb825bef02&chksm=cf54d8cff82351d9cb1c6ad49b6df8b7f0eaa7b965e3be5546b449e71ce1ffccf47ae68f7bf7&token=1920060057&lang=zh_CN#rd\">面试官：HashMap 为什么线程不安全？</a></p>\n<h2 id=\"16-ConcurrentHashMap-的实现原理是什么？\"><a href=\"#16-ConcurrentHashMap-的实现原理是什么？\" class=\"headerlink\" title=\"16. ConcurrentHashMap 的实现原理是什么？\"></a>16. ConcurrentHashMap 的实现原理是什么？</h2><p>ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。</p>\n<p><strong>先来看下JDK1.7</strong></p>\n<p>JDK1.7中的ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry （哈希桶）组成。</p>\n<p>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。</p>\n<p><a href=\"https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67\"><img src=\"https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67\" alt=\"img\"></a></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>\n<p>在每个 segment 中，采用类似 HashMap 的结构来存储 key-value 对，也是通过哈希值与桶的个数取模的方式来计算 key 应该存储在哪个桶中。每个桶是一个链表，存储了哈希值相同的 key-value 对。在插入 key-value 对时，如果链表已经有了该 key 则更新 value，否则就添加一个新的节点到链表的头部。</p>\n<p>当 ConcurrentHashMap 的 size 达到阈值时，需要进行扩容操作，也就是重新计算每个 key 的哈希值，重新插入到新的 segment 中。这个操作需要将原来的 segment 全部锁定，所以需要考虑到并发扩容时可能会发生的死锁情况。JDK1.7 对此做了优化，当扩容时，只需对需要扩容的 segment 进行锁定，因为现有的 segment 不会再插入新的元素。同时，JDK1.7 也通过调整 segment 数量来避免过于分散或集中的哈希值导致的不平衡问题。</p>\n<p><strong>JDK1.8</strong></p>\n<p>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加低粒度的锁。</p>\n<p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>\n<p><a href=\"https://camo.githubusercontent.com/7b73df7dd7039ffd1a7639bae5fb00f5e78094564eb45997a83251fbf9047ea8/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e382e706e67\"><img src=\"https://camo.githubusercontent.com/7b73df7dd7039ffd1a7639bae5fb00f5e78094564eb45997a83251fbf9047ea8/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e382e706e67\" alt=\"img\"></a></p>\n<p>举个例子，假设有两个线程 A 和 B，同时要向 ConcurrentHashMap 中添加一个 key-value 对（key&#x3D;“apple”，value&#x3D;1）。在 JDK1.7 中，如果这两个 key-value 要被映射到同一个段里，那么只能依次访问，虽然锁的粒度比 Hashtable 更小，性能也有所提高，但是还是存在一定的性能瓶颈。而在 JDK1.8 中，则不需要锁的操作，它使用 CAS 技术通过一次操作就能完成修改，从而避免了线程之间的竞争和阻塞，提高了并发效率。</p>\n<h2 id=\"17-ConcurrentHashMap-的-put-方法执行逻辑是什么？\"><a href=\"#17-ConcurrentHashMap-的-put-方法执行逻辑是什么？\" class=\"headerlink\" title=\"17. ConcurrentHashMap 的 put 方法执行逻辑是什么？\"></a>17. ConcurrentHashMap 的 put 方法执行逻辑是什么？</h2><p><strong>JDK1.7</strong></p>\n<p>首先，会尝试获取锁，如果获取失败，利用<code>scanAndLockForPut()</code>自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。</p>\n<p>获取到锁后：</p>\n<ol>\n<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>\n<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>\n<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>\n<li>释放 Segment 的锁。</li>\n</ol>\n<p><strong>JDK1.8</strong></p>\n<p>大致可以分为以下步骤：</p>\n<ol>\n<li>根据 key 计算出 hash值。</li>\n<li>判断是否需要进行初始化。</li>\n<li>定位到 Node，拿到首节点 f，判断首节点 f：<ul>\n<li>如果为 null ，则通过cas的方式尝试添加。</li>\n<li>如果为 <code>f.hash = MOVED = -1</code> ，说明其他线程在扩容，参与一起扩容。</li>\n<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li>\n</ul>\n</li>\n<li>当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。</li>\n</ol>\n<p>源码分析可看这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjUxMTI4NA==&mid=2247484715&idx=1&sn=f5c3ad8e66122531a1c77efcb9cb50b7&chksm=cf54d9f0f82350e637a51fa8bc679f6197d15e4c9703aac971150bfcc5437e867c3bcf3f409c&token=1920060057&lang=zh_CN#rd\">面试 ConcurrentHashMap ，看这一篇就够了！</a></p>\n<h2 id=\"18-ConcurrentHashMap-的-get-方法是否要加锁，为什么？\"><a href=\"#18-ConcurrentHashMap-的-get-方法是否要加锁，为什么？\" class=\"headerlink\" title=\"18. ConcurrentHashMap 的 get 方法是否要加锁，为什么？\"></a>18. ConcurrentHashMap 的 get 方法是否要加锁，为什么？</h2><p>get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p>\n<p>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//可以看到这些都用了volatile修饰</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">V</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"19-get方法不需要加锁与volatile修饰的哈希桶有关吗？\"><a href=\"#19-get方法不需要加锁与volatile修饰的哈希桶有关吗？\" class=\"headerlink\" title=\"19. get方法不需要加锁与volatile修饰的哈希桶有关吗？\"></a>19. get方法不需要加锁与volatile修饰的哈希桶有关吗？</h2><p>没有关系。哈希桶<code>table</code>用volatile修饰主要是保证在数组扩容的时候保证可见性。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;\n\n    &#x2F;&#x2F; 存放数据的桶\n    transient volatile HashEntry&lt;K,V&gt;[] table;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"20-ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？\"><a href=\"#20-ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？\" class=\"headerlink\" title=\"20. ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？\"></a>20. ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h2><p>我们先来说value 为什么不能为 null ，因为<code>ConcurrentHashMap </code>是用于多线程的 ，如果<code>map.get(key)</code>得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。</p>\n<p>而用于单线程状态的<code>HashMap</code>却可以用<code>containsKey(key)</code> 去判断到底是否包含了这个 null 。</p>\n<p>我们用<strong>反证法</strong>来推理：</p>\n<p>假设ConcurrentHashMap 允许存放值为 null 的value，这时有A、B两个线程，线程A调用ConcurrentHashMap .get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p>\n<p>假设此时，返回为 null 的真实情况是没有找到对应的key。那么，我们可以用ConcurrentHashMap .containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回false。</p>\n<p>但是在我们调用ConcurrentHashMap .get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap .put(key, null )的操作。那么我们调用containsKey方法返回的就是true了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p>\n<p>至于ConcurrentHashMap 中的key为什么也不能为 null 的问题，源码就是这样写的。可能是因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的key存在。</p>\n<h2 id=\"21-ConcurrentHashMap-的并发度是多少？\"><a href=\"#21-ConcurrentHashMap-的并发度是多少？\" class=\"headerlink\" title=\"21. ConcurrentHashMap 的并发度是多少？\"></a>21. ConcurrentHashMap 的并发度是多少？</h2><p>在JDK1.7中，并发度默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>\n<h2 id=\"22-ConcurrentHashMap-迭代器是强一致性还是弱一致性？\"><a href=\"#22-ConcurrentHashMap-迭代器是强一致性还是弱一致性？\" class=\"headerlink\" title=\"22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？\"></a>22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h2><p>与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>\n<p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>\n<p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</p>\n<h2 id=\"23-JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？\"><a href=\"#23-JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？\" class=\"headerlink\" title=\"23. JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？\"></a>23. JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？</h2><ul>\n<li>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li>\n<li>保证线程安全机制：JDK1.7采用Segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8 采用CAS+Synchronized保证线程安全。</li>\n<li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li>\n<li>链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</li>\n</ul>\n<h2 id=\"24-ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？\"><a href=\"#24-ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？\" class=\"headerlink\" title=\"24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？\"></a>24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</h2><p>ConcurrentHashMap 的效率要高于Hashtable，因为Hashtable给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采用<code>CAS+Synchronized</code>实现线程安全。</p>\n<h2 id=\"25-说一下Hashtable的锁机制\"><a href=\"#25-说一下Hashtable的锁机制\" class=\"headerlink\" title=\"25. 说一下Hashtable的锁机制 ?\"></a>25. 说一下Hashtable的锁机制 ?</h2><p>Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p>\n<p><a href=\"https://camo.githubusercontent.com/0ca109a46b738223720b9d51aa634d6fa9138804e3aefbec50474415a7817faf/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d686173687461626c652e706e67\"><img src=\"https://camo.githubusercontent.com/0ca109a46b738223720b9d51aa634d6fa9138804e3aefbec50474415a7817faf/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d686173687461626c652e706e67\" alt=\"img\"></a></p>\n<h2 id=\"26-多线程下安全的操作map还有其他方法吗？\"><a href=\"#26-多线程下安全的操作map还有其他方法吗？\" class=\"headerlink\" title=\"26. 多线程下安全的操作map还有其他方法吗？\"></a>26. 多线程下安全的操作map还有其他方法吗？</h2><p>还可以使用<code>Collections.synchronizedMap</code>方法，对方法进行加同步锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynchronizedMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> <span class=\"token number\">1978198479659022715L</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> m<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// Backing Map</span>\n        <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span>      mutex<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// Object on which to synchronize</span>\n\n        <span class=\"token class-name\">SynchronizedMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span>requireNon <span class=\"token keyword\">null</span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mutex <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token class-name\">SynchronizedMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> m<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mutex <span class=\"token operator\">=</span> mutex<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// 省略部分代码</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>\n<h2 id=\"27-HashSet-和-HashMap-区别\"><a href=\"#27-HashSet-和-HashMap-区别\" class=\"headerlink\" title=\"27. HashSet 和 HashMap 区别?\"></a>27. HashSet 和 HashMap 区别?</h2><p><a href=\"https://camo.githubusercontent.com/07140775e6b066dfa7a516ce7869453ced7059aa1f5f2e262ef5611f63ccb004/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333139333031303934392e706e67\"><img src=\"https://camo.githubusercontent.com/07140775e6b066dfa7a516ce7869453ced7059aa1f5f2e262ef5611f63ccb004/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333139333031303934392e706e67\" alt=\"img\"></a></p>\n<p>补充HashSet的实现：HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。如源码所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> <span class=\"token constant\">PRESENT</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。</p>\n<h2 id=\"28-Collection框架中实现比较要怎么做？\"><a href=\"#28-Collection框架中实现比较要怎么做？\" class=\"headerlink\" title=\"28. Collection框架中实现比较要怎么做？\"></a>28. Collection框架中实现比较要怎么做？</h2><p>第一种，实体类实现<strong>Comparable接口</strong>，并实现 <strong>compareTo</strong>(T t) 方法，称为内部比较器。</p>\n<p>第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 **compare(**T t1, T t2)方法。</p>\n<h2 id=\"29-Iterator-和-ListIterator-有什么区别？\"><a href=\"#29-Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"29. Iterator 和 ListIterator 有什么区别？\"></a>29. Iterator 和 ListIterator 有什么区别？</h2><ul>\n<li>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在<strong>向前方向</strong>上遍历集合中的元素。</li>\n</ul>\n<p>使用ListIterator，只能遍历<strong>List</strong>实现的对象，但可以向前和向后遍历集合中的元素。</p>\n<ul>\n<li>添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。</li>\n<li>修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。</li>\n<li>索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。</li>\n</ul>\n<h2 id=\"30-讲一讲快速失败-fail-fast-和安全失败-fail-safe\"><a href=\"#30-讲一讲快速失败-fail-fast-和安全失败-fail-safe\" class=\"headerlink\" title=\"30. 讲一讲快速失败(fail-fast)和安全失败(fail-safe)\"></a>30. 讲一讲快速失败(fail-fast)和安全失败(fail-safe)</h2><p><strong>快速失败（fail—fast）</strong></p>\n<ul>\n<li>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>\n<li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>\n<li>注意：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>\n<li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改，比如HashMap、ArrayList 这些集合类。</li>\n</ul>\n<p><strong>安全失败（fail—safe）</strong></p>\n<ul>\n<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>\n<li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>\n<li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>\n<li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如：ConcurrentHashMap。</li>\n</ul>\n","text":"1. 常见的集合有哪些？Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意：Col...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":29,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">1. 常见的集合有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">2. 线程安全的集合有哪些？线程不安全的呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Arraylist%E4%B8%8E-LinkedList-%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">3. Arraylist与 LinkedList 异同点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-ArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4. ArrayList 与 Vector 区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">5. 说一说ArrayList 的扩容机制？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E5%BA%94-Array-%E8%80%8C%E4%B8%8D%E6%98%AF-ArrayList-%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-HashMap\"><span class=\"toc-text\">7. HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1）基本数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E6%A0%91%E5%8C%96%E4%B8%8E%E9%80%80%E5%8C%96\"><span class=\"toc-text\">2）树化与退化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">3）索引计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89put-%E4%B8%8E%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">4）put 与扩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5）并发问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%EF%BC%89key-%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">6）key 的设计</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F\"><span class=\"toc-text\">8. 解决hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%E8%80%8C%E9%80%89%E6%8B%A9%E5%85%88%E7%94%A8%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%86%8D%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75%EF%BC%8C%E4%B8%8D%E6%98%AF-0-6-%E6%88%96%E8%80%85-0-8-%EF%BC%9F\"><span class=\"toc-text\">10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-HashMap-%E4%B8%AD-key-%E7%9A%84%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">11. HashMap 中 key 的存储索引是怎么计算的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-HashMap-%E7%9A%84put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">12. HashMap 的put方法流程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">13. HashMap 的扩容方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key\"><span class=\"toc-text\">14. 一般用什么作为HashMap的key?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">15. HashMap为什么线程不安全？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">16. ConcurrentHashMap 的实现原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-ConcurrentHashMap-%E7%9A%84-put-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">17. ConcurrentHashMap 的 put 方法执行逻辑是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-ConcurrentHashMap-%E7%9A%84-get-%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E8%A6%81%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">18. ConcurrentHashMap 的 get 方法是否要加锁，为什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-get%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%E4%B8%8Evolatile%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%93%88%E5%B8%8C%E6%A1%B6%E6%9C%89%E5%85%B3%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">19. get方法不需要加锁与volatile修饰的哈希桶有关吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-ConcurrentHashMap-%E4%B8%8D%E6%94%AF%E6%8C%81-key-%E6%88%96%E8%80%85-value-%E4%B8%BA-null-%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F\"><span class=\"toc-text\">20. ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-ConcurrentHashMap-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">21. ConcurrentHashMap 的并发度是多少？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-ConcurrentHashMap-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E8%BF%98%E6%98%AF%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-JDK1-7%E4%B8%8EJDK1-8-%E4%B8%ADConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">23. JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-ConcurrentHashMap-%E5%92%8CHashtable%E7%9A%84%E6%95%88%E7%8E%87%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E8%AF%B4%E4%B8%80%E4%B8%8BHashtable%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">25. 说一下Hashtable的锁机制 ?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%93%8D%E4%BD%9Cmap%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">26. 多线程下安全的操作map还有其他方法吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">27. HashSet 和 HashMap 区别?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-Collection%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E8%A6%81%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F\"><span class=\"toc-text\">28. Collection框架中实现比较要怎么做？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29-Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">29. Iterator 和 ListIterator 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30-%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe\"><span class=\"toc-text\">30. 讲一讲快速失败(fail-fast)和安全失败(fail-safe)</span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2023-06-07T11:42:20.000Z","updated":"2023-06-07T13:31:41.753Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":[],"text":"Executor线程池在Java框架设计中，一般涉及到资源相关的，并且资源具有创建消耗大、可复用的特点时，都采用了池化技术管理资源，形成一个“资源池”，池化技术可以带来以下一般性好处：对外部隐藏了资源的创建与释放的细节、实现资源的复用减少内存或者时间性能开销。常见Java中池化技...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"Redis实战-用户签到_UV统计","uid":"37c665cf8e0e08ae6a11b540ba094729","slug":"Redis实战-用户签到","date":"2023-06-06T02:48:05.000Z","updated":"2023-06-14T14:24:13.759Z","comments":true,"path":"api/articles/Redis实战-用户签到.json","keywords":null,"cover":[],"text":"用户签到用户签到-BitMap功能演示我们针对签到功能完全可以通过mysql来完成，比如说以下这张表 用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"},{"name":"Redis实战","slug":"Redis实战","count":10,"path":"api/tags/Redis实战.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}