{"title":"Java集合高频考点","uid":"19e0c7830137ba378427a6cdcb7fc021","slug":"Java集合高频考点","date":"2023-06-06T04:20:49.000Z","updated":"2023-06-06T16:16:43.165Z","comments":true,"path":"api/articles/Java集合高频考点.json","keywords":null,"cover":[],"content":"<h2 id=\"1-常见的集合有哪些？\"><a href=\"#1-常见的集合有哪些？\" class=\"headerlink\" title=\"1. 常见的集合有哪些？\"></a>1. 常见的集合有哪些？</h2><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。</p>\n<p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p>\n<p>Java集合框架图如下：</p>\n<p><a href=\"https://camo.githubusercontent.com/52b958a5bc3272449398d3a56835f509ae0ffb7e8d08ec4528200150d87f0c23/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333733333536392e706e67\"><img src=\"https://camo.githubusercontent.com/52b958a5bc3272449398d3a56835f509ae0ffb7e8d08ec4528200150d87f0c23/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333733333536392e706e67\" alt=\"img\"></a></p>\n<p><a href=\"https://camo.githubusercontent.com/1c17e24adbb0486039d5a8e3ea30a29a5ec382266ab8bb1bf8584f038aa0aa16/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333735313530312e706e67\"><img src=\"https://camo.githubusercontent.com/1c17e24adbb0486039d5a8e3ea30a29a5ec382266ab8bb1bf8584f038aa0aa16/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303430333136333735313530312e706e67\" alt=\"img\"></a></p>\n<p>图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</p>\n<p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>\n<p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p>\n<h2 id=\"2-线程安全的集合有哪些？线程不安全的呢？\"><a href=\"#2-线程安全的集合有哪些？线程不安全的呢？\" class=\"headerlink\" title=\"2. 线程安全的集合有哪些？线程不安全的呢？\"></a>2. 线程安全的集合有哪些？线程不安全的呢？</h2><p>线程安全的：</p>\n<ul>\n<li>Hashtable：比HashMap多了个线程安全。</li>\n<li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li>\n<li>Vector：比Arraylist多了个同步化机制。</li>\n<li>Stack：栈，也是线程安全的，继承于Vector。</li>\n</ul>\n<p>线性不安全的：</p>\n<ul>\n<li>HashMap</li>\n<li>Arraylist</li>\n<li>LinkedList</li>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>TreeMap</li>\n</ul>\n<h2 id=\"3-Arraylist与-LinkedList-异同点？\"><a href=\"#3-Arraylist与-LinkedList-异同点？\" class=\"headerlink\" title=\"3. Arraylist与 LinkedList 异同点？\"></a>3. Arraylist与 LinkedList 异同点？</h2><ul>\n<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>\n<li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间；LinkedList 由于需要存储指向前驱和后继节点的指针，因此占用内存较多。</li>\n<li><strong>性能方面</strong>：<ul>\n<li><strong>ArrayList</strong> 是基于数组实现的，它在内存中是连续存储的。当我们访问 ArrayList 中的一个元素时，CPU 缓存会将这个元素所在的内存块缓存起来。由于局部性原理，我们很可能在不久的将来再次访问这个内存块中的其他元素。此时，由于这些元素已经被缓存在 CPU 缓存中，我们可以快速访问它们。 </li>\n<li><strong>LinkedList</strong> 是基于链表实现的，它的节点在内存中不是连续存储的。当我们访问 LinkedList 中的一个元素时，CPU 缓存会将这个元素所在的内存块缓存起来。但由于链表节点在内存中不是连续存储的，这个内存块中的其他数据很可能与当前访问的元素无关。因此，即使这个内存块被缓存在 CPU 缓存中，我们也无法利用它来加快对其他元素的访问速度。总之，由于 LinkedList 的节点在内存中不是连续存储的，它不能像 ArrayList 那样有效地利用 CPU 缓存。</li>\n<li>总之，由于 LinkedList 的节点在内存中不是连续存储的，它不能像 ArrayList 那样有效地利用 CPU 缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-ArrayList-与-Vector-区别？\"><a href=\"#4-ArrayList-与-Vector-区别？\" class=\"headerlink\" title=\"4. ArrayList 与 Vector 区别？\"></a>4. ArrayList 与 Vector 区别？</h2><ul>\n<li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li>\n<li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li>\n</ul>\n<h2 id=\"5-说一说ArrayList-的扩容机制？\"><a href=\"#5-说一说ArrayList-的扩容机制？\" class=\"headerlink\" title=\"5. 说一说ArrayList 的扩容机制？\"></a>5. 说一说ArrayList 的扩容机制？</h2><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍</strong>。</p>\n<p>有以下扩容规则：</p>\n<ol>\n<li><p>ArrayList() 会使用长度为零的数组</p>\n</li>\n<li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p>\n</li>\n<li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p>\n</li>\n<li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p>\n</li>\n<li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p>\n</li>\n</ol>\n<p>以JDK1.8为例说明:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span>\n    <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Increments modCount!!</span>\n    <span class=\"token comment\">//将e添加到数组末尾</span>\n    elementData<span class=\"token punctuation\">[</span>size<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">ensureExplicitCapacity</span><span class=\"token punctuation\">(</span><span class=\"token function\">calculateCapacity</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculateCapacity</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elementData<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>elementData <span class=\"token operator\">==</span> <span class=\"token constant\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token constant\">DEFAULT_CAPACITY</span><span class=\"token punctuation\">,</span> minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> minCapacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    \n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ensureExplicitCapacity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minCapacity <span class=\"token operator\">-</span> elementData<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取elementData数组的内存空间长度</span>\n        <span class=\"token keyword\">int</span> oldCapacity <span class=\"token operator\">=</span> elementData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 扩容至原来的1.5倍</span>\n        <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> oldCapacity <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//校验容量是否够</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> minCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            newCapacity <span class=\"token operator\">=</span> minCapacity<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//若预设值大于默认的最大值，检查是否溢出</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> <span class=\"token constant\">MAX_ARRAY_SIZE</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            newCapacity <span class=\"token operator\">=</span> <span class=\"token function\">hugeCapacity</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间</span>\n         <span class=\"token comment\">//并将elementData的数据复制到新的内存空间</span>\n        elementData <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"6-Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\"><a href=\"#6-Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\" class=\"headerlink\" title=\"6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？\"></a>6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h2><ul>\n<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>\n<li>Array 是一种静态数据结构，它在创建时就确定了大小，之后不能再改变。而 ArrayList 是一种动态数据结构，它可以根据需要自动扩容，ArrayList 底层是使用 Array 实现的。</li>\n<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>\n</ul>\n<p>在选择使用 Array 还是 ArrayList 时，需要根据实际情况进行判断。如果你需要存储基本数据类型，或者你知道数组的大小不会改变，那么使用 Array 可能是一个更好的选择。如果你需要存储对象类型，并且数组的大小可能会改变，那么使用 ArrayList 可能更方便。</p>\n<h2 id=\"7-HashMap\"><a href=\"#7-HashMap\" class=\"headerlink\" title=\"7. HashMap\"></a>7. HashMap</h2><h3 id=\"1）基本数据结构\"><a href=\"#1）基本数据结构\" class=\"headerlink\" title=\"1）基本数据结构\"></a>1）基本数据结构</h3><ul>\n<li>1.7 数组 + 链表</li>\n<li>1.8 数组 + （链表 | 红黑树）</li>\n</ul>\n<h3 id=\"2）树化与退化\"><a href=\"#2）树化与退化\" class=\"headerlink\" title=\"2）树化与退化\"></a>2）树化与退化</h3><p><strong>树化意义</strong></p>\n<ul>\n<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li>\n<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 $O(\\log_2 n)$ ，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>\n<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>\n</ul>\n<p><strong>树化规则</strong></p>\n<ul>\n<li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>\n</ul>\n<p><strong>退化规则</strong></p>\n<ul>\n<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li>\n<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表，即使退化后链表的长度仍然大于 8，链表不会再次树化。因为树化的条件是在添加元素时链表长度超过阈值，而不是在删除元素时。</li>\n</ul>\n<h3 id=\"3）索引计算\"><a href=\"#3）索引计算\" class=\"headerlink\" title=\"3）索引计算\"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p>\n<ul>\n<li>首先，计算对象的 hashCode()</li>\n<li>再进行调用 HashMap 的 hash() 方法进行<strong>二次哈希</strong>，二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>\n<li>将哈希值与 (capacity - 1) 进行按位与运算，得到索引</li>\n</ul>\n<p><strong>数组容量为何是 2 的 n 次幂</strong></p>\n<ol>\n<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li>\n<li>扩容时重新计算索引效率更高。当容量扩大一倍时，原来的元素可以直接留在原来的位置，或者移动到旧位置加上旧容量的位置。</li>\n</ol>\n<p><strong>注意</strong></p>\n<ul>\n<li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>\n<li><strong>容量是 2 的 n 次幂</strong> 这一设计可以提高计算索引的效率，但会降低哈希的分散性，因此需要二次哈希来作为补偿。一个没有采用这一设计的典型例子是 Hashtable。</li>\n</ul>\n<h3 id=\"4）put-与扩容\"><a href=\"#4）put-与扩容\" class=\"headerlink\" title=\"4）put 与扩容\"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p>\n<ol>\n<li><p>首先，检查数组是否已经创建。如果还没有创建，则创建一个新的数组。如果你使用无参构造函数创建 HashMap，那么在首次调用 put 方法时，会创建一个长度为 16 的数组。这个值是 HashMap 类中定义的默认初始容量。如果你使用带参构造函数创建 HashMap，并指定了初始容量，那么在首次调用 put 方法时，会创建一个长度为大于等于指定初始容量且最小的 2 的 n 次幂的数组。例如，如果你指定初始容量为 20，那么首次调用 put 方法时会创建一个长度为 32 的数组。</p>\n</li>\n<li><p>计算键的哈希值，并根据哈希值计算键在数组中的索引（桶下标）。</p>\n</li>\n<li><p>检查桶下标是否已经有元素占用。如果没有，则创建一个新的 Node 占位，并返回。</p>\n</li>\n<li><p>如果桶下标已经有元素占用，则需要进行进一步处理。如果这个位置已经是 TreeNode，则走红黑树的添加或更新逻辑；如果这个位置是普通 Node，则走链表的添加或更新逻辑。如果链表长度超过树化阈值，则进行树化。在添加元素前，还会先检查是否需要扩容，如果需要，则进行扩容。扩容后，再将新元素添加到扩容后的HashMap 中。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：在添加元素时，如果发现数组容量已经超过阈值，则会进行扩容。会创建一个新的数组，并将原来的元素重新分配到新的数组中，再插入新的元素。这个过程中，元素会被重新计算索引，并根据新的索引分配到新的位置。如果原来的位置是链表或红黑树，则会进行拆分，将元素分配到新的位置。</p></blockquote>\n</li>\n</ol>\n<p><strong>1.7 与 1.8 的区别</strong></p>\n<ul>\n<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>\n</li>\n<li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p>\n</li>\n<li><p>1.8 在扩容计算 Node 索引时，会优化</p>\n</li>\n</ul>\n<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>\n<ol>\n<li>在空间占用与查询时间之间取得较好的权衡</li>\n<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>\n<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>\n</ol>\n<h3 id=\"5）并发问题\"><a href=\"#5）并发问题\" class=\"headerlink\" title=\"5）并发问题\"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p>\n<p>1.7 源码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> rehash<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">:</span> table<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token operator\">!=</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rehash<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">.</span>key <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n            e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li>\n<li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084325075.png\" alt=\"image-20210831084325075\"></p>\n<ul>\n<li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084723383.png\" alt=\"image-20210831084723383\"></p>\n<ul>\n<li>第一次循环<ul>\n<li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li>\n<li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li>\n<li>当循环结束是 e 会指向 next 也就是 b 节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831084855348.png\" alt=\"image-20210831084855348\"></p>\n<ul>\n<li>第二次循环<ul>\n<li>next 指向了节点 a</li>\n<li>e 头插节点 b</li>\n<li>当循环结束时，e 指向 next 也就是节点 a</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831085329449.png\" alt=\"image-20210831085329449\"></p>\n<ul>\n<li>第三次循环<ul>\n<li>next 指向了 null</li>\n<li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li>\n<li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"E:\\砥砺前行\\Java面试专题-资料\\day01-基础篇\\讲义\\img\\image-20210831085543224.png\" alt=\"image-20210831085543224\"></p>\n<p><strong>数据错乱（1.7，1.8 都会存在）</strong></p>\n<h3 id=\"6）key-的设计\"><a href=\"#6）key-的设计\" class=\"headerlink\" title=\"6）key 的设计\"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p>\n<ol>\n<li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li>\n<li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li>\n<li>key 的 hashCode 应该有良好的散列性</li>\n</ol>\n<p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HashMapMutableKey</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Student</span> stu <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        stu<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">19</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>stu<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> o<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> age <span class=\"token operator\">==</span> student<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> student<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>String 对象的 hashCode() 设计</strong></p>\n<ul>\n<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>\n<li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li>\n<li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li>\n<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul>\n<li>即 $32 ∗h -h $</li>\n<li>即 $2^5  ∗h -h$</li>\n<li>即 $h≪5  -h$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"8-解决hash冲突的办法有哪些？HashMap用的哪种？\"><a href=\"#8-解决hash冲突的办法有哪些？HashMap用的哪种？\" class=\"headerlink\" title=\"8. 解决hash冲突的办法有哪些？HashMap用的哪种？\"></a>8. 解决hash冲突的办法有哪些？HashMap用的哪种？</h2><p>解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。</p>\n<ul>\n<li>开放定址法也称为<code>再散列法</code>，基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code></li>\n<li>再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li>\n<li>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li>\n<li>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</li>\n</ul>\n<h2 id=\"9-为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树\"><a href=\"#9-为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树\" class=\"headerlink\" title=\"9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?\"></a>9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h2><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p>\n<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>\n<h2 id=\"10-HashMap默认加载因子为什么是-0-75，不是-0-6-或者-0-8-？\"><a href=\"#10-HashMap默认加载因子为什么是-0-75，不是-0-6-或者-0-8-？\" class=\"headerlink\" title=\"10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？\"></a>10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？</h2><p>回答这个问题前，我们来先看下HashMap的默认构造函数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// 容纳键值对的最大值</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 负载因子</span>\n<span class=\"token keyword\">int</span> modCount<span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold &#x3D; length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>\n<p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p>\n<ul>\n<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li>\n<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li>\n</ul>\n<p>我们来追溯下作者在源码中的注释（JDK1.7）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>\n<h2 id=\"11-HashMap-中-key-的存储索引是怎么计算的？\"><a href=\"#11-HashMap-中-key-的存储索引是怎么计算的？\" class=\"headerlink\" title=\"11. HashMap 中 key 的存储索引是怎么计算的？\"></a>11. HashMap 中 key 的存储索引是怎么计算的？</h2><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。看看源码的实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// jdk1.7</span>\n<span class=\"token comment\">//方法一：</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> hashSeed<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> <span class=\"token operator\">!=</span> h <span class=\"token operator\">&amp;&amp;</span> k <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token class-name\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span>Hashing</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringHash32</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n    h <span class=\"token operator\">^=</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 为第一步：取hashCode值</span>\n    h <span class=\"token operator\">^=</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> h <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//方法二：</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样</span>\n     <span class=\"token keyword\">return</span> h <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//第三步：取模运算</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// jdk1.8</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n     <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/* \n     h = key.hashCode() 为第一步：取hashCode值\n     h ^ (h >>> 16)  为第二步：高位参与运算\n    */</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>这里的 Hash 算法本质上就是三步：<strong>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</strong>。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。</p>\n<p><a href=\"https://camo.githubusercontent.com/f75a09581111489d3c496582c8b5676919957d4e30edcf64ac933beb5e01716e/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303131323139313932303131312e706e67\"><img src=\"https://camo.githubusercontent.com/f75a09581111489d3c496582c8b5676919957d4e30edcf64ac933beb5e01716e/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f696d6167652d32303231303131323139313932303131312e706e67\" alt=\"image-20210112191920111\"></a></p>\n<h2 id=\"12-HashMap-的put方法流程？\"><a href=\"#12-HashMap-的put方法流程？\" class=\"headerlink\" title=\"12. HashMap 的put方法流程？\"></a>12. HashMap 的put方法流程？</h2><p>简要流程如下：</p>\n<ol>\n<li><p>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</p>\n</li>\n<li><p>如果数组是空的，则调用 resize 进行初始化；</p>\n</li>\n<li><p>如果没有哈希冲突直接放在对应的数组下标里；</p>\n</li>\n<li><p>如果冲突了，且 key 已经存在，就覆盖掉 value；</p>\n</li>\n<li><p>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</p>\n</li>\n<li><p>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</p>\n<p><a href=\"https://camo.githubusercontent.com/5db65c891539d37f7b4fc65014969487be3d2f80a3462f19eb0ac772bf82ac0a/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f686173686d61702545342542392538427075742545362539362542392545362542332539352e6a7067\"><img src=\"https://camo.githubusercontent.com/5db65c891539d37f7b4fc65014969487be3d2f80a3462f19eb0ac772bf82ac0a/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f686173686d61702545342542392538427075742545362539362542392545362542332539352e6a7067\" alt=\"hashmap之put方法(JDK1.8)\"></a></p>\n</li>\n</ol>\n<h2 id=\"13-HashMap-的扩容方式？\"><a href=\"#13-HashMap-的扩容方式？\" class=\"headerlink\" title=\"13. HashMap 的扩容方式？\"></a>13. HashMap 的扩容方式？</h2><p>那扩容的具体步骤是什么？让我们看看源码。</p>\n<p>先来看下JDK1.7 的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   <span class=\"token comment\">//传入新的容量</span>\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> oldTable <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//引用扩容前的Entry数组</span>\n        <span class=\"token keyword\">int</span> oldCapacity <span class=\"token operator\">=</span> oldTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">==</span> <span class=\"token constant\">MAXIMUM_CAPACITY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//扩容前的数组大小如果已经达到最大(2^30)了</span>\n            threshold <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span>newCapacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//初始化一个新的Entry数组</span>\n        <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>newTable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                         <span class=\"token comment\">//！！将数据转移到新的Entry数组里</span>\n        table <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">;</span>                           <span class=\"token comment\">//HashMap的table属性引用新的Entry数组</span>\n        threshold <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">*</span> loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//修改阈值</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> src <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">//src引用了旧的Entry数组</span>\n        <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> src<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//遍历旧的Entry数组</span>\n            <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">=</span> src<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">//取得旧Entry数组的每个元素</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n              src<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//！！重新计算每个元素在数组中的位置</span>\n                    e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//标记[1]</span>\n                    newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//将元素放在数组上</span>\n                    e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>             <span class=\"token comment\">//访问下一个Entry链上的元素</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p>\n<h2 id=\"14-一般用什么作为HashMap的key\"><a href=\"#14-一般用什么作为HashMap的key\" class=\"headerlink\" title=\"14. 一般用什么作为HashMap的key?\"></a>14. 一般用什么作为HashMap的key?</h2><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>\n<ul>\n<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li>\n<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>\n<li>缓存了-128到127之间的所有整数，这是用于提高性能的一种优化技巧。在创建 Integer 对象时，如果它表示的是缓存中的一个整数，那么会直接返回缓存中的实例，而不是新建一个对象。这意味着这些整数的对象只有一个，不同的变量都引用的是同一个对象实例，这也就保证了这些对象是不可变的。</li>\n</ul>\n<h2 id=\"15-HashMap为什么线程不安全？\"><a href=\"#15-HashMap为什么线程不安全？\" class=\"headerlink\" title=\"15. HashMap为什么线程不安全？\"></a>15. HashMap为什么线程不安全？</h2><p><a href=\"https://camo.githubusercontent.com/78693ffd4f81e9013fbe07993a7db303965e4d22dea647efb215e19bfdf5be3b/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f486173684d61702545342542382542412545342542422538302545342542392538382545372542412542462545372541382538422545342542382538442545352541452538392545352538352541382e706e67\"><img src=\"https://camo.githubusercontent.com/78693ffd4f81e9013fbe07993a7db303965e4d22dea647efb215e19bfdf5be3b/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f486173684d61702545342542382542412545342542422538302545342542392538382545372542412542462545372541382538422545342542382538442545352541452538392545352538352541382e706e67\" alt=\"img\"></a></p>\n<ul>\n<li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>\n<li>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n<li>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n</ul>\n<p>具体分析可见大佬的这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjUxMTI4NA==&mid=2247484436&idx=1&sn=eb677611e2ba1d10e3eb3ceb825bef02&chksm=cf54d8cff82351d9cb1c6ad49b6df8b7f0eaa7b965e3be5546b449e71ce1ffccf47ae68f7bf7&token=1920060057&lang=zh_CN#rd\">面试官：HashMap 为什么线程不安全？</a></p>\n<h2 id=\"16-ConcurrentHashMap-的实现原理是什么？\"><a href=\"#16-ConcurrentHashMap-的实现原理是什么？\" class=\"headerlink\" title=\"16. ConcurrentHashMap 的实现原理是什么？\"></a>16. ConcurrentHashMap 的实现原理是什么？</h2><p>ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。</p>\n<p><strong>先来看下JDK1.7</strong></p>\n<p>JDK1.7中的ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p>\n<p>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。</p>\n<p><a href=\"https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67\"><img src=\"https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67\" alt=\"img\"></a></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>\n<p><strong>JDK1.8</strong></p>\n<p>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加低粒度的锁。</p>\n<p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>\n<p><a href=\"https://camo.githubusercontent.com/7b73df7dd7039ffd1a7639bae5fb00f5e78094564eb45997a83251fbf9047ea8/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e382e706e67\"><img src=\"https://camo.githubusercontent.com/7b73df7dd7039ffd1a7639bae5fb00f5e78094564eb45997a83251fbf9047ea8/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e382e706e67\" alt=\"img\"></a></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","feature":true,"text":"1. 常见的集合有哪些？Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意：Col...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">1. 常见的集合有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">2. 线程安全的集合有哪些？线程不安全的呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Arraylist%E4%B8%8E-LinkedList-%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">3. Arraylist与 LinkedList 异同点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-ArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4. ArrayList 与 Vector 区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">5. 说一说ArrayList 的扩容机制？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E5%BA%94-Array-%E8%80%8C%E4%B8%8D%E6%98%AF-ArrayList-%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-HashMap\"><span class=\"toc-text\">7. HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1）基本数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E6%A0%91%E5%8C%96%E4%B8%8E%E9%80%80%E5%8C%96\"><span class=\"toc-text\">2）树化与退化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">3）索引计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89put-%E4%B8%8E%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">4）put 与扩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5）并发问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%EF%BC%89key-%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">6）key 的设计</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F\"><span class=\"toc-text\">8. 解决hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%E8%80%8C%E9%80%89%E6%8B%A9%E5%85%88%E7%94%A8%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%86%8D%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75%EF%BC%8C%E4%B8%8D%E6%98%AF-0-6-%E6%88%96%E8%80%85-0-8-%EF%BC%9F\"><span class=\"toc-text\">10. HashMap默认加载因子为什么是 0.75，不是 0.6 或者 0.8 ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-HashMap-%E4%B8%AD-key-%E7%9A%84%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">11. HashMap 中 key 的存储索引是怎么计算的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-HashMap-%E7%9A%84put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">12. HashMap 的put方法流程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">13. HashMap 的扩容方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key\"><span class=\"toc-text\">14. 一般用什么作为HashMap的key?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">15. HashMap为什么线程不安全？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">16. ConcurrentHashMap 的实现原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Redis实战-用户签到_UV统计","uid":"37c665cf8e0e08ae6a11b540ba094729","slug":"Redis实战-用户签到","date":"2023-06-06T02:48:05.000Z","updated":"2023-06-06T03:25:10.077Z","comments":true,"path":"api/articles/Redis实战-用户签到.json","keywords":null,"cover":[],"text":"用户签到用户签到-BitMap功能演示我们针对签到功能完全可以通过mysql来完成，比如说以下这张表 用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}