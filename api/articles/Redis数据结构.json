{"title":"Redis数据结构","uid":"95d031e6876e8ced445f4faed1bda7eb","slug":"Redis数据结构","date":"2023-06-16T13:30:38.000Z","updated":"2023-06-17T10:15:26.357Z","comments":true,"path":"api/articles/Redis数据结构.json","keywords":null,"cover":[],"content":"<h3 id=\"Redis数据结构-动态字符串SDS\"><a href=\"#Redis数据结构-动态字符串SDS\" class=\"headerlink\" title=\"Redis数据结构-动态字符串SDS\"></a>Redis数据结构-动态字符串SDS</h3><p>Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p>\n<ul>\n<li>获取字符串长度的需要通过运算</li>\n<li>非二进制安全</li>\n<li>不可修改</li>\n</ul>\n<p>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p>\n<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984624671.png\" alt=\"1653984624671\"></p>\n<p>例如，一个包含字符串“name”的sds结构如下：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984648404.png\" alt=\"1653984648404\"></p>\n<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984787383.png\" alt=\"1653984787383\"></p>\n<p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>\n<p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p>\n<p>alloc（申请长度） &#x3D; len * 2 实际申请为 len * 2 + 1多出一位用来存\\0</p>\n<p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984822363.png\" alt=\"1653984822363\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984838306.png\" alt=\"1653984838306\"></p>\n<p>二进制安全：根据len读取，不会因为在中间读到\\0而结束</p>\n<h3 id=\"Redis数据结构-intset\"><a href=\"#Redis数据结构-intset\" class=\"headerlink\" title=\"Redis数据结构-intset\"></a>Redis数据结构-intset</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984923322.png\" alt=\"1653984923322\"></p>\n<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984942385.png\" alt=\"1653984942385\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985149557.png\" alt=\"1653985149557\"></p>\n<p>startPtr为起始地址，数组从0开始遍历，为了方便计算地址（每个元素距离开始元素的位置）</p>\n<p>数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  &#x3D; 6字节</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985197214.png\" alt=\"1653985197214\"></p>\n<p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>\n<ul>\n<li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>\n<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>\n<li>将待添加的元素放入数组末尾</li>\n<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>\n</ul>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985276621.png\" alt=\"1653985276621\"></p>\n<p>源码如下：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985304075.png\" alt=\"1653985304075\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985327653.png\" alt=\"1653985327653\"></p>\n<p>小总结：</p>\n<p>Intset可以看做是特殊的整数数组，具备一些特点：</p>\n<ul>\n<li>Redis会确保Intset中的元素唯一、<strong>有序</strong></li>\n<li>具备类型升级机制，可以节省内存空间</li>\n<li>底层采用二分查找方式来查询</li>\n</ul>\n<h3 id=\"Redis数据结构-Dict\"><a href=\"#Redis数据结构-Dict\" class=\"headerlink\" title=\"Redis数据结构-Dict\"></a>Redis数据结构-Dict</h3><p>Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。</p>\n<p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985497735.png\" alt=\"1653985497735\"></p>\n<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985570612.png\" alt=\"1653985570612\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985586543.png\" alt=\"1653985586543\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985640422.png\" alt=\"1653985640422\"></p>\n<p><strong>Dict的扩容</strong></p>\n<p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：<br>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；<br>哈希表的 LoadFactor &gt; 5 ；</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985716275.png\" alt=\"1653985716275\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985743412.png\" alt=\"1653985743412\"></p>\n<p><strong>Dict的rehash</strong></p>\n<p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p>\n<ul>\n<li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p>\n<ul>\n<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li>\n<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>\n</ul>\n</li>\n<li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p>\n</li>\n<li><p>设置dict.rehashidx &#x3D; 0，标示开始rehash</p>\n</li>\n<li><p>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</p>\n</li>\n<li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>\n</li>\n<li><p>将rehashidx赋值为-1，代表rehash结束</p>\n</li>\n<li><p>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</p>\n</li>\n</ul>\n<p>整个过程可以描述成：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985824540.png\" alt=\"1653985824540\"></p>\n<p>小总结：</p>\n<p>Dict的结构：</p>\n<ul>\n<li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li>\n<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>\n</ul>\n<p>Dict的伸缩：</p>\n<ul>\n<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>\n<li>当LoadFactor小于0.1时，Dict收缩</li>\n<li>扩容大小为第一个大于等于used + 1的2^n</li>\n<li>收缩大小为第一个大于等于used 的2^n</li>\n<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>\n<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>\n</ul>\n<h3 id=\"Redis数据结构-ZipList\"><a href=\"#Redis数据结构-ZipList\" class=\"headerlink\" title=\"Redis数据结构-ZipList\"></a>Redis数据结构-ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653985987327.png\" alt=\"1653985987327\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986020491.png\" alt=\"1653986020491\"></p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>类型</strong></th>\n<th><strong>长度</strong></th>\n<th><strong>用途</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zlbytes</td>\n<td>uint32_t</td>\n<td>4 字节</td>\n<td>记录整个压缩列表占用的内存字节数</td>\n</tr>\n<tr>\n<td>zltail</td>\n<td>uint32_t</td>\n<td>4 字节</td>\n<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>\n</tr>\n<tr>\n<td>zllen</td>\n<td>uint16_t</td>\n<td>2 字节</td>\n<td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>\n</tr>\n<tr>\n<td>entry</td>\n<td>列表节点</td>\n<td>不定</td>\n<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>\n</tr>\n<tr>\n<td>zlend</td>\n<td>uint8_t</td>\n<td>1 字节</td>\n<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>\n</tr>\n</tbody></table>\n<p><strong>ZipListEntry</strong></p>\n<p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986055253.png\" alt=\"1653986055253\"></p>\n<ul>\n<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>\n<ul>\n<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>\n<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>\n</ul>\n</li>\n<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>\n</li>\n<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>\n</li>\n</ul>\n<p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p>\n<p><strong>Encoding编码</strong></p>\n<p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p>\n<table>\n<thead>\n<tr>\n<th><strong>编码</strong></th>\n<th><strong>编码长度</strong></th>\n<th><strong>字符串大小</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>|00pppppp|</td>\n<td>1 bytes</td>\n<td>&lt;&#x3D; 63 bytes</td>\n</tr>\n<tr>\n<td>|01pppppp|qqqqqqqq|</td>\n<td>2 bytes</td>\n<td>&lt;&#x3D; 16383 bytes</td>\n</tr>\n<tr>\n<td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>\n<td>5 bytes</td>\n<td>&lt;&#x3D; 4294967295 bytes</td>\n</tr>\n</tbody></table>\n<p>例如，我们要保存字符串：“ab”和 “bc”</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986172002.png\" alt=\"1653986172002\"></p>\n<p> ZipListEntry中的encoding编码分为字符串和整数两种：</p>\n<ul>\n<li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>编码</strong></th>\n<th><strong>编码长度</strong></th>\n<th><strong>整数类型</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>11000000</td>\n<td>1</td>\n<td>int16_t（2 bytes）</td>\n</tr>\n<tr>\n<td>11010000</td>\n<td>1</td>\n<td>int32_t（4 bytes）</td>\n</tr>\n<tr>\n<td>11100000</td>\n<td>1</td>\n<td>int64_t（8 bytes）</td>\n</tr>\n<tr>\n<td>11110000</td>\n<td>1</td>\n<td>24位有符整数(3 bytes)</td>\n</tr>\n<tr>\n<td>11111110</td>\n<td>1</td>\n<td>8位有符整数(1 bytes)</td>\n</tr>\n<tr>\n<td>1111xxxx</td>\n<td>1</td>\n<td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td>\n</tr>\n</tbody></table>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986282879.png\" alt=\"1653986282879\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986217182.png\" alt=\"1653986217182\"></p>\n<h4 id=\"ZipList的连锁更新问题\"><a href=\"#ZipList的连锁更新问题\" class=\"headerlink\" title=\"ZipList的连锁更新问题\"></a>ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986328124.png\" alt=\"1653986328124\"></p>\n<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p>\n<p><strong>小总结：</strong></p>\n<p><strong>ZipList特性：</strong></p>\n<ul>\n<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>\n<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>\n<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>\n<li>增或删较大数据时有可能发生连续更新问题</li>\n</ul>\n<h3 id=\"Redis数据结构-QuickList\"><a href=\"#Redis数据结构-QuickList\" class=\"headerlink\" title=\"Redis数据结构-QuickList\"></a>Redis数据结构-QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是<strong>连续空间</strong>，如果内存占用较多，申请内存效率很低。</p>\n<p>​\t答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>\n<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>\n<p>​\t答：我们可以创建多个ZipList来分片存储数据。</p>\n<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>\n<p>​\t答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986474927.png\" alt=\"1653986474927\"></p>\n<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>\n<ul>\n<li>-1：每个ZipList的内存占用不能超过4kb</li>\n<li>-2：每个ZipList的内存占用不能超过8kb</li>\n<li>-3：每个ZipList的内存占用不能超过16kb</li>\n<li>-4：每个ZipList的内存占用不能超过32kb</li>\n<li>-5：每个ZipList的内存占用不能超过64kb</li>\n</ul>\n<p>其默认值为 -2：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986642777.png\" alt=\"1653986642777\"></p>\n<p>以下是QuickList的和QuickListNode的结构源码：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986667228.png\" alt=\"1653986667228\"></p>\n<p>我们接下来用一段流程图来描述当前的这个结构</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986718554.png\" alt=\"1653986718554\"></p>\n<p>总结：</p>\n<p>QuickList的特点：</p>\n<ul>\n<li>是一个节点为ZipList的双端链表</li>\n<li>节点采用ZipList，解决了传统链表的内存占用问题</li>\n<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>\n<li>中间节点可以压缩，进一步节省了内存</li>\n</ul>\n<h3 id=\"Redis数据结构-SkipList\"><a href=\"#Redis数据结构-SkipList\" class=\"headerlink\" title=\"Redis数据结构-SkipList\"></a>Redis数据结构-SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986771309.png\" alt=\"1653986771309\"></p>\n<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照<strong>升序</strong>排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986813240.png\" alt=\"1653986813240\"></p>\n<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986877620.png\" alt=\"1653986877620\"></p>\n<p>小总结：</p>\n<p>SkipList的特点：</p>\n<ul>\n<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>\n<li>节点按照score值排序，score值一样则按照ele字典排序</li>\n<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>\n<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>\n<li>增删改查效率与红黑树基本一致，实现却更简单</li>\n</ul>\n<h3 id=\"Redis数据结构-RedisObject\"><a href=\"#Redis数据结构-RedisObject\" class=\"headerlink\" title=\"Redis数据结构-RedisObject\"></a>Redis数据结构-RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>\n<p>1、什么是redisObject：<br>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653986956618.png\" alt=\"1653986956618\"></p>\n<p>Redis的<strong>编码方式</strong></p>\n<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>\n<table>\n<thead>\n<tr>\n<th><strong>编号</strong></th>\n<th><strong>编码方式</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>OBJ_ENCODING_RAW</td>\n<td>raw编码动态字符串</td>\n</tr>\n<tr>\n<td>1</td>\n<td>OBJ_ENCODING_INT</td>\n<td>long类型的整数的字符串</td>\n</tr>\n<tr>\n<td>2</td>\n<td>OBJ_ENCODING_HT</td>\n<td>hash表（字典dict）</td>\n</tr>\n<tr>\n<td>3</td>\n<td>OBJ_ENCODING_ZIPMAP</td>\n<td>已废弃</td>\n</tr>\n<tr>\n<td>4</td>\n<td>OBJ_ENCODING_LINKEDLIST</td>\n<td>双端链表</td>\n</tr>\n<tr>\n<td>5</td>\n<td>OBJ_ENCODING_ZIPLIST</td>\n<td>压缩列表</td>\n</tr>\n<tr>\n<td>6</td>\n<td>OBJ_ENCODING_INTSET</td>\n<td>整数集合</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OBJ_ENCODING_SKIPLIST</td>\n<td>跳表</td>\n</tr>\n<tr>\n<td>8</td>\n<td>OBJ_ENCODING_EMBSTR</td>\n<td>embstr的动态字符串</td>\n</tr>\n<tr>\n<td>9</td>\n<td>OBJ_ENCODING_QUICKLIST</td>\n<td>快速列表</td>\n</tr>\n<tr>\n<td>10</td>\n<td>OBJ_ENCODING_STREAM</td>\n<td>Stream流</td>\n</tr>\n</tbody></table>\n<p>五种数据结构</p>\n<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>编码方式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OBJ_STRING</td>\n<td>int、embstr、raw</td>\n</tr>\n<tr>\n<td>OBJ_LIST</td>\n<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>\n</tr>\n<tr>\n<td>OBJ_SET</td>\n<td>intset、HT</td>\n</tr>\n<tr>\n<td>OBJ_ZSET</td>\n<td>ZipList、HT、SkipList</td>\n</tr>\n<tr>\n<td>OBJ_HASH</td>\n<td>ZipList、HT</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-8-Redis数据结构-String\"><a href=\"#1-8-Redis数据结构-String\" class=\"headerlink\" title=\"1.8 Redis数据结构-String\"></a>1.8 Redis数据结构-String</h3><p>String是Redis中最常见的数据存储类型：</p>\n<p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>\n<p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时</p>\n<p>只需要调用一次内存分配函数，效率更高。</p>\n<p>（1）底层实现⽅式：动态字符串sds 或者 long<br>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987103450.png\" alt=\"1653987103450\"></p>\n<p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987159575.png\" alt=\"1653987159575\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987172764.png\" alt=\"1653987172764\"></p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987202522.png\" alt=\"1653987202522\"></p>\n<p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p>\n<p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</p>\n<h3 id=\"Redis数据结构-List\"><a href=\"#Redis数据结构-List\" class=\"headerlink\" title=\"Redis数据结构-List\"></a>Redis数据结构-List</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987240622.png\" alt=\"1653987240622\"></p>\n<p>哪一个数据结构能满足上述特征？</p>\n<ul>\n<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>\n<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>\n<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>\n</ul>\n<p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>\n<p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>\n<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>\n<p><img src=\"D:/Java成神之路/7、2022版Redis入门到精通/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653987313461.png\" alt=\"1653987313461\"></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","feature":true,"text":"Redis数据结构-动态字符串SDSRedis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题： 获取字符串长度的需要通过运算 非二进制安全 不可修改 Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。 R...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS\"><span class=\"toc-text\">Redis数据结构-动态字符串SDS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-intset\"><span class=\"toc-text\">Redis数据结构-intset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Dict\"><span class=\"toc-text\">Redis数据结构-Dict</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ZipList\"><span class=\"toc-text\">Redis数据结构-ZipList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">ZipList的连锁更新问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-QuickList\"><span class=\"toc-text\">Redis数据结构-QuickList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-SkipList\"><span class=\"toc-text\">Redis数据结构-SkipList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-RedisObject\"><span class=\"toc-text\">Redis数据结构-RedisObject</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-String\"><span class=\"toc-text\">1.8 Redis数据结构-String</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-List\"><span class=\"toc-text\">Redis数据结构-List</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java I/O","uid":"2c570c14ab50f79f35e97f38eeea9026","slug":"Java-IO","date":"2023-06-17T09:45:56.000Z","updated":"2023-06-17T10:15:17.802Z","comments":true,"path":"api/articles/Java-IO.json","keywords":null,"cover":null,"text":"I&#x2F;O 流的分类按照读写的单位大小来分： 字符流：以字符为单位，每次次读入或读出是 16 位数据。其只能读取字符类型数据。(Java 代码接收数据一般为 char 数组，也可以是别的) 字节流：以字节为单位，每次读入或读出是 8 位数据。可以读任何类型数据，图片、文件、...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":28,"path":"api/tags/Java.json"},{"name":"IO","slug":"IO","count":2,"path":"api/tags/IO.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Linux实战操作","uid":"1259182ad65f322df495428ef17055e6","slug":"Linux实战操作","date":"2023-06-16T04:22:35.000Z","updated":"2023-06-16T13:25:14.926Z","comments":true,"path":"api/articles/Linux实战操作.json","keywords":null,"cover":[],"text":"一个开源的中文查Linux命令的网站：https://wangchujiang.com/linux-command/list.html Linux目录结构 &#x2F;bin 是Binary的缩写，这个目录存放着最经典的常用命令 &#x2F;Sbin s是Super User的意...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Shell","slug":"Shell","count":1,"path":"api/tags/Shell.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}