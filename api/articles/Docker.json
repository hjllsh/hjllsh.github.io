{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2023-05-24T11:24:04.000Z","updated":"2023-05-24T12:33:11.159Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":[],"content":"<h3 id=\"Docker的用途\"><a href=\"#Docker的用途\" class=\"headerlink\" title=\"Docker的用途\"></a>Docker的用途</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>\n<ul>\n<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>\n<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>\n</ul>\n<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>\n<ul>\n<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>\n</ul>\n<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul>\n<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>\n<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>\n<li>启动、移除都可以通过一行命令完成，方便快捷</li>\n</ul>\n<h3 id=\"Docker和虚拟机的区别\"><a href=\"#Docker和虚拟机的区别\" class=\"headerlink\" title=\"Docker和虚拟机的区别\"></a>Docker和虚拟机的区别</h3><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>\n<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>\n<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统。</p>\n<p>对比：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Docker</th>\n<th>虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>性能</td>\n<td>接近原生</td>\n<td>性能较差</td>\n</tr>\n<tr>\n<td>磁盘占用</td>\n<td>一般为MB</td>\n<td>一般为GB</td>\n</tr>\n<tr>\n<td>启动</td>\n<td>秒级</td>\n<td>分钟级</td>\n</tr>\n</tbody></table>\n<p>Docker和虚拟机的差异：</p>\n<ul>\n<li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p>\n</li>\n<li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>\n</li>\n</ul>\n<h3 id=\"Docker架构\"><a href=\"#Docker架构\" class=\"headerlink\" title=\"Docker架构\"></a>Docker架构</h3><h4 id=\"镜像和容器\"><a href=\"#镜像和容器\" class=\"headerlink\" title=\"镜像和容器\"></a>镜像和容器</h4><p>Docker中有几个重要的概念：</p>\n<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>\n<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>\n<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成<strong>进程</strong>。</p>\n<p><strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>\n<p><strong>容器</strong>，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>\n<h3 id=\"DockerHub\"><a href=\"#DockerHub\" class=\"headerlink\" title=\"DockerHub\"></a>DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>\n<ul>\n<li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p>\n</li>\n<li><p>国内也有类似于DockerHub 的公开服务，比如 <a href=\"https://c.163yun.com/hub\">网易云镜像服务</a>、<a href=\"https://cr.console.aliyun.com/\">阿里云镜像库</a>等。</p>\n</li>\n</ul>\n<h4 id=\"Docker架构-1\"><a href=\"#Docker架构-1\" class=\"headerlink\" title=\"Docker架构\"></a>Docker架构</h4><p>Docker是一个CS架构的程序，由两部分组成：</p>\n<ul>\n<li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>\n</li>\n<li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>\n</li>\n</ul>\n<p><img src=\"/../assets/docker%E6%9E%B6%E6%9E%84.png\" alt=\"docker架构\"></p>\n<h3 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h3><h4 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum remove <span class=\"token function\">docker</span> <span class=\"token punctuation\">\\</span>\n                  docker-client <span class=\"token punctuation\">\\</span>\n                  docker-client-latest <span class=\"token punctuation\">\\</span>\n                  docker-common <span class=\"token punctuation\">\\</span>\n                  docker-latest <span class=\"token punctuation\">\\</span>\n                  docker-latest-logrotate <span class=\"token punctuation\">\\</span>\n                  docker-logrotate <span class=\"token punctuation\">\\</span>\n                  docker-selinux <span class=\"token punctuation\">\\</span>\n                  docker-engine-selinux <span class=\"token punctuation\">\\</span>\n                  docker-engine <span class=\"token punctuation\">\\</span>\n                  docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h4><p>安装yum工具</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> yum-utils <span class=\"token punctuation\">\\</span>\n           device-mapper-persistent-data <span class=\"token punctuation\">\\</span>\n           lvm2 --skip-broken<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>然后更新本地镜像源：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum-config-manager <span class=\"token punctuation\">\\</span>\n    --add-repo <span class=\"token punctuation\">\\</span>\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \n<span class=\"token function\">sed</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g'</span> /etc/yum.repos.d/docker-ce.repo\n\nyum makecache fast<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后输入命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yum install -y docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"docker启动相关命令\"><a href=\"#docker启动相关命令\" class=\"headerlink\" title=\"docker启动相关命令\"></a>docker启动相关命令</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 关闭</span>\nsystemctl stop firewalld\n<span class=\"token comment\"># 禁止开机启动防火墙</span>\nsystemctl disable firewalld\n\nsystemctl start <span class=\"token function\">docker</span>  <span class=\"token comment\"># 启动docker服务</span>\n\nsystemctl stop <span class=\"token function\">docker</span>  <span class=\"token comment\"># 停止docker服务</span>\n\nsystemctl restart <span class=\"token function\">docker</span>  <span class=\"token comment\"># 重启docker服务</span>\n\n<span class=\"token function\">docker</span> <span class=\"token parameter variable\">-v</span>\t\t\t<span class=\"token comment\">#查看docker版本</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"CentOS7安装DockerCompose\"><a href=\"#CentOS7安装DockerCompose\" class=\"headerlink\" title=\"CentOS7安装DockerCompose\"></a>CentOS7安装DockerCompose</h3><h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p>Linux下需要通过命令下载：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 安装</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-s</span><span class=\"token variable\">`</span></span>-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-m</span><span class=\"token variable\">`</span></span> <span class=\"token operator\">></span> /usr/local/bin/docker-compose<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 修改权限</span>\n<span class=\"token function\">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"Base自动补全命令\"><a href=\"#Base自动补全命令\" class=\"headerlink\" title=\"Base自动补全命令\"></a>Base自动补全命令</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 补全命令</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose <span class=\"token operator\">></span> /etc/bash_completion.d/docker-compose<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果这里出现错误，需要修改自己的hosts文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"199.232.68.133 raw.githubusercontent.com\"</span> <span class=\"token operator\">>></span> /etc/hosts<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"Docker的基本操作\"><a href=\"#Docker的基本操作\" class=\"headerlink\" title=\"Docker的基本操作\"></a>Docker的基本操作</h3><h4 id=\"镜像操作\"><a href=\"#镜像操作\" class=\"headerlink\" title=\"镜像操作\"></a>镜像操作</h4><p><strong>镜像名称</strong></p>\n<p>镜像的名称组成：</p>\n<ul>\n<li>镜名称一般分两部分组成：[repository]:[tag]。</li>\n<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>\n</ul>\n<p>mysql:5.7\t中mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>\n<p><strong>镜像命令</strong></p>\n<p>需求：从DockerHub中拉取一个nginx镜像并查看</p>\n<ul>\n<li><p>首先去镜像仓库搜索nginx镜像，比如<a href=\"https://hub.docker.com/\">DockerHub</a>:</p>\n</li>\n<li><p>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<code>docker pull nginx</code></p>\n</li>\n<li><p>通过命令：<code>docker images</code> 查看拉取到的镜像</p>\n</li>\n</ul>\n<p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>\n<ul>\n<li>利用<code>docker xx --help</code>命令查看<code>docker save</code>和<code>docker load</code>的语法；如<code>docker save --help</code></li>\n</ul>\n<p>​\t命令格式：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> <span class=\"token punctuation\">[</span>保存的目标文件名称<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>镜像名称<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>使用docker save导出镜像到磁盘</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> nginx.tar nginx:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>使用docker load加载镜像</li>\n</ul>\n<p>​\t\t先删除本地的nginx镜像：<code>docker rmi nginx:latest</code></p>\n<p>​\t\t然后运行命令，加载本地文件：<code>docker load -i nginx.tar</code></p>\n<h3 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h3><h4 id=\"容器相关命令\"><a href=\"#容器相关命令\" class=\"headerlink\" title=\"容器相关命令\"></a>容器相关命令</h4><p>容器操作的命令如图：</p>\n<p><img src=\"/../assets/%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4%E5%9B%BE.png\" alt=\"容器命令图\"></p>\n<p>容器保护三个状态：</p>\n<ul>\n<li>运行：进程正常运行</li>\n<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>\n<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>\n</ul>\n<p>容器操作的常用命令</p>\n<ul>\n<li><p>docker run：创建并运行一个容器，处于运行状态</p>\n</li>\n<li><p>docker pause：让一个运行的容器暂停</p>\n</li>\n<li><p>docker unpause：让一个容器从暂停状态恢复运行</p>\n</li>\n<li><p>docker stop：停止一个运行的容器</p>\n</li>\n<li><p>docker start：让一个停止的容器再次运行</p>\n</li>\n<li><p>docker rm：删除一个容器</p>\n</li>\n</ul>\n<p>需求：创建并运行一个容器；例如nginx</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 创建并运行一个容器</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> containerName <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">-d</span> nginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>命令解读：</p>\n<ul>\n<li>docker run ：创建并运行一个容器</li>\n<li>–name : 给容器起一个名字</li>\n<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>\n<li>-d：后台运行容器</li>\n<li>nginx：镜像名称，例如nginx</li>\n</ul>\n<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx。</p>\n<p><img src=\"/../assets/%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.png\" alt=\"容器端口映射\"></p>\n<p>需求：案例-进入容器，修改文件；如：进入Nginx容器，修改HTML文件内容</p>\n<p>进入容器。进入刚刚创建的nginx容器的命令为：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> containerName <span class=\"token parameter variable\">-it</span>  <span class=\"token function\">bash</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>命令解读：</p>\n<ul>\n<li><p>docker exec ：进入容器内部，执行一个命令</p>\n</li>\n<li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>\n</li>\n<li><p>containerName ：要进入的容器的名称</p>\n</li>\n<li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>\n</li>\n</ul>\n<p>进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>\n<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样</p>\n<p><img src=\"/../assets/docker_nginx.png\" alt=\"docker_nginx\"></p>\n<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>\n<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>\n<h3 id=\"数据卷（容器数据管理）\"><a href=\"#数据卷（容器数据管理）\" class=\"headerlink\" title=\"数据卷（容器数据管理）\"></a>数据卷（容器数据管理）</h3><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。这就是因为容器与数据（容器内文件）耦合带来的后果。要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>\n<p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>\n<p><img src=\"/../assets/%E6%95%B0%E6%8D%AE%E5%8D%B7.png\" alt=\"数据卷\"></p>\n<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p>\n<h4 id=\"数据集操作命令\"><a href=\"#数据集操作命令\" class=\"headerlink\" title=\"数据集操作命令\"></a>数据集操作命令</h4><p>数据卷操作的基本语法如下：<code>docker volume [COMMAND]</code></p>\n<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>\n<ul>\n<li>create 创建一个volume</li>\n<li>inspect 显示一个或多个volume的信息,包括关联的宿主机目录位置</li>\n<li>ls 列出所有的volume</li>\n<li>prune 删除未使用的volume</li>\n<li>rm 删除一个或多个指定的volume</li>\n</ul>\n<h4 id=\"创建和查看数据卷\"><a href=\"#创建和查看数据卷\" class=\"headerlink\" title=\"创建和查看数据卷\"></a>创建和查看数据卷</h4><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>\n<p>创建数据卷</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> volume create html<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>查看所有数据</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> volume <span class=\"token function\">ls</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 查看数据卷详细信息卷</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> volume inspect html<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>可以看到html这个数据卷关联的宿主机目录</p>\n<h4 id=\"挂载数据卷\"><a href=\"#挂载数据卷\" class=\"headerlink\" title=\"挂载数据卷\"></a>挂载数据卷</h4><p>可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--name</span> mn <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-v</span> html:/root/html <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:80\n  nginx <span class=\"token punctuation\">\\</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</p>\n<h3 id=\"Dockerfile自定义镜像\"><a href=\"#Dockerfile自定义镜像\" class=\"headerlink\" title=\"Dockerfile自定义镜像\"></a>Dockerfile自定义镜像</h3><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>\n<h4 id=\"Dockerfile语法\"><a href=\"#Dockerfile语法\" class=\"headerlink\" title=\"Dockerfile语法\"></a>Dockerfile语法</h4>","feature":true,"text":"Docker的用途Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Dock...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Docker%E7%9A%84%E7%94%A8%E9%80%94\"><span class=\"toc-text\">Docker的用途</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Docker和虚拟机的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Docker%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">Docker架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">镜像和容器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DockerHub\"><span class=\"toc-text\">DockerHub</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Docker%E6%9E%B6%E6%9E%84-1\"><span class=\"toc-text\">Docker架构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85Docker\"><span class=\"toc-text\">安装Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">卸载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85docker\"><span class=\"toc-text\">安装docker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#docker%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">docker启动相关命令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CentOS7%E5%AE%89%E8%A3%85DockerCompose\"><span class=\"toc-text\">CentOS7安装DockerCompose</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">下载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90\"><span class=\"toc-text\">修改文件权限</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Base%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">Base自动补全命令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Docker的基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">镜像操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">容器操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">容器相关命令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%88%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89\"><span class=\"toc-text\">数据卷（容器数据管理）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">数据集操作命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">创建和查看数据卷</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7\"><span class=\"toc-text\">挂载数据卷</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">Dockerfile自定义镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dockerfile%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">Dockerfile语法</span></a></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2023-05-25T02:38:47.000Z","updated":"2023-05-25T15:12:11.103Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"NIO 基础non-blocking io 非阻塞 IO三大组件Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之...","link":"","photos":[],"count_time":{"symbolsCount":"47k","symbolsTime":"43 mins."},"categories":[],"tags":[{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"SQL优化","uid":"f515c75be93536d047fb1ea7dd55160d","slug":"SQL优化","date":"2023-05-23T13:48:45.000Z","updated":"2023-05-23T15:55:25.049Z","comments":true,"path":"api/articles/SQL优化.json","keywords":null,"cover":null,"text":"SQL优化插入数据insert 如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。 优化方案一 批量插入数据 Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerr...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":10,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}