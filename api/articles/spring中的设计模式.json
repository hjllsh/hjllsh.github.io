{"title":"spring中常见的设计模式","uid":"0c6e8405652937a86cc3782f838cf782","slug":"spring中的设计模式","date":"2023-05-09T04:00:50.000Z","updated":"2023-05-09T05:18:32.881Z","comments":true,"path":"api/articles/spring中的设计模式.json","keywords":null,"cover":null,"content":"<h2 id=\"Spring中常见的设计模式\"><a href=\"#Spring中常见的设计模式\" class=\"headerlink\" title=\"Spring中常见的设计模式\"></a>Spring中常见的设计模式</h2><h5 id=\"1-Spring中的单例模式\"><a href=\"#1-Spring中的单例模式\" class=\"headerlink\" title=\"1.Spring中的单例模式\"></a>1.Spring中的单例模式</h5><p><strong>单例模式</strong> 与 <strong>单例bean</strong> 的区别</p>\n<ul>\n<li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em></li>\n</ul>\n<p>就是确保只有一个实例提供给全局使用</p>\n<ul>\n<li><p>显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例</p>\n<p> <strong>Spring中也有用到单例模式</strong></p>\n</li>\n<li><p>org.springframework.transaction.TransactionDefinition#withDefaults</p>\n</li>\n<li><p>org.springframework.aop.TruePointcut#INSTANCE</p>\n</li>\n<li><p>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</p>\n</li>\n<li><p>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</p>\n</li>\n<li><p>org.springframework.core.OrderComparator#INSTANCE</p>\n</li>\n</ul>\n<h5 id=\"2-Spring中的Builder（建造者模式）\"><a href=\"#2-Spring中的Builder（建造者模式）\" class=\"headerlink\" title=\"2.Spring中的Builder（建造者模式）\"></a>2.Spring中的Builder（建造者模式）</h5><p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em> 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。</p>\n<p>优点：</p>\n<ul>\n<li>较为灵活的构建产品对象</li>\n<li>在不执行最后 build 方法前，产品对象都不可用</li>\n<li>构建过程采用链式调用，看起来比较爽</li>\n</ul>\n<p>Spring 中体现 Builder 模式的地方：</p>\n<ul>\n<li>org.springframework.beans.factory.support.BeanDefinitionBuilder</li>\n<li>org.springframework.web.util.UriComponentsBuilder</li>\n<li>org.springframework.http.ResponseEntity.HeadersBuilder</li>\n<li>org.springframework.http.ResponseEntity.BodyBuilder</li>\n</ul>\n<h5 id=\"3-Spring中的Factory-Method-工厂方法模式\"><a href=\"#3-Spring中的Factory-Method-工厂方法模式\" class=\"headerlink\" title=\"3.Spring中的Factory Method(工厂方法模式)\"></a>3.Spring中的Factory Method(工厂方法模式)</h5><p>定义<em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em>  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。</p>\n<p>Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p>\n<p>Spring 中其它工厂：</p>\n<ul>\n<li><p>org.springframework.beans.factory.FactoryBean</p>\n</li>\n<li><p>@Bean 标注的静态方法及实例方法</p>\n</li>\n<li><p>ObjectFactory 及 ObjectProvider</p>\n</li>\n</ul>\n<p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p>\n<h5 id=\"4-Spring中的Adapter-适配器模式\"><a href=\"#4-Spring中的Adapter-适配器模式\" class=\"headerlink\" title=\"4.Spring中的Adapter(适配器模式)\"></a>4.Spring中的Adapter(适配器模式)</h5><p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em> 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。</p>\n","feature":true,"text":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别 根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it 就是确...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"},{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Spring中常见的设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Spring%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.Spring中的单例模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Spring%E4%B8%AD%E7%9A%84Builder%EF%BC%88%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">2.Spring中的Builder（建造者模式）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-Spring%E4%B8%AD%E7%9A%84Factory-Method-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.Spring中的Factory Method(工厂方法模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Spring%E4%B8%AD%E7%9A%84Adapter-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.Spring中的Adapter(适配器模式)</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"建造者模式","uid":"b00cac0eae3b04411014ea36945005af","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","updated":"2023-05-09T04:53:43.979Z","comments":true,"path":"api/articles/建造者模式.json","keywords":null,"cover":null,"text":"Java建造者模式Java中的建造者模式(Builder Pattern) 主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。 该模式包含以下几个角色： Builder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。 Concrete...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"单例模式","uid":"5e422a9b2c69bd7294ec71b84cbbb53b","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","updated":"2023-05-08T15:15:46.818Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":"/img/5.8.jpg","text":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":4,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}