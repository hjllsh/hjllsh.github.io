{"title":"spring中常见的设计模式","uid":"0c6e8405652937a86cc3782f838cf782","slug":"spring中的设计模式","date":"2023-05-09T04:00:50.000Z","updated":"2023-05-09T13:53:18.440Z","comments":true,"path":"api/articles/spring中的设计模式.json","keywords":null,"cover":null,"content":"<h2 id=\"Spring中常见的设计模式\"><a href=\"#Spring中常见的设计模式\" class=\"headerlink\" title=\"Spring中常见的设计模式\"></a>Spring中常见的设计模式</h2><h5 id=\"1-Spring中的单例模式\"><a href=\"#1-Spring中的单例模式\" class=\"headerlink\" title=\"1.Spring中的单例模式\"></a>1.Spring中的单例模式</h5><p><strong>单例模式</strong> 与 <strong>单例bean</strong> 的区别</p>\n<ul>\n<li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em></li>\n</ul>\n<p>就是确保只有一个实例提供给全局使用</p>\n<ul>\n<li><p>显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例</p>\n<p> <strong>Spring中也有用到单例模式</strong></p>\n</li>\n<li><p>org.springframework.transaction.TransactionDefinition#withDefaults</p>\n</li>\n<li><p>org.springframework.aop.TruePointcut#INSTANCE</p>\n</li>\n<li><p>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</p>\n</li>\n<li><p>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</p>\n</li>\n<li><p>org.springframework.core.OrderComparator#INSTANCE</p>\n</li>\n</ul>\n<h5 id=\"2-Spring中的Builder（建造者模式）\"><a href=\"#2-Spring中的Builder（建造者模式）\" class=\"headerlink\" title=\"2.Spring中的Builder（建造者模式）\"></a>2.Spring中的Builder（建造者模式）</h5><p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em> 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。</p>\n<p>优点：</p>\n<ul>\n<li>较为灵活的构建产品对象</li>\n<li>在不执行最后 build 方法前，产品对象都不可用</li>\n<li>构建过程采用链式调用，看起来比较爽</li>\n</ul>\n<p>Spring 中体现 Builder 模式的地方：</p>\n<ul>\n<li>org.springframework.beans.factory.support.BeanDefinitionBuilder</li>\n<li>org.springframework.web.util.UriComponentsBuilder</li>\n<li>org.springframework.http.ResponseEntity.HeadersBuilder</li>\n<li>org.springframework.http.ResponseEntity.BodyBuilder</li>\n</ul>\n<h5 id=\"3-Spring中的Factory-Method-工厂方法模式\"><a href=\"#3-Spring中的Factory-Method-工厂方法模式\" class=\"headerlink\" title=\"3.Spring中的Factory Method(工厂方法模式)\"></a>3.Spring中的Factory Method(工厂方法模式)</h5><p>定义<em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em>  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。</p>\n<p>Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p>\n<p>Spring 中其它工厂：</p>\n<ul>\n<li><p>org.springframework.beans.factory.FactoryBean</p>\n</li>\n<li><p>@Bean 标注的静态方法及实例方法</p>\n</li>\n<li><p>ObjectFactory 及 ObjectProvider</p>\n</li>\n</ul>\n<p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p>\n<h5 id=\"4-Spring中的Adapter-适配器模式\"><a href=\"#4-Spring中的Adapter-适配器模式\" class=\"headerlink\" title=\"4.Spring中的Adapter(适配器模式)\"></a>4.Spring中的Adapter(适配器模式)</h5><p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em> 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。</p>\n<p>典型的实现有两处:</p>\n<ul>\n<li>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有<ul>\n<li>@RequestMapping 标注的控制器实现</li>\n<li>传统的基于 Controller 接口（不是 @Controller注解啊）的实现</li>\n<li>较新的基于 RouterFunction 接口的实现</li>\n<li>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</li>\n</ul>\n</li>\n<li>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</li>\n</ul>\n<h5 id=\"5-Spring中的Composite-组合模式\"><a href=\"#5-Spring中的Composite-组合模式\" class=\"headerlink\" title=\"5.Spring中的Composite(组合模式)\"></a>5.Spring中的Composite(组合模式)</h5><p>定义 <em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em>  即将对象组合成树形结构来表示部分-整体层次结构。组合模式可以让客户端统一地对待单个对象和对象组合。</p>\n<p>典型实现有：</p>\n<ul>\n<li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li>\n<li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li>\n<li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li>\n<li>org.springframework.web.servlet.view.ViewResolverComposite</li>\n</ul>\n<p>composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是：与具体干活的类实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的类实现来完成                                                                     </p>\n<h5 id=\"6-Spring中的Decorator-装饰器模式\"><a href=\"#6-Spring中的Decorator-装饰器模式\" class=\"headerlink\" title=\"6.Spring中的Decorator(装饰器模式)\"></a>6.Spring中的Decorator(装饰器模式)</h5><p>定义 <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em> 即 向对象动态地附加职责。 装饰器提供了一种灵活的替代继承的方式，以扩展功能。</p>\n<p>典型实现：</p>\n<ul>\n<li>org.springframework.web.util.ContentCachingRequestWrapper</li>\n</ul>\n<p><code>ContentCachingRequestWrapper</code> 通过包装 <code>HttpServletRequest</code> 对象，提供了对输入流进行重复读取和缓存的功能。其构造函数需要传入一个原始的 <code>HttpServletRequest</code> 对象，然后使用自己的 <code>ByteArrayOutputStream</code> 缓存请求体，同时提供了多个方法来获取请求信息。例如：</p>\n<ul>\n<li><code>getContentAsByteArray()</code> : 获取请求的内容（byte 数组），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。</li>\n<li><code>getContentAsStream()</code> : 返回请求的内容流（<code>ServletInputStream</code>），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。</li>\n<li><code>getReader()</code> : 返回一个读取请求内容的 <code>BufferedReader</code> 实例，如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。</li>\n</ul>\n<p>总的来说，<code>ContentCachingRequestWrapper</code> 的实现非常好地体现了装饰器模式的思想，通过包装原始请求对象，提供了额外的功能，并且不改变原始对象的行为，从而实现了请求体的缓存和多次读取。</p>\n<h5 id=\"7-Spring中的Proxy-代理模式\"><a href=\"#7-Spring中的Proxy-代理模式\" class=\"headerlink\" title=\"7.Spring中的Proxy(代理模式)\"></a>7.Spring中的Proxy(代理模式)</h5><p>定义 <em>Provide a surrogate or placeholder for another object to control access to it</em> 即，为另一个对象提供一个代理或占位符来控制对它的访问。</p>\n<p>代理模式的主要目的是控制对目标对象的访问，在不改变原有代码的情况下，为对象提供一种间接访问的方式。代理模式在客户端和目标对象之间创建了一个代理对象，客户端通过代理对象来访问目标对象，从而可以对访问进行控制。代理模式可以用于保护目标对象的访问性、缓存对象等。</p>\n<p><strong>与装饰器模式的区别</strong></p>\n<p>装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问</p>\n<p>典型实现：</p>\n<ul>\n<li>org.springframework.aop.framework.JdkDynamicAopProxy</li>\n<li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li>\n</ul>\n<h5 id=\"8-Spring中的Chain-of-Responsibility-责任链模式\"><a href=\"#8-Spring中的Chain-of-Responsibility-责任链模式\" class=\"headerlink\" title=\"8.Spring中的Chain of Responsibility(责任链模式)\"></a>8.Spring中的Chain of Responsibility(责任链模式)</h5><p>定义 <em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em> 即 避免使用一个对象直接调用另一个对象，而是通过将请求传递给多个对象中的一个来处理请求。将接收对象链接在一起，并将请求沿着链传递，直到一个对象能够处理它。</p>\n<p>典型实现：</p>\n<ul>\n<li>org.springframework.web.servlet.HandlerInterceptor</li>\n</ul>\n<p><code>HandlerInterceptor</code>支持责任链模式，通过链式调用多个<code>HandlerInterceptor</code>，可以处理同一个请求的多个这样的拦截器。</p>\n<p>当一个请求到达后端控制器前，可以通过多个<code>HandlerInterceptor</code>按照特定的顺序进行处理。每个<code>HandlerInterceptor</code>可以处理请求，然后将处理结果传递给下一个<code>HandlerInterceptor</code>。这样，就形成了一个责任链。</p>\n<p>在责任链模式中，我们可以动态添加或删除<code>HandlerInterceptor</code>，并且可以定义多个拦截器链。这样，我们可以实现一些复杂的处理逻辑，将请求按照不同的方式进行处理，以达到更好的效果。</p>\n<h5 id=\"9-Spring-中的-Observer-观察者模式\"><a href=\"#9-Spring-中的-Observer-观察者模式\" class=\"headerlink\" title=\"9.Spring 中的 Observer(观察者模式)\"></a>9.Spring 中的 Observer(观察者模式)</h5><p>定义 <em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em> 即 定义一种一对多的对象依赖关系，这样当一个对象改变状态时，所有其依赖者将自动得到通知并更新。</p>\n<p>典型实现：</p>\n<ul>\n<li>org.springframework.context.ApplicationListener</li>\n<li>org.springframework.context.event.ApplicationEventMulticaster</li>\n<li>org.springframework.context.ApplicationEvent</li>\n</ul>\n<p>一个事件（ApplicationEvent）可以被ApplicationContext中的一个或多个ApplicationListener所监听。ApplicationContext会在事件发生时通知已注册的ApplicationListener，并由ApplicationListener来负责对该事件做出响应。</p>\n<p>为了实现这种模式，Spring提供了以下几个核心组件：</p>\n<ol>\n<li>ApplicationEvent：代表了一个应用程序中发生的事件，包含了事件的信息。</li>\n<li>ApplicationListener：负责处理事件，并进行响应的组件。</li>\n<li>ApplicationEventMulticaster：用于管理事件监听器，负责将事件分发给对应的监听器进行处理。</li>\n</ol>\n<p>当一个事件被触发时，ApplicationEventMulticaster会调用所有已注册的ApplicationListener实例的onApplicationEvent()方法来进行处理。当事件被多个ApplicationListener监听时，ApplicationEventMulticaster会按顺序调用它们的onApplicationEvent()方法。</p>\n<p>因此，Spring的事件驱动模型就体现了观察者模式的特征，其中ApplicationListener充当了观察者的角色，ApplicationEventMulticaster充当了被观察者的角色。</p>\n<h5 id=\"10-Spring-中的-Strategy-策略模式\"><a href=\"#10-Spring-中的-Strategy-策略模式\" class=\"headerlink\" title=\"10. Spring 中的 Strategy(策略模式)\"></a>10. Spring 中的 Strategy(策略模式)</h5><p>定义 <em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em> 即，定义一个算法族，将每个算法封装起来，使它们可以互换。策略模式能够让算法的变化独立于使用它们的客户端。</p>\n<p>典型实现：</p>\n<ul>\n<li>org.springframework.beans.factory.support.InstantiationStrategy</li>\n<li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li>\n<li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li>\n</ul>\n<p>org.springframework.beans.factory.support.InstantiationStrategy：<br>存在多个实现InstantiationStrategy接口的类，这些类都实现了不同的实例化策略，比如：CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy和SmartInstantiationStrategy等。这些实现类可以根据实际情况取舍，通过策略模式实现了实例化策略的动态切换。</p>\n<p>org.springframework.core.annotation.MergedAnnotations.SearchStrategy：<br>存在多个实现SearchStrategy接口的类，这些类都实现了不同的注解查找策略，比如：TypeMappedAnnotationChecker、RepeatableContainers、DirectlyDeclaredAnnotations和SynthesizedAnnotationDetection等。这些实现类可以根据实际情况取舍，通过策略模式实现了注解查找策略的动态切换。</p>\n<p>org.springframework.boot.autoconfigure.condition.SearchStrategy：<br>存在多个实现SearchStrategy接口的类，这些类都实现了不同的条件判断策略，比如：OnClassCondition、ConditionalOnWebApplication和ConditionalOnProperty等。这些实现类可以根据实际情况取舍，通过策略模式实现了条件判断策略的动态切换。</p>\n<h5 id=\"11-Spring-中的-Template-Method-模板方法\"><a href=\"#11-Spring-中的-Template-Method-模板方法\" class=\"headerlink\" title=\"11. Spring 中的 Template Method(模板方法)\"></a>11. Spring 中的 Template Method(模板方法)</h5><p>定义 <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em>  在一个操作中定义算法的框架，将某些步骤延迟到子类中。模板方法让子类重新定义算法的某些步骤，而不改变算法的结构。</p>\n<p>典型实现：</p>\n<ul>\n<li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li>\n<li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li>\n</ul>\n<p>在JdbcTemplate中，模板方法是execute()方法，它封装了执行SQL语句的流程，具体的SQL语句可以通过传入不同的参数来实现。execute()方法中包含了一些固定的步骤，如获取连接、创建Statement、执行SQL语句、关闭资源等，这些步骤是不变的，但是具体的SQL语句和参数是可以变化的。通过这种方式，JdbcTemplate将重复的、泛化的操作封装到模板方法中，使得使用者只需要关注具体的SQL语句和参数。</p>\n<p>TransactionTemplate也是类似的，在Spring事务管理中，它封装了执行事务的流程，具体的事务操作可以通过传入不同的参数来实现。TransactionTemplate中的模板方法是execute()方法，它包含了获取事务、执行方法、提交&#x2F;回滚事务等固定步骤，这些步骤是每个事务操作都必须要执行的，但是具体的事务操作可以改变。通过这种方式，TransactionTemplate将事务管理的复杂性封装到模板方法中，使用者只需要关注自己的业务逻辑，而不需要关心事务的管理。</p>\n<p>在AbstractApplicationContext中，模板方法是refresh()方法，该方法包含了Spring容器的初始化流程，具体的初始化过程可以通过继承AbstractApplicationContext的子类来实现。refresh()方法中包含了一些固定的步骤，比如读取配置文件、创建&#x2F;初始化BeanFactory、加载Bean定义、注册BeanPostProcessor等，这些步骤是不变的，但是具体的实现可以改变。子类根据自己的需要，可以通过重写refresh()方法中的一些步骤来实现自己的初始化过程，比如读取不同的配置文件、使用不同的BeanFactory等。</p>\n<p>通过这种方式，AbstractApplicationContext将Spring容器的初始化过程封装到模板方法中，使得使用者只需要关注具体的Bean的配置和使用，而不需要关心Spring容器的初始化过程。这样可以大大简化代码的编写和维护，提高开发效率。</p>\n","text":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别 根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it 就是确...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":12,"path":"api/tags/设计模式.json"},{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Spring中常见的设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Spring%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.Spring中的单例模式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Spring%E4%B8%AD%E7%9A%84Builder%EF%BC%88%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">2.Spring中的Builder（建造者模式）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-Spring%E4%B8%AD%E7%9A%84Factory-Method-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.Spring中的Factory Method(工厂方法模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Spring%E4%B8%AD%E7%9A%84Adapter-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.Spring中的Adapter(适配器模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-Spring%E4%B8%AD%E7%9A%84Composite-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.Spring中的Composite(组合模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-Spring%E4%B8%AD%E7%9A%84Decorator-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.Spring中的Decorator(装饰器模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-Spring%E4%B8%AD%E7%9A%84Proxy-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">7.Spring中的Proxy(代理模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-Spring%E4%B8%AD%E7%9A%84Chain-of-Responsibility-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">8.Spring中的Chain of Responsibility(责任链模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-Spring-%E4%B8%AD%E7%9A%84-Observer-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">9.Spring 中的 Observer(观察者模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#10-Spring-%E4%B8%AD%E7%9A%84-Strategy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">10. Spring 中的 Strategy(策略模式)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-Spring-%E4%B8%AD%E7%9A%84-Template-Method-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">11. Spring 中的 Template Method(模板方法)</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"建造者模式","uid":"b00cac0eae3b04411014ea36945005af","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","updated":"2023-05-09T04:53:43.979Z","comments":true,"path":"api/articles/建造者模式.json","keywords":null,"cover":null,"text":"Java建造者模式Java中的建造者模式(Builder Pattern) 主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。 该模式包含以下几个角色： Builder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。 Concrete...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":12,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"单例模式","uid":"5e422a9b2c69bd7294ec71b84cbbb53b","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","updated":"2023-05-08T15:15:46.818Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":"/img/5.8.jpg","text":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":13,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":12,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}