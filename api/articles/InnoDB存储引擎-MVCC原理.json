{"title":"InnoDB存储引擎_MVCC原理","uid":"12e6f0c825691db3e38970eadda0c57d","slug":"InnoDB存储引擎-MVCC原理","date":"2023-05-20T02:00:56.000Z","updated":"2023-05-20T09:10:10.924Z","comments":true,"path":"api/articles/InnoDB存储引擎-MVCC原理.json","keywords":null,"cover":[],"content":"<h2 id=\"InnoDB引擎\"><a href=\"#InnoDB引擎\" class=\"headerlink\" title=\"InnoDB引擎\"></a>InnoDB引擎</h2><h4 id=\"逻辑存储结构\"><a href=\"#逻辑存储结构\" class=\"headerlink\" title=\"逻辑存储结构\"></a><strong>逻辑存储结构</strong></h4><p>InnoDB的逻辑存储结构如下图所示:</p>\n<p><img src=\"/assets/images/logicalConstruct.png\"></p>\n<p> <strong>表空间</strong></p>\n<p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p>\n<p><strong>段</strong></p>\n<p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p>\n<p><strong>区</strong></p>\n<p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p>\n<p> <strong>页</strong></p>\n<p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>\n<p><strong>行</strong></p>\n<p>行，InnoDB 存储引擎数据是按行进行存放的。</p>\n<p>在行中，默认有两个隐藏字段：</p>\n<p>​\t\tTrx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p>\n<p>​\t\tRoll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a><strong>架构</strong></h4><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>\n<p><img src=\"/assets/images/%E6%9E%B6%E6%9E%841.png\"></p>\n<h5 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h5><p><img src=\"/assets/images/%E6%9E%B6%E6%9E%842.png\"></p>\n<p>主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 </p>\n<p> <strong>Buffer Pool</strong></p>\n<p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O</p>\n<p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等</p>\n<p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>\n<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p>\n<p>​\tfree page：空闲page，未被使用。</p>\n<p>​\tclean page：被使用page，数据没有被修改过。</p>\n<p>​\tdirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p>\n<p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：<code>show variables like  &#39;innodb_buffer_pool_size&#39;;</code></p>\n<p><strong>Change Buffer</strong></p>\n<p>Change Buffer，更改缓冲区（针对于非唯一的二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>\n<p>Change Buffer的意义是什么呢?</p>\n<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>\n<p> <strong>Adaptive Hash Index</strong></p>\n<p>参数： adaptive_hash_index</p>\n<p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的InnoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p>\n<p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p>\n<p> <strong>Log Buffer</strong></p>\n<p>innodb_log_buffer_size：缓冲区大小</p>\n<p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p>\n<p>​\t\t1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p>\n<p>​\t\t0: 每秒将日志写入并刷新到磁盘一次。</p>\n<p>​\t\t2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p>\n<p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p>\n<h5 id=\"磁盘结构\"><a href=\"#磁盘结构\" class=\"headerlink\" title=\"磁盘结构\"></a>磁盘结构</h5><p>InnoDB体系结构的磁盘结构：</p>\n<p><img src=\"/assets/images/%E6%9E%B6%E6%9E%843.png\"></p>\n<p> <strong>System Tablespace</strong></p>\n<p>参数：innodb_data_file_path</p>\n<p>系统表空间是一个特殊的InnoDB表空间，它是用来存储系统表和索引的地方。虽然你可以在其他表空间中创建表，在系统表空间中包含这些表和索引数据，允许InnoDB使用更少的内存和磁盘空间，因为系统表空间是被当做一个单独的文件处理。系统表空间，默认的文件名叫 ibdata1。</p>\n<p>当你使用InnoDB引擎时，系统表空间在存储InnoDB的缓存池中发挥着重要的作用。MySQL使用缓存机制来最小化对硬盘I&#x2F;O访问的次数，来提高InnoDB性能。系统表空间是其中之一，InnoDB会将读取的数据缓存到系统表空间中，并使用系统表空间将存储的数据进行共享，避免了不必要的副本。</p>\n<p>系统表空间是通过配置文件参数innodb_data_file_path来定义的。通常，系统表空间会被定义为一个更改缓冲区和一个UNDO日志空间的共同文件。在MySQL 5.x版本中，由于InnoDB存储一些特殊的元数据和事务信息，所以系统表空间还包含了InnoDB数据字典、undolog等，用来支持事务和锁等机制的实现。</p>\n<p><strong>File-Per-Table Tablespaces</strong></p>\n<p>开关参数：innodb_file_per_table ，该参数默认开启。</p>\n<p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。我们每创建一个表，都会产生一个表空间文件</p>\n<p> <strong>General Tablespaces</strong></p>\n<p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>\n<p>创建表空间</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLESPACE</span> ts_name <span class=\"token keyword\">ADD</span> DATAFILE <span class=\"token string\">'file_name'</span> <span class=\"token keyword\">ENGINE</span> <span class=\"token operator\">=</span> engine_name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 创建表时指定表空间</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> xxx <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">TABLESPACE</span> ts_name<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Undo Tablespaces</strong></p>\n<p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间初始大小16M，用于存储undo log日志</p>\n<p><strong>Temporary Tablespaces</strong></p>\n<p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>\n<p><strong>Doublewrite Buffer Files</strong></p>\n<p>双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>\n<p>涉及文件：#ib_16384_0.dblwr、#ib_16384_1.dblwr</p>\n<p><strong>Redo Log</strong></p>\n<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用</p>\n<p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0、iblogfile1</p>\n<h5 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h5><p><img src=\"/assets/images/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png\"></p>\n<p>在InnoDB的后台线程中，分为4类：</p>\n<p>Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread</p>\n<p> <strong>Master Thread</strong></p>\n<p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p>\n<p> <strong>IO Thread</strong></p>\n<p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p>\n<p>查看到InnoDB的状态信息，其中就包含IO Thread信息</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">engine</span> <span class=\"token keyword\">innodb</span> <span class=\"token keyword\">status</span> \\G<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th><strong>线程类型</strong></th>\n<th><strong>默认个数</strong></th>\n<th><strong>职责</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read thread</td>\n<td>4</td>\n<td>负责读操作</td>\n</tr>\n<tr>\n<td>Write thread</td>\n<td>4</td>\n<td>负责写操作</td>\n</tr>\n<tr>\n<td>Log thread</td>\n<td>1</td>\n<td>负责将日志缓冲区刷新到磁盘</td>\n</tr>\n<tr>\n<td>Insert buffer thread</td>\n<td>1</td>\n<td>负责将写缓冲区内容刷新到磁盘</td>\n</tr>\n</tbody></table>\n<p> <strong>Purge Thread</strong></p>\n<p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p>\n<p><strong>Page Cleaner Thread</strong></p>\n<p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>\n<h4 id=\"事务原理\"><a href=\"#事务原理\" class=\"headerlink\" title=\"事务原理\"></a>事务原理</h4><p>我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p>\n<p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的。</p>\n<p><img src=\"/assets/images/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.png\"></p>\n<p><strong>redo log</strong></p>\n<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>\n<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p>\n<p>如果没有redolog，可能会存在什么问题的？</p>\n<p><img src=\"/assets/images/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%861.png\"></p>\n<p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>\n<p>在InnoDB中提供了一份日志 redo log，接下来我们再来看看，通过redolog如何解决这个问题。</p>\n<p><img src=\"/assets/images/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%862.png\"></p>\n<p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。</p>\n<p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p>\n<p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）</p>\n<p><strong>undo log</strong></p>\n<p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) </p>\n<p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>\n<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p>\n<p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。</p>\n<h4 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h4><p>MVCC全称为Multi-Version Concurrency Control，即多版本并发控制。它是一种用于实现数据库事务的并发控制方式，主要应用于多用户、多事务同时执行的环境下，用来保证事务的隔离性和并发性。</p>\n<p>MVCC的主要思想是为每个数据库记录维护多个版本，每个版本都对应着不同的事务更新。这样，即使有多个事务并发执行，每个事务看到的都是一致性的数据，而不会发生脏读、不可重复读等问题。</p>\n<p><strong>当前读</strong></p>\n<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p>\n<p><img src=\"/assets/images/MVCC1.png\"></p>\n<p>即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p>\n<p> <strong>快照读</strong></p>\n<p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>\n<p>Read Committed：每次select，都生成一个快照读。</p>\n<p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p>\n<p>Serializable：快照读会退化为当前读。</p>\n<p>演示RR</p>\n<p><img src=\"/assets/images/MVCC2.png\"></p>\n<p>到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p>\n<p> <strong>MVCC</strong></p>\n<p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>\n<p><strong>隐藏字段</strong></p>\n<p>我们创建了一张表，在查看表结构的时候，就可以显式的看到这张表的字段。实际上除了显式字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是</p>\n<table>\n<thead>\n<tr>\n<th><strong>隐藏字段</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DB_TRX_ID</td>\n<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td>\n</tr>\n<tr>\n<td>DB_ROLL_PTR</td>\n<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td>\n</tr>\n<tr>\n<td>DB_ROW_ID</td>\n<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>\n</tr>\n</tbody></table>\n<p><strong>测试</strong></p>\n<p>查看有主键的表 stu</p>\n<p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;hj&#x2F; , 查看stu的表结构信息, 通过如下指令:</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ibd2sdi stu<span class=\"token punctuation\">.</span>ibd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>除了我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID隐藏字段</p>\n<p>查看没有主键的表 employee</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ibd2sdi employee<span class=\"token punctuation\">.</span>ibd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的</p>\n<p> <strong>版本链</strong></p>\n<p>有一张表原始数据为：</p>\n<p><img src=\"/assets/images/%E7%89%88%E6%9C%AC%E9%93%BE.png\"></p>\n<p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p>\n<p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p>\n<p>有四个并发事务同时在访问这张表</p>\n<p><img src=\"/assets/images/%E7%89%88%E6%9C%AC%E9%93%BE2.png\"></p>\n<p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>\n<p><img src=\"/assets/images/%E7%89%88%E6%9C%AC%E9%93%BE3.png\"></p>\n<p>紧接着事务三操作</p>\n<p><img src=\"/assets/images/%E7%89%88%E6%9C%AC%E9%93%BE4.png\"></p>\n<p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>\n<p><img src=\"/assets/images/%E7%89%88%E6%9C%AC%E9%93%BE5.png\"></p>\n<p>最终发现不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>\n<p><strong>readview</strong></p>\n<p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的未提交事务的id。在使用 MVCC 进行事务并发控制时，数据库需要维护一个 ReadView(读视图)，它是快照读在 SQL 执行过程中提取数据的依据。</p>\n<p>ReadView 记录着系统当前活跃的事务的 id。一个事务被视作“活跃”的条件是它已经启动，但尚未提交或回滚。也就是说，只有在提交或回滚时，事务才算结束，它的 id 才被从 ReadView 中移除。</p>\n<p>ReadView 中的事务 id 用来判断一个快照读的数据版本是否可见。当一个事务执行快照读时，它会读取 ReadView 的事务 id，用于确定事务开始前那一刻的数据版本。如果在它之前启动的活跃事务已经对数据进行了修改，那么这些修改的数据版本对该事务来说是不可见的，因为它的事务 id 在 ReadView 中。而读视图只会看到在它之前启动的事务的更新，它之后启动的事务的更新它是不可见的。</p>\n<p>因此，保持 ReadView 中的 id 维护了系统当前的并发状态，使得快照读能够在一致性的基础上提取数据，避免了不合适的结果。</p>\n<p>ReadView中包含了四个核心字段：</p>\n<table>\n<thead>\n<tr>\n<th><strong>字段</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids</td>\n<td>当前活跃的事务ID集合</td>\n</tr>\n<tr>\n<td>min_trx_id</td>\n<td>最小活跃事务ID</td>\n</tr>\n<tr>\n<td>max_trx_id</td>\n<td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>\n</tr>\n<tr>\n<td>creator_trx_id</td>\n<td>ReadView创建者的事务ID</td>\n</tr>\n</tbody></table>\n<p>而在readview中就规定了版本链数据的访问规则：</p>\n<p>​\ttrx_id 代表当前undo log版本链对应事务ID。</p>\n<table>\n<thead>\n<tr>\n<th><strong>条件</strong></th>\n<th><strong>是否可以访问</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>trx_id &#x3D;&#x3D; creator_trx_id</td>\n<td>可以访问该版本</td>\n<td>成立，说明数据是当前这个事务更改的。</td>\n</tr>\n<tr>\n<td>trx_id &lt; min_trx_id</td>\n<td>可以访问该版本</td>\n<td>成立，说明数据已经提交了。</td>\n</tr>\n<tr>\n<td>trx_id &gt; max_trx_id</td>\n<td>不可以访问该版本</td>\n<td>成立，说明该事务是在ReadView生成后才开启。</td>\n</tr>\n<tr>\n<td>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id</td>\n<td>如果trx_id不在m_ids中，是可以访问该版本的</td>\n<td>成立，说明数据已经提交。</td>\n</tr>\n</tbody></table>\n<p>不同的隔离级别，生成ReadView的时机不同：</p>\n<p>​\tREAD COMMITTED ：在事务中每一次执行快照读时生成ReadView。</p>\n<p>​\tREPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p>\n<p><strong>原理分析</strong></p>\n<p><strong>RC隔离级别</strong></p>\n<p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p>\n<p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p>\n<p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB.png\"></p>\n<p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undo log版本链中匹配数据，最终决定此次快照读返回的数据。</p>\n<p>先来看<strong>第一次快照读</strong>具体的读取过程：</p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB2.png\"></p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB3.png\"></p>\n<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>\n<p>先匹配 DB_TRX_ID &#x3D; 4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p>\n<p>再匹配第二条DB_TRX_ID &#x3D; 3，将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条</p>\n<p>再匹配第三条DB_TRX_ID &#x3D; 2，将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据</p>\n<p>再来看<strong>第二次快照读</strong>具体的读取过程:</p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB4.png\"></p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB5.png\"></p>\n<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>\n<p>先匹配 DB_TRX_ID &#x3D; 4，将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p>\n<p>再匹配DB_TRX_ID &#x3D; 3，将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</p>\n<p> <strong>RR隔离级别</strong></p>\n<p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>\n<p><img src=\"/assets/images/%E5%BF%AB%E7%85%A7%E8%AF%BB6.png\"></p>\n<p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的</p>\n<p>所以MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证</p>\n<p><img src=\"/assets/images/MVCC%E5%8E%9F%E7%90%86%E5%9B%BE.png\"></p>\n","feature":true,"text":"InnoDB引擎逻辑存储结构InnoDB的逻辑存储结构如下图所示: 表空间 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可...","link":"","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InnoDB%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">InnoDB引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">逻辑存储结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">内存结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">磁盘结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">后台线程</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">事务原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring MVC","uid":"84c6604e94d88eec227a0b74aad54f6e","slug":"Spring-MVC","date":"2023-05-20T12:40:51.000Z","updated":"2023-05-20T12:44:54.770Z","comments":true,"path":"api/articles/Spring-MVC.json","keywords":null,"cover":null,"text":"Spring MVCWebMvcConfigurerWebMvcConfigurer是一个Spring MVC的配置接口，它提供了一些方法来进行各种配置。WebConfig类实现了这个接口，因此可以利用这些方法来配置应用程序。例如：addInterceptors()：用于添加拦截...","link":"","photos":[],"count_time":{"symbolsCount":370,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":10,"path":"api/tags/Spring.json"},{"name":"Spring MVC","slug":"Spring-MVC","count":1,"path":"api/tags/Spring-MVC.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"MySQL_锁","uid":"083e3a4ebfcb19d327b53b7d73aaddd3","slug":"MySQL-锁","date":"2023-05-19T01:39:57.000Z","updated":"2023-05-19T15:44:11.108Z","comments":true,"path":"api/articles/MySQL-锁.json","keywords":null,"cover":[],"text":"锁​ 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":9,"path":"api/tags/MySQL.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true}}