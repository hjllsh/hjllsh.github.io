{"title":"线程池","uid":"d1863bbf8aa3ec7bc32e4a0f3476163f","slug":"线程池","date":"2023-06-07T11:42:20.000Z","updated":"2023-06-07T13:31:41.753Z","comments":true,"path":"api/articles/线程池.json","keywords":null,"cover":[],"content":"<h1 id=\"Executor线程池\"><a href=\"#Executor线程池\" class=\"headerlink\" title=\"Executor线程池\"></a>Executor线程池</h1><p>在Java框架设计中，一般涉及到资源相关的，并且资源具有创建消耗大、可复用的特点时，都采用了池化技术管理资源，形成一个“资源池”，池化技术可以带来以下一般性好处：对外部隐藏了资源的创建与释放的细节、实现资源的复用减少内存或者时间性能开销。常见Java中池化技术有：数据库连接池（管理数据库连接资源）、、redis连接池（管理redis连接）等等</p>\n<h5 id=\"Executor线程池来自于JDK1-5的JUC包，使用线程池的目的或者好处如下：\"><a href=\"#Executor线程池来自于JDK1-5的JUC包，使用线程池的目的或者好处如下：\" class=\"headerlink\" title=\"Executor线程池来自于JDK1.5的JUC包，使用线程池的目的或者好处如下：\"></a>Executor线程池来自于JDK1.5的JUC包，使用线程池的目的或者好处如下：</h5><ul>\n<li>实现线程资源的合理复用。线程资源属于操作系统核心资源之一，创建和销毁都需要占用系统资源和大量时间。使用线程池之后，不再需要开发者管理线程，线程的创建和销毁都交给线程池控制，实现线程的复用，减少线程资源的频繁的创建和销毁。</li>\n<li>提升任务执行效率。当新来一个线程任务的时候，由于具有线程复用计数因此可以直接利用现有的线程去执行任务，不需要新建线程，这样一定程度上提升了执行效率。</li>\n<li>可以对线程和线程任务实现实时监控和管理。比如目前活动线程数、曾经的最大线程数、已完成的任务数量等功能；比如控制最大线程数，在线程任务执行前-执行完毕后-线程池停止后具有可选的回调方法、移除某个线程任务、立即停止线程池等功能，他们都可以通过线程池的相关方法调用来实现。</li>\n</ul>\n<h3 id=\"Executor线程池的基本结构\"><a href=\"#Executor线程池的基本结构\" class=\"headerlink\" title=\"Executor线程池的基本结构\"></a>Executor线程池的基本结构</h3><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A001.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>线程池的核心接口以及实现类：</strong></p>\n<p><strong>Executor</strong><br>        作为线程池的顶级执行接口，也是一个函数式接口。只有一个execute方法，用于执行已提交的 Runnable 任务对象。<br>        它不仅仅是一个接口，更是代表着一种将任务与每个任务将如何运行的机制（包括线程的创建、使用、调度等）分离开来的思想。使用者只需要提交任务，不需要创建线程，执行的细节被封装到Executor中，任务的执行方法可以根据实现者自由选择，可以实现为异步（使用新线程执行任务）、也可以是同步的（在调用者的线程中立即运行已提交的任务）。<br><strong>ExecutorService</strong><br>        继承并扩展了Executor接口的执行服务接口。<br>        新增了可为跟踪一个或多个异步任务执行状况而生成 Future 的方法，比如submit方法，作为execute方法的扩展。新增了可以关闭线程池的方法，比如shutdown和shutdownNow方法。新增了批量执行任务的方法，比如 invokeAny 和 invokeAll方法。<br><strong>AbstractExecutorService</strong><br>        实现了ExecutorService的抽象类，提供 ExecutorService 执行方法的默认实现。比如对ExecutorService返回Future，实现为返回RunnableFuture。另一个作用是作为骨干实现最大限度地减少ExecutorService的实现类的代码。<br><strong>ThreadPoolExecutor</strong><br>        继承了ExecutorService的普通类，这是JDK线程池的核心实现。<br>        它的构造器提供了各种可配置参数，比如线程数量、任务队列、拒绝策略等，方便我们自定义自己的线程池，以及各种钩子 (hook) 方法，方便追踪线程任务的执行，这是我们学习的重点，这里不做详细介绍。<br><strong>ScheduledThreadPoolExecutor</strong><br>        继承了ThreadPoolExecutor的普通类，可以看作功能的扩展或增强。<br>        它能够将线程任务延迟指定时间后执行，或者间隔固定时间多次执行。功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。Timer中一个任务出现异常之后会影响其他任务的执行，但是ScheduledThreadPoolExecutor不会。Timer中一个任务耗时较常会影响其他任务的执行，ScheduledThreadPoolExecutor不会。<br><strong>Executors</strong><br>        独立出来的一个普通类（没有继承和实现关系，采用组合&#x2F;聚合关系，图上没有注明），作为一个线程池工厂，提供各种实用方法。<br>        提供了各种预定义线程池的实现，比如CachedThreadPool、FixedThreadPool等；提供了将Runnable包装、转换为Callable的方法；提供默认的ThreadFactory线程工厂的实现等功能。</p>\n<h4 id=\"JDK内部提供了Executors这个工具类，来快速的创建线程池。\"><a href=\"#JDK内部提供了Executors这个工具类，来快速的创建线程池。\" class=\"headerlink\" title=\"JDK内部提供了Executors这个工具类，来快速的创建线程池。\"></a>JDK内部提供了Executors这个工具类，来快速的创建线程池。</h4><h5 id=\"固定线程数量的线程池：核心线程数与最大线程数相等\"><a href=\"#固定线程数量的线程池：核心线程数与最大线程数相等\" class=\"headerlink\" title=\"固定线程数量的线程池：核心线程数与最大线程数相等\"></a>固定线程数量的线程池：核心线程数与最大线程数相等</h5><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A002.png\" alt=\"img\"></p>\n<h5 id=\"单个线程数量的线程池\"><a href=\"#单个线程数量的线程池\" class=\"headerlink\" title=\"单个线程数量的线程池\"></a>单个线程数量的线程池</h5><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A003.png\" alt=\"img\"></p>\n<h5 id=\"接近无限大线程数量的线程池\"><a href=\"#接近无限大线程数量的线程池\" class=\"headerlink\" title=\"接近无限大线程数量的线程池\"></a>接近无限大线程数量的线程池</h5><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A004.png\" alt=\"img\"></p>\n<h5 id=\"带定时调度功能的线程池\"><a href=\"#带定时调度功能的线程池\" class=\"headerlink\" title=\"带定时调度功能的线程池\"></a>带定时调度功能的线程池</h5><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A005.png\" alt=\"img\"></p>\n<p>虽然JDK提供了快速创建线程池的方法，但是其实不推荐使用Executors来创建线程池，因为从上面构造线程池可以看出，newFixedThreadPool线程池，由于使用了LinkedBlockingQueue，队列的容量默认是无限大，实际使用中出现任务过多时会导致内存溢出；newCachedThreadPool线程池由于核心线程数无限大，当任务过多的时候，会导致创建大量的线程，可能机器负载过高，可能会导致服务宕机。</p>\n<h2 id=\"ThreadPoolExecutor的概述\"><a href=\"#ThreadPoolExecutor的概述\" class=\"headerlink\" title=\"ThreadPoolExecutor的概述\"></a>ThreadPoolExecutor的概述</h2><p>JDK线程池的关键实现，我们常用的Executors中的预定义线程池就有这个类的实例，当然也可以通过该类的构造器来创建一个自定义的线程池，提供任务执行，线程调度，线程池管理等等服务</p>\n<p><strong>ThreadPoolExecutor的类层次结构</strong></p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A006.png\" alt=\"在这里插入图片描述\"></p>\n<p>CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy是四个拒绝策略类。对于正在执行的线程数大于等于maxmumPoolSize以及workQueue容量已满时提交的任务，或者线程池正在关闭时的新提交的任务，线程池将会执行拒绝策略，任务会交给RejectedExecutionHandler来处理。</p>\n<h3 id=\"ThreadPoolExecutor的主要属性\"><a href=\"#ThreadPoolExecutor的主要属性\" class=\"headerlink\" title=\"ThreadPoolExecutor的主要属性\"></a>ThreadPoolExecutor的主要属性</h3><p>使用一个<strong>ctl</strong>原子变量来来同时记录线程池的运行状态(runState，简称rs)和线程池中线程数量(workerCount，简称wc)。int类型转换为二进制之后的最高三位保存线程池的状态，低29位保存线程数量。刚初始化ctl的时候，rs为RUNNING状态，wc为0。</p>\n<p>还有一个ReentrantLock独占锁，当改变线程池状态，比如添加工作线程、停止线程池，或者访问线程池共享参数信息比如当前线程数量的时候，因为这涉及到多个工作线程之间的共享信息比如线程池状态、工作线程数量等参数的同步，需要获取mainLock独占锁才能进行操作。</p>\n<p>部分源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 用来同时记录线程池的运行状态(runState，简称rs)和线程池中线程数量(workerCount，简称wc)。\n \tctl的值使用AtomicInteger原子类包装，能够保证数据是线程安全的。\n * int类型转换为二进制之后的最高三位保存线程池的状态，低29位保存线程数量。\n \t刚初始化ctl的时候，rs为RUNNING状态，wc为0\n * ReentrantReadWriteLock也是使用一个state变量保存写锁和读锁的获取信息，\n \tConcurrentHashMap中的甚至使用一个lockState保存三种锁状态\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">AtomicInteger</span> ctl <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token function\">ctlOf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">RUNNING</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 线程数量掩码位数，int类型长度－3后的剩余位数，即wc所占位数为29\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">COUNT_BITS</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SIZE</span> <span class=\"token operator\">-</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * 为了能正确保存线程数量，线程池的数量线程被限制为29位的最大值，即最大(2^29）-1个，而不是(2^31)-1个\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">CAPACITY</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">//ThreadPoolExecutor中定义了线程池的状态，存储在ctl的高三位中，一共有五种</span>\n\n<span class=\"token comment\">/**\n * RUNNING状态，11100000000000000000000000000000\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">RUNNING</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * SHUTDOWN状态：00000000000000000000000000000000\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">SHUTDOWN</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * STOP状态：00100000000000000000000000000000\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">STOP</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * TIDYING状态：01000000000000000000000000000000\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">TIDYING</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n * TERMINATED状态：01100000000000000000000000000000\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">TERMINATED</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">COUNT_BITS</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//通过对ctl的拆解、组合，获取相关的数据</span>\n<span class=\"token comment\">/**\n * 获取ctl的高3位，线程池运行状态\n *\n * @param c 此时的ctl值\n * @return ctl的高3位的int值\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//将c的低29位置为0并返回结果</span>\n    <span class=\"token keyword\">return</span> c <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span><span class=\"token constant\">CAPACITY</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 获取ctl的低29位，线程数量\n *\n * @param c 此时的ctl值\n * @return ctl的低29位的int值\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//将c的高3位置为0并返回结果</span>\n    <span class=\"token keyword\">return</span> c <span class=\"token operator\">&amp;</span> <span class=\"token constant\">CAPACITY</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 组合rs和wc，计算ctl新值\n *\n * @param rs 运行状态\n * @param wc 线程数量\n * @return 新ctl的int值\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">ctlOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> rs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> wc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//两者与运算</span>\n    <span class=\"token keyword\">return</span> rs <span class=\"token operator\">|</span> wc<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 线程任务队列，是一个阻塞队列\n * 使用isEmpty来检测队列是否为空，而不是通过poll的返回值\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 当改变线程池状态，比如添加工作线程、停止线程池，或者访问线程池共享参数信息比如当前线程数量的时候\n * 因为这涉及到多个线程之间的共享信息比如线程池状态、工作线程数量等参数的同步，需要获取mainLock独占锁才行\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> mainLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 包含全部工作线程的set集合\n * 只有在持有mainLock锁的时候才能访问\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Worker</span><span class=\"token punctuation\">></span></span> workers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Worker</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 主要是为了支持awaitTermination方法，外部线程调用awaitTermination方法之后\n * 会判断线程池是否是TERMINATED状态，即终止状态，如果不是则调用线程在termination条件变量中等待，直到超时或者线程完毕\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Condition</span> termination <span class=\"token operator\">=</span> mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 记录到目前为止线程池中的拥有的最大线程数量\n * 只有在持有mainLock锁的时候才能访问\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> largestPoolSize<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 线程池已完成的任务数量，只有在某个Worker工作线程终止时才会更新\n * 只有在持有mainLock锁的时候才能访问\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> completedTaskCount<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">/**\n * ThreadPoolExecutor中的工作线程统一使用线程工厂来创建\n * threadFactory用于保存传入的线程工厂实现，具有volatile的特性\n * Executors中给出了默认实现，我们可以直接使用：Executors.defaultThreadFactory()\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 对于提交任务数超过maxmumPoolSize+workQueue之和时超出的任务，或者线程池正在关闭时的新提交的任务执行的拒绝策略，\n * 任务会交给RejectedExecutionHandler的handler来处理，具有volatile的特性\n * ThreadPoolExecutor中提供了默认实现：AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 空闲的工作线程的等待超时时间，具有volatile的特性\n * 当存在的工作线程数量大于指定核心线程数量时，那么多余的线程会使用此超时时间，超过该时间没有工作则关闭线程\n * 或者如果允许CoreThreadTimeOut，那核心线程也会使用此超时时间，超过该时间没有任务则关闭线程；否则，核心将永远等待新的任务。\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 是否允许核心线程应用空闲超时时间，具有volatile的特性\n * 如果为false，那么即使核心线程空闲也会永远保持活动状态（不会被销毁）\n * 如果为true，那么核心线程将会应用 keepAliveTime，在指定时间内等待工作，超时则被销毁（设置成功的要求是超时时间大于0）。\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span> allowCoreThreadTimeOut<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 线程池核心线程数量，具有volatile的特性\n * 除非设置了allowCoreThreadTimeOut=true，那么核心线程永远不会被销毁\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 线程池最大线程数量，具有volatile的特性\n * 不能超过(2^29）-1\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">//下面的属性涉及到Java安全模型：https://developer.ibm.com/zh/articles/j-lo-javasecurity/</span>\n<span class=\"token comment\">//一般人接触不到</span>\n<span class=\"token comment\">/**\n * 用于校验是否具有shutdown 和 shutdownNow 关闭线程池的操作权限\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">RuntimePermission</span> shutdownPerm <span class=\"token operator\">=</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimePermission</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"modifyThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 授权上下文环境对象\n * 在GC标记ThreadPoolExecutor对象并调用finalize方法时调用，用于释放资源\n */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">AccessControlContext</span> acc<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"线程池的状态\"><a href=\"#线程池的状态\" class=\"headerlink\" title=\"线程池的状态\"></a>线程池的状态</h3><p>线程池有5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。</p>\n<p>RUNNING &#x3D; -1 &lt;&lt; COUNT_BITS，转换为二进制就是11100000000000000000000000000000<br>SHUTDOWN &#x3D; 0 &lt;&lt; COUNT_BITS，转换为二进制就是00000000000000000000000000000000<br>STOP &#x3D; 1 &lt;&lt; COUNT_BITS，转换为二进制就是00100000000000000000000000000000<br>TIDYING &#x3D; 2 &lt;&lt; COUNT_BITS，转换为二进制就是01000000000000000000000000000000<br>TERMINATED &#x3D; 3 &lt;&lt; COUNT_BITS，转换为二进制就是01100000000000000000000000000000</p>\n<p>可以发现，运行状态的大小关系为：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，这在状态转换的时候非常有用，这样可以通过大小判断状态关系。</p>\n<p>类似于线程的状态，线程池的状态也可以转换。但是又有不同，线程状态可以循环转换、相互转换，而一旦发生线程池的状态的转换，那么该转换不可逆。下面来看看线程池状态的转换规则：</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A007.png\" alt=\"在这里插入图片描述\"></p>\n<p>详细说明：</p>\n<table>\n<thead>\n<tr>\n<th>状态名</th>\n<th>说明</th>\n<th>转换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RUNNING</td>\n<td>线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。</td>\n<td>新建的线程池的初始状态就是RUNNING，并且线程池中的工作线程数量为0。</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>线程池处在SHUTDOWN状态时，不接收新任务，但内部正在执行的任务和队列里等待的任务，会执行完，随后会清理全部工作线程。</td>\n<td>RUNNING状态的线程池，调用shutdown方法，或者隐式调用了finalize方法（里面有shutdown方法时线程池状态将变成SHUTDOWN。</td>\n</tr>\n<tr>\n<td>STOP</td>\n<td>线程池处在STOP状态时，不接收新任务，不处理已添加的任务（丢弃），并且会中断正在处理的任务，随后会清理全部工作线程。</td>\n<td>RUNNING or SHUTDOWN状态的线程池，调用shutdownNow方法，线程池状态将变成 STOP。</td>\n</tr>\n<tr>\n<td>TIDYING</td>\n<td>所有的任务已执行完或被终止或被丢弃，ctl记录的workerCount工作线程数量为0，线程池会变为TIDYING状态。接着会执行钩子函数terminated()。</td>\n<td>SHUTDOWN状态的线程池，当任务队列为空并且线程池工作线程数workerCount为0时，线程池状态就会由 SHUTDOWN 自动转换为 TIDYING状态。   STOP状态的线程池，线程池中工作线程数workerCount为0时，线程池状态就会由STOP自动转换为TIDYING状态。</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>钩子函数terminated()执行完毕，就变成TERMINATED状态，线程池彻底终止。</td>\n<td>TIDYING状态的线程池，在接着执行完terminated()之后，线程池状态就会由TIDYING自动转换为 TERMINATED。</td>\n</tr>\n</tbody></table>\n<h3 id=\"ThreadPoolExecutor的构造器\"><a href=\"#ThreadPoolExecutor的构造器\" class=\"headerlink\" title=\"ThreadPoolExecutor的构造器\"></a>ThreadPoolExecutor的构造器</h3><p>ThreadPoolExecutor的构造器是创建线程池的入口，JDK提供了四个构造函数。其中参数较少的的三个构造函数内部都是调用参数最多的那一个构造函数。\t\t</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 使用给定的初始参数和默认的线程工厂及默认的拒绝策略创建新的 ThreadPoolExecutor。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//内部调用最多参数的构造器</span>\n    <span class=\"token comment\">//线程工厂传递的Executors的默认实现：Executors.defaultThreadFactory()</span>\n    <span class=\"token comment\">//拒绝策略传递的默认实现：defaultHandler</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> maximumPoolSize<span class=\"token punctuation\">,</span> keepAliveTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> workQueue<span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">defaultThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> defaultHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 使用给定的初始参数和默认的拒绝策略创建新的 ThreadPoolExecutor。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//内部调用最多参数的构造器</span>\n    <span class=\"token comment\">//拒绝策略传递的默认实现：defaultHandler</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> maximumPoolSize<span class=\"token punctuation\">,</span> keepAliveTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> workQueue<span class=\"token punctuation\">,</span>\n            threadFactory<span class=\"token punctuation\">,</span> defaultHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n * 使用给定的初始参数和默认的线程工厂创建新的 ThreadPoolExecutor。\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//内部调用最多参数的构造器</span>\n    <span class=\"token comment\">//线程工厂传递的Executors的默认实现：Executors.defaultThreadFactory()</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> maximumPoolSize<span class=\"token punctuation\">,</span> keepAliveTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> workQueue<span class=\"token punctuation\">,</span>\n            <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">defaultThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/**\n 1. 使用给定的初始参数创建新的 ThreadPoolExecutor,一共有7个参数。\n 2.  3. @param corePoolSize    核心线程数\n 3. @param maximumPoolSize 最大线程数\n 4. @param keepAliveTime   空闲线程等待超时时间\n 5. @param unit            超时时间单位\n 6. @param workQueue       阻塞任务队列\n 7. @param threadFactory   线程工厂\n 8. @param handler         拒绝策略\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">,</span>\n                          <span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//一系列参数校验</span>\n    <span class=\"token comment\">/*\n     * 如果核心线程数小于0\n     * 或者 如果最大线程数小于等于0\n     * 或者 如果最大线程数小于核心线程数\n     * 或者 如果空闲线程等待超时时间小于0\n     *\n     * 满足上面一项，都将抛出IllegalArgumentException异常\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>corePoolSize <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span>\n            maximumPoolSize <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span>\n            maximumPoolSize <span class=\"token operator\">&lt;</span> corePoolSize <span class=\"token operator\">||</span>\n            keepAliveTime <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*\n     * 如果阻塞任务队列为null\n     * 或者 如果线程工厂为null\n     * 或者 如果拒绝策略为null\n     *\n     * 满足上面一项，都将抛出NullPointerException异常\n     */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workQueue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> threadFactory <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> handler <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化用于安全管理器的上下文参数</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>acc <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSecurityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span>\n            <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span>\n            <span class=\"token class-name\">AccessController</span><span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化核心线程数</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>corePoolSize <span class=\"token operator\">=</span> corePoolSize<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化最大线程数</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>maximumPoolSize <span class=\"token operator\">=</span> maximumPoolSize<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化阻塞任务队列</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>workQueue <span class=\"token operator\">=</span> workQueue<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化空闲线程等待超时时间</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>keepAliveTime <span class=\"token operator\">=</span> unit<span class=\"token punctuation\">.</span><span class=\"token function\">toNanos</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化线程工厂</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threadFactory <span class=\"token operator\">=</span> threadFactory<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//初始化拒绝策略</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"corePoolSize：线程池核心线程数。不能小于0。\"><a href=\"#corePoolSize：线程池核心线程数。不能小于0。\" class=\"headerlink\" title=\"corePoolSize：线程池核心线程数。不能小于0。\"></a>corePoolSize：线程池核心线程数。不能小于0。</h5><p>当提交一个任务到线程池时，如果此时线程池的线程数量小于核心线程数，那么线程池会新创建一个线程来执行任务，即使此时存在空闲线程也不例外。默认情况创建0个核心线程，如果调用了线程池的prestartAllCoreThreads()方法，线程池会立即创建并启动所有核心线程。</p>\n<h5 id=\"maximumPoolSize：线程池最大线程数。不能小于corePoolSize，不能小于等于0。\"><a href=\"#maximumPoolSize：线程池最大线程数。不能小于corePoolSize，不能小于等于0。\" class=\"headerlink\" title=\"maximumPoolSize：线程池最大线程数。不能小于corePoolSize，不能小于等于0。\"></a>maximumPoolSize：线程池最大线程数。不能小于corePoolSize，不能小于等于0。</h5><p>当workQueue（任务队列）放不下线程任务，并且已创建的线程数小于最大线程数，则线程池会再次创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列（任务队列没有上限大小）这个参数就没什么效果。</p>\n<h5 id=\"keepAliveTime：空闲线程等待超时时间；unit：keepAliveTime时间单位\"><a href=\"#keepAliveTime：空闲线程等待超时时间；unit：keepAliveTime时间单位\" class=\"headerlink\" title=\"keepAliveTime：空闲线程等待超时时间；unit：keepAliveTime时间单位\"></a>keepAliveTime：空闲线程等待超时时间；unit：keepAliveTime时间单位</h5><p>当线程数量超过corePoolSize时，多余的空闲线程等待超时时间，即如果指定时间返回没有任务执行，那么该线程将被回收，直到数量减少到corePoolSize为止。<br>如果允许CoreThreadTimeOut（前提是keepAliveTime大于0），那核心线程也会使用此超时时间，超过该时间没有任务则关闭线程；否则，核心线程将永远等待新的任务。</p>\n<h5 id=\"workQueue：阻塞任务队列。\"><a href=\"#workQueue：阻塞任务队列。\" class=\"headerlink\" title=\"workQueue：阻塞任务队列。\"></a>workQueue：阻塞任务队列。</h5><p>当线程任务添加的速度超过所有核心线程执行速度时，新来的来不及执行的线程任务将被存放到workQueue阻塞任务队列中。<br>任务队列一定是阻塞队列，常见的有以下四种，实际上有很多种：<br>ArrayBlockingQueue：有界阻塞任务队列，构造函数一定要传入具体队列容量。<br>LinkedBlockingQueu：通常作为无界阻塞任务队列（构造函数不传大小会默认为Integer.MAX_VALUE ），当有大量任务提交时，容易造成内存耗尽。<br>SynchronousQueue：一个没有容量的阻塞队列，会将任务同步交付给工作线程。<br>PriorityBlockingQueue : 具有优先级的无界阻塞任务队列。</p>\n<h5 id=\"threadFactor：线程工厂\"><a href=\"#threadFactor：线程工厂\" class=\"headerlink\" title=\"threadFactor：线程工厂\"></a>threadFactor：线程工厂</h5><p>线程工厂用于创建工作线程，默认线程工厂：Executors.defaultThreadFactory。</p>\n<h5 id=\"handler：拒绝策略。\"><a href=\"#handler：拒绝策略。\" class=\"headerlink\" title=\"handler：拒绝策略。\"></a>handler：拒绝策略。</h5><p>对于正在执行的线程数等于maxmumPoolSize以及workQueue容量已满时提交的任务，或者线程池正在关闭时的新提交的任务，线程池将会执行拒绝策略，即这些任务都直接被非线程池线程处理了。<br>ThreadPoolExecutor中提供了4种拒绝策略的实现：</p>\n<ul>\n<li>AbortPolicy：调用者的线程直接抛出异常，作为默认拒绝策略；</li>\n<li>CallerRunsPolicy：用调用者的线程执行任务；</li>\n<li>DiscardOldestPolicy：抛弃队列中最久的任务；</li>\n<li>DiscardPolicy：抛弃当前任务；</li>\n</ul>\n<h3 id=\"线程池的运行原理\"><a href=\"#线程池的运行原理\" class=\"headerlink\" title=\"线程池的运行原理\"></a>线程池的运行原理</h3><p>线程池刚创建出来是什么样子呢，如下图</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A008.png\" alt=\"img\"></p>\n<p>不错，刚创建出来的线程池中只有一个构造时传入的阻塞队列而已，此时里面并没有的任何线程，但是如果你想要在执行之前已经创建好核心线程数，可以调用prestartAllCoreThreads方法来实现，默认是没有线程的。</p>\n<p>当有线程通过execute方法提交了一个任务，会发生什么呢？</p>\n<p>提交任务的时候，其实会去进行任务的处理</p>\n<p>首先会去判断当前线程池的线程数是否小于核心线程数，也就是线程池构造时传入的参数corePoolSize。</p>\n<p>如果小于，那么就直接通过ThreadFactory创建一个线程来执行这个任务，如图</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A009.png\" alt=\"img\"></p>\n<p>当任务执行完之后，线程不会退出，而是会去从阻塞队列中获取任务，如下图</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A010.png\" alt=\"img\"></p>\n<p>接下来如果又提交了一个任务，也会按照上述的步骤，去判断是否小于核心线程数，如果小于，还是会创建线程来执行任务，执行完之后也会从阻塞队列中获取任务。这里有个细节，就是提交任务的时候，就算有线程池里的线程从阻塞队列中获取不到任务，如果线程池里的线程数还是小于核心线程数，那么依然会继续创建线程，而不是复用已有的线程。</p>\n<p>如果线程池里的线程数不再小于核心线程数呢？那么此时就会尝试将任务放入阻塞队列中，入队成功之后，如图</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A011.png\" alt=\"img\"></p>\n<p>这样在阻塞的线程就可以获取到任务了。</p>\n<p>但是，随着任务越来越多，队列已经满了，任务放入失败了，那怎么办呢？</p>\n<p>此时就会判断当前线程池里的线程数是否小于最大线程数，也就是入参时的maximumPoolSize参数</p>\n<p>如果小于最大线程数，那么也会创建非核心线程来执行提交的任务，如图</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A012.png\" alt=\"img\"></p>\n<p>所以，从这里可以发现，就算队列中有任务，新创建的线程还是优先处理这个提交的任务，而不是从队列中获取已有的任务执行，从这可以看出，先提交的任务不一定先执行。</p>\n<p>但是不幸的事发生了，线程数已经达到了最大线程数量，那么此时会怎么办呢？</p>\n<p>此时就会执行拒绝策略，也就是构造线程池的时候，传入的RejectedExecutionHandler对象，来处理这个任务。</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A013.png\" alt=\"img\"></p>\n<h4 id=\"看看execute方法代码是如何实现的\"><a href=\"#看看execute方法代码是如何实现的\" class=\"headerlink\" title=\"看看execute方法代码是如何实现的\"></a>看看execute方法代码是如何实现的</h4><p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A014.png\" alt=\"img\"></p>\n<p>workerCountOf(c)&lt;corePoolSize:这行代码就是判断是否小于核心线程数，是的话就通过addWorker方法，addWorker就是添加线程来执行任务</p>\n<p>workQueue.offer(command)：这行代码就表示尝试往阻塞队列中添加任务</p>\n<p>添加失败之后就会再次调用addWorker方法尝试添加非核心线程来执行任务</p>\n<p>如果还是添加非核心线程失败了，那么就会调用reject(command)来拒绝这个任务。</p>\n<h4 id=\"ctl相关方法\"><a href=\"#ctl相关方法\" class=\"headerlink\" title=\"ctl相关方法\"></a>ctl相关方法</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>runStateOf(int c)：获取ctl的高3位，即获取线程池运行状态值；<br>workerCountOf(int c)：获取ctl的低29位，即获取线程数量值；<br>ctlOf(int rs, int wc)：组合rs和wc，计算ctl新值；<br>runStateLessThan(int c, int s)：c的运行状态值是否小于指定状态值s；<br>runStateAtLeast(int c, int s)：c的运行状态值是否大于等于指定状态值s；<br>isRunning(int c)：c 的运行状态是否是RUNNING；<br>compareAndIncrementWorkerCount(int expect)：尝试CAS的将ctl的WorkerCount线程数量部分自增1；<br>compareAndDecrementWorkerCount(int expect)：尝试CAS的将ctl的WorkerCount线程数量部分自减1；<br>decrementWorkerCount()：循环尝试CAS的将ctl的WorkerCount线程数量部分自减1，直到成功为止。只有在addWorkerFailed、processWorkerExit以及getTask方法中调用。</p></blockquote>\n<h3 id=\"线程池中线程实现复用的原理\"><a href=\"#线程池中线程实现复用的原理\" class=\"headerlink\" title=\"线程池中线程实现复用的原理\"></a>线程池中线程实现复用的原理</h3><p>线程在线程池内部其实是被封装成一个Worker对象</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A015.png\" alt=\"img\"></p>\n<p>Worker继承了AQS，也就是有一定锁的特性。</p>\n<p>创建线程来执行任务的方法上面提到是通过addWorker方法创建的。在创建Worker对象的时候，会把线程和任务一起封装到Worker内部，然后调用runWorker方法来让线程执行任务，接下来我们就来看一下runWorker方法。</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A016.png\" alt=\"img\"></p>\n<p>从这张图可以看出线程执行完任务不会退出的原因，runWorker内部使用了while死循环，当第一个任务执行完之后，会不断地通过getTask方法获取任务，只要能获取到任务，就会调用run方法，继续执行任务，这就是线程能够复用的主要原因。</p>\n<p>但是如果从getTask获取不到方法的时候，最后就会调用finally中的processWorkerExit方法，来将线程退出。</p>\n<p>这里有个一个细节就是，因为Worker继承了AQS，每次在执行任务之前都会调用Worker的lock方法，执行完任务之后，会调用unlock方法，这样做的目的就可以通过Woker的加锁状态就能判断出当前线程是否正在运行任务。如果想知道线程是否正在运行任务，只需要调用Woker的tryLock方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用shutdown方法关闭线程池的时候，就用这种方式来判断线程有没有在执行任务，如果没有的话，来尝试打断没有执行任务的线程。</p>\n<h2 id=\"线程是如何获取任务的以及如何实现超时的\"><a href=\"#线程是如何获取任务的以及如何实现超时的\" class=\"headerlink\" title=\"线程是如何获取任务的以及如何实现超时的\"></a>线程是如何获取任务的以及如何实现超时的</h2><p>线程在执行完任务之后，会继续从getTask方法中获取任务，获取不到就会退出。接下来我们就来看一看getTask方法的实现。</p>\n<p><img src=\"/../assets/executorPool/%E7%BA%BF%E7%A8%8B%E6%B1%A017.png\" alt=\"img\"></p>\n<p>getTask方法这里有一行代码</p>\n<p><code>boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</code></p>\n<p>这行代码是判断，当前过来获取任务的线程是否可以超时退出。如果allowCoreThreadTimeOut设置为true或者线程池当前的线程数大于核心线程数，也就是corePoolSize，那么该获取任务的线程就可以超时退出。</p>\n<p>那是怎么做到超时退出呢，就是这行核心代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Runnable</span> r <span class=\"token operator\">=</span> timed <span class=\"token operator\">?</span>\n    workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">NANOSECONDS</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n    workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>会根据是否允许超时来选择调用阻塞队列workQueue的poll方法或者take方法。如果允许超时，则会调用poll方法，传入keepAliveTime，也就是构造线程池时传入的空闲时间，这个方法的意思就是从队列中阻塞keepAliveTime时间来获取任务，获取不到就会返回null；如果不允许超时，就会调用take方法，这个方法会一直阻塞获取任务，直到从队列中获取到任务位置。从这里可以看到keepAliveTime是如何使用的了。</p>\n<p>程池中的线程可以做到空闲一定时间就退出，利用了阻塞队列的poll方法的实现，这个方法可以指定超时时间，一旦线程达到了keepAliveTime还没有获取到任务，那么就会返回null。</p>\n<p>如果将allowCoreThreadTimeOut设置为true，那么所有线程走到这个timed都是true，那么所有的线程，包括核心线程都可以做到超时退出。如果你的线程池需要将核心线程超时退出，那么可以通过allowCoreThreadTimeOut方法将allowCoreThreadTimeOut变量设置为true。</p>\n<h3 id=\"实际项目中如何合理的自定义线程池\"><a href=\"#实际项目中如何合理的自定义线程池\" class=\"headerlink\" title=\"实际项目中如何合理的自定义线程池\"></a>实际项目中如何合理的自定义线程池</h3><p>通过上面分析提到，通过Executors这个工具类来创建的线程池其实都无法满足实际的使用场景，那么在实际的项目中，到底该如何构造线程池呢，该如何合理的设置参数？</p>\n<h4 id=\"线程数\"><a href=\"#线程数\" class=\"headerlink\" title=\"线程数\"></a>线程数</h4><p>线程数的设置主要取决于业务是IO密集型还是CPU密集型。</p>\n<p>CPU密集型指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为CPU核心数+1。</p>\n<p>IO密集型：当执行任务需要大量的io，比如磁盘io，网络io，可能会存在大量的阻塞，所以在IO密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU核心数</p>\n<p>java中用来获取CPU核心数的方法是：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Runtime</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuntime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">availableProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"线程工厂\"><a href=\"#线程工厂\" class=\"headerlink\" title=\"线程工厂\"></a>线程工厂</h4><p>一般建议自定义线程工厂，构建线程的时候设置线程的名称，这样就在查日志的时候就方便知道是哪个线程执行的代码。</p>\n<h4 id=\"有界队列\"><a href=\"#有界队列\" class=\"headerlink\" title=\"有界队列\"></a>有界队列</h4><p>一般需要设置有界队列的大小，比如LinkedBlockingQueue在构造的时候就可以传入参数，来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的oom。</p>\n","text":"Executor线程池在Java框架设计中，一般涉及到资源相关的，并且资源具有创建消耗大、可复用的特点时，都采用了池化技术管理资源，形成一个“资源池”，池化技术可以带来以下一般性好处：对外部隐藏了资源的创建与释放的细节、实现资源的复用减少内存或者时间性能开销。常见Java中池化技...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"线程池","slug":"线程池","count":3,"path":"api/tags/线程池.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">Executor线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9D%A5%E8%87%AA%E4%BA%8EJDK1-5%E7%9A%84JUC%E5%8C%85%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%AE%E7%9A%84%E6%88%96%E8%80%85%E5%A5%BD%E5%A4%84%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">Executor线程池来自于JDK1.5的JUC包，使用线程池的目的或者好处如下：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Executor线程池的基本结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JDK%E5%86%85%E9%83%A8%E6%8F%90%E4%BE%9B%E4%BA%86Executors%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E6%9D%A5%E5%BF%AB%E9%80%9F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%82\"><span class=\"toc-text\">JDK内部提供了Executors这个工具类，来快速的创建线程池。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9B%B8%E7%AD%89\"><span class=\"toc-text\">固定线程数量的线程池：核心线程数与最大线程数相等</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">单个线程数量的线程池</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E8%BF%91%E6%97%A0%E9%99%90%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">接近无限大线程数量的线程池</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">带定时调度功能的线程池</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThreadPoolExecutor%E7%9A%84%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">ThreadPoolExecutor的概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ThreadPoolExecutor%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">ThreadPoolExecutor的主要属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">线程池的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ThreadPoolExecutor%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8\"><span class=\"toc-text\">ThreadPoolExecutor的构造器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#corePoolSize%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%82%E4%B8%8D%E8%83%BD%E5%B0%8F%E4%BA%8E0%E3%80%82\"><span class=\"toc-text\">corePoolSize：线程池核心线程数。不能小于0。</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#maximumPoolSize%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%82%E4%B8%8D%E8%83%BD%E5%B0%8F%E4%BA%8EcorePoolSize%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E0%E3%80%82\"><span class=\"toc-text\">maximumPoolSize：线程池最大线程数。不能小于corePoolSize，不能小于等于0。</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#keepAliveTime%EF%BC%9A%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%EF%BC%9Bunit%EF%BC%9AkeepAliveTime%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">keepAliveTime：空闲线程等待超时时间；unit：keepAliveTime时间单位</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#workQueue%EF%BC%9A%E9%98%BB%E5%A1%9E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E3%80%82\"><span class=\"toc-text\">workQueue：阻塞任务队列。</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#threadFactor%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">threadFactor：线程工厂</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#handler%EF%BC%9A%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E3%80%82\"><span class=\"toc-text\">handler：拒绝策略。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">线程池的运行原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9C%8B%E7%9C%8Bexecute%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84\"><span class=\"toc-text\">看看execute方法代码是如何实现的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ctl%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">ctl相关方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">线程池中线程实现复用的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B6%85%E6%97%B6%E7%9A%84\"><span class=\"toc-text\">线程是如何获取任务的以及如何实现超时的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">实际项目中如何合理的自定义线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%95%B0\"><span class=\"toc-text\">线程数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">线程工厂</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%89%E7%95%8C%E9%98%9F%E5%88%97\"><span class=\"toc-text\">有界队列</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"微服务_入门","uid":"fe3fb8c55b48b7e212cb33aae1728c63","slug":"微服务-入门","date":"2023-06-08T09:44:27.000Z","updated":"2023-06-10T15:48:11.230Z","comments":true,"path":"api/articles/微服务-入门.json","keywords":null,"cover":[],"text":"认识微服务单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"Java集合高频考点","uid":"19e0c7830137ba378427a6cdcb7fc021","slug":"Java集合高频考点","date":"2023-06-06T04:20:49.000Z","updated":"2023-06-07T11:08:27.946Z","comments":true,"path":"api/articles/Java集合高频考点.json","keywords":null,"cover":[],"text":"1. 常见的集合有哪些？Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意：Col...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":27,"path":"api/tags/Java.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}