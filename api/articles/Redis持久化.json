{"title":"Redis持久化","uid":"25530e52ab0638e424f51939c49f1051","slug":"Redis持久化","date":"2023-06-15T08:51:33.000Z","updated":"2023-06-15T09:24:04.798Z","comments":true,"path":"api/articles/Redis持久化.json","keywords":null,"cover":[],"content":"<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><h3 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>\n<h4 id=\"执行时机\"><a href=\"#执行时机\" class=\"headerlink\" title=\"执行时机\"></a>执行时机</h4><p>RDB持久化在四种情况下会执行：</p>\n<ul>\n<li>执行save命令<ul>\n<li>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</li>\n</ul>\n</li>\n<li>执行bgsave命令<ul>\n<li>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</li>\n</ul>\n</li>\n<li>Redis停机时<ul>\n<li>Redis停机时会执行一次save命令，实现RDB持久化。</li>\n</ul>\n</li>\n<li>触发RDB条件时</li>\n</ul>\n<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"><span class=\"token comment\"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \"\" 则表示禁用RDB</span>\n<span class=\"token key attr-name\">save</span> <span class=\"token value attr-value\">900 1  </span>\n<span class=\"token key attr-name\">save</span> <span class=\"token value attr-value\">300 10  </span>\n<span class=\"token key attr-name\">save</span> <span class=\"token value attr-value\">60 10000 </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>RDB的其它配置也可以在redis.conf文件中设置：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"><span class=\"token comment\"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>\n<span class=\"token key attr-name\">rdbcompression</span> <span class=\"token value attr-value\">yes</span>\n\n<span class=\"token comment\"># RDB文件名称</span>\n<span class=\"token key attr-name\">dbfilename</span> <span class=\"token value attr-value\">dump.rdb  </span>\n\n<span class=\"token comment\"># 文件保存的路径目录</span>\n<span class=\"token key attr-name\">dir</span> <span class=\"token value attr-value\">./ </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"RDB原理\"><a href=\"#RDB原理\" class=\"headerlink\" title=\"RDB原理\"></a>RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>\n<p>fork采用的是copy-on-write技术：</p>\n<ul>\n<li>当主进程执行读操作时，访问共享内存；</li>\n<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>\n</ul>\n<p><img src=\"/../assets/redis-git/image-20210725151319695.png\" alt=\"image-20210725151319695\"></p>\n<p>RDB的缺点</p>\n<ul>\n<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>\n<li>fork子进程、压缩、写出RDB文件都比较耗时</li>\n</ul>\n<h3 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h3><h4 id=\"AOF原理\"><a href=\"#AOF原理\" class=\"headerlink\" title=\"AOF原理\"></a>AOF原理</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>\n<h4 id=\"AOF配置\"><a href=\"#AOF配置\" class=\"headerlink\" title=\"AOF配置\"></a>AOF配置</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"><span class=\"token comment\"># 是否开启AOF功能，默认是no</span>\n<span class=\"token key attr-name\">appendonly</span> <span class=\"token value attr-value\">yes</span>\n<span class=\"token comment\"># AOF文件的名称</span>\n<span class=\"token key attr-name\">appendfilename</span> <span class=\"token value attr-value\">\"appendonly.aof\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"><span class=\"token comment\"># 表示每执行一次写命令，立即记录到AOF文件</span>\n<span class=\"token key attr-name\">appendfsync</span> <span class=\"token value attr-value\">always </span>\n<span class=\"token comment\"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>\n<span class=\"token key attr-name\">appendfsync</span> <span class=\"token value attr-value\">everysec </span>\n<span class=\"token comment\"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>\n<span class=\"token key attr-name\">appendfsync</span> <span class=\"token value attr-value\">no</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>三种策略对比：</p>\n<p><img src=\"/../assets/redis-git/image-20210725151654046.png\" alt=\"image-20210725151654046\"></p>\n<h4 id=\"AOF文件重写\"><a href=\"#AOF文件重写\" class=\"headerlink\" title=\"AOF文件重写\"></a>AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>\n<p><img src=\"/../assets/redis-git/image-20210725151729118.png\" alt=\"image-20210725151729118\"></p>\n<p>AOF文件内容就是：<code>mset name jack num 666</code></p>\n<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"><span class=\"token comment\"># AOF文件比上次文件 增长超过多少百分比则触发重写</span>\n<span class=\"token key attr-name\">auto-aof-rewrite-percentage</span> <span class=\"token value attr-value\">100</span>\n<span class=\"token comment\"># AOF文件体积最小多大以上才触发重写 </span>\n<span class=\"token key attr-name\">auto-aof-rewrite-min-size</span> <span class=\"token value attr-value\">64mb </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"RDB与AOF对比\"><a href=\"#RDB与AOF对比\" class=\"headerlink\" title=\"RDB与AOF对比\"></a>RDB与AOF对比</h4><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>\n<p><img src=\"/../assets/redis-git/image-20210725151940515.png\" alt=\"image-20210725151940515\"></p>\n","text":"Redis持久化RDB持久化RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">Redis持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RDB%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">RDB持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">执行时机</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RDB%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">RDB原理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AOF%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">AOF持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#AOF%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">AOF原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#AOF%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">AOF配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#AOF%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99\"><span class=\"toc-text\">AOF文件重写</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RDB%E4%B8%8EAOF%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">RDB与AOF对比</span></a></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis主从-哨兵-分片集群","uid":"e17bf8cdf59871b374971436072adfe0","slug":"Redis主从-哨兵-分片集群","date":"2023-06-15T09:27:23.000Z","updated":"2023-06-15T12:49:23.964Z","comments":true,"path":"api/articles/Redis主从-哨兵-分片集群.json","keywords":null,"cover":[],"text":"Redis主从单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 主从数据同步原理全量同步主从第一次建立连接时，会执行全量同步，将master节点的所有数据都拷贝给slave节点，流程： master如何得知salve是第一...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"redis","slug":"redis","count":14,"path":"api/tags/redis.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Git经典场景操作","uid":"a23f2d002fc146791ed8e3604cc7ab69","slug":"Git经典场景操作","date":"2023-06-14T14:29:11.000Z","updated":"2023-06-15T13:58:30.560Z","comments":true,"path":"api/articles/Git经典场景操作.json","keywords":null,"cover":[],"text":"Git常用命令 命令名称 作用 git config –global user.name 用户名 设置用户签名 git config –global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}