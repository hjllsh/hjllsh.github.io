{"title":"模板方法的设计模式","uid":"594a23198fd2599edc1d35598ede3148","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","updated":"2023-05-09T14:04:17.842Z","comments":true,"path":"api/articles/模板方法模式.json","keywords":null,"cover":null,"content":"<h2 id=\"模板方法的设计模式\"><a href=\"#模板方法的设计模式\" class=\"headerlink\" title=\"模板方法的设计模式\"></a>模板方法的设计模式</h2><p>它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。</p>\n<p><strong>模板方法设计模式的优点</strong></p>\n<ol>\n<li>将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。</li>\n<li>通过把通用方法提取到抽象类中，避免了重复代码的出现，提高了代码的可重用性。</li>\n<li>提高了代码的可扩展性，可以在不修改算法骨架结构的情况下替换部分内容。</li>\n<li>使得算法的实现更加灵活，允许不同子类实现算法骨架的不同部分。</li>\n</ol>\n<p><strong>模板方法设计模式的缺点</strong></p>\n<ol>\n<li>由于将算法细节分离开，代码的难度可能会增加，这会导致代码的维护成本增加。</li>\n<li>子类对父类的依赖性较高，使得继承的滥用可能会导致代码的复杂性和不可读性增加。</li>\n<li>如果算法骨架的修改较多，可能会导致大量的类都需要进行调整，这会带来一定的开销。</li>\n</ol>\n<h6 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h6><p>首先，创建一个抽象模板类，它定义了一个算法的骨架，并包含一些抽象方法，这些方法将在子类中实现。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AlgorithmTemplate</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">executeAlgorithm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后，创建几个继承自抽象模板类的具体子类，并实现抽象方法。</p>\n<pre class=\"line-numbers language-jav\" data-language=\"jav\"><code class=\"language-jav\">public class ConcreteAlgorithmA extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Finalizing...&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteAlgorithmB extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Finalizing...&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最后，在主程序中使用这些子类来演示模板方法设计模式。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">AlgorithmTemplate</span> algorithmA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteAlgorithmA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">AlgorithmTemplate</span> algorithmB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteAlgorithmB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        algorithmA<span class=\"token punctuation\">.</span><span class=\"token function\">executeAlgorithm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        algorithmB<span class=\"token punctuation\">.</span><span class=\"token function\">executeAlgorithm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当执行该程序时，输出如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ConcreteAlgorithmA</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Initializing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token class-name\">ConcreteAlgorithmA</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Processing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token class-name\">ConcreteAlgorithmA</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Finalizing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token class-name\">ConcreteAlgorithmB</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Initializing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token class-name\">ConcreteAlgorithmB</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Processing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token class-name\">ConcreteAlgorithmB</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Finalizing</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，多个具体子类都通过继承抽象模板类来实现相同的算法骨架。这使得更改算法骨架变得更加容易，并且可以避免重复编写相似的算法代码。</p>\n","text":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。 模板方法设计模式的优点 将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。 通过把通用方法提取到抽象类中，避免了重复代码的出现，...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":18,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":12,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">模板方法的设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"AOP实现之agent类加载","uid":"d7e2802c58918040c31b14740192f666","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","updated":"2023-05-10T08:39:08.324Z","comments":true,"path":"api/articles/AOP实现之agent类加载.json","keywords":null,"cover":null,"text":"AOP实现之agent类加载","link":"","photos":[],"count_time":{"symbolsCount":14,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":18,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":7,"path":"api/tags/Spring.json"},{"name":"AOP","slug":"AOP","count":1,"path":"api/tags/AOP.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}},"next_post":{"title":"策略模式","uid":"8ced7c3b7dad33d06ee59bde7028cd4a","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","updated":"2023-05-09T13:33:40.042Z","comments":true,"path":"api/articles/策略模式.json","keywords":null,"cover":null,"text":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。 在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。 优点 封装了一系列算法：将一系列...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":18,"path":"api/tags/Java.json"},{"name":"设计模式","slug":"设计模式","count":12,"path":"api/tags/设计模式.json"}],"author":{"name":"大宝贝的程序员","slug":"blog-author","avatar":"/img/header.jpg","link":"/","description":"Java实习生,即将入职场的小白","socials":{"github":"https://github.com/hjllsh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://mp.csdn.net/mp_blog/manage/article","juejin":"","customs":{}}}}}