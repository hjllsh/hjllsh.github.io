[{"id":"d45227e04d8ac0c4d2b575d738f28254","title":"spring中的设计模式","content":"","slug":"spring中的设计模式","date":"2023-05-09T04:00:50.000Z","categories_index":"","tags_index":"Java,设计模式,Spring","author_index":"大宝贝的程序员"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，\n构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀\n个静态公有⽅法获取实例。\n优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的\n情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，\n与单⼀职责原则冲突。\n单例模式的常⻅写法有哪些？饿汉式顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间。\n\n优点：线程安全，没有加锁，执⾏效率较⾼\n\n缺点：不是懒加载，类加载时就初始化，浪费内存空间\n\n\n\n线程安全：饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程\n的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。\n\n\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123;&#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private final static Singleton instance = new\nSingleton();\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n return instance;\n &#125;\n&#125;\n\n使⽤反射破坏单例public class Test &#123;\n public static void main(String[] args) throws\nException&#123;\n // 使⽤反射破坏单例\n // 获取空参构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(null);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例\n Singleton singleton =\ndeclaredConstructor.newInstance();\n System.out.println(\"反射创建的实例\" + singleton);\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n &#125;\n&#125;\n\n输出结果如下反射创建的实例\ncom.example.spring.demo.single.Singleton@6267c3bb\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n\n线程不安全的懒汉式这种⽅式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的，这⾥列出来是为了和后⾯使⽤锁保证线程安全的单例做对⽐\n\n优点：懒加载\n缺点：线程不安全\n\n//线程不安全的懒汉式单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 判断为 null 的时候再创建对象\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n &#125;\n&#125;\n\n线程安全的懒汉式懒汉式单例如何保证线程安全呢？通过 synchronized 关键字加锁保证线程\n安全， synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这\n⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时\n都需要加锁和释放锁，这样是⾮常影响性能的。\n\n优点：懒加载，线程安全\n\n缺点：效率较低\n\n\n//懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public synchronized static Singleton getInstance() &#123;\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n    &#125;\n&#125;\n\n双重检查锁(DCL)这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么\n要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就\n不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进\n⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调\n⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同\n步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创\n建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单\n例。\n关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁\n竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对\n象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返\n回已创建的单例对象。\n其中最关键的⼀个点就是 volatile 关键字的使⽤，关于 volatile 的详细介\n绍可以直接搜索 volatile 关键字即可，有很多写的⾮常好的⽂章，这⾥不做\n详细介绍，简单说明⼀下，双重检查锁中使⽤ volatile 的两个重要特性：\n可⻅性、禁⽌指令重排序\n当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令\n的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对\nvolatile 修饰的变量的修改对其他任何线程都是可⻅的\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private volatile static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 第⼀重检查是否为 null\n if (instance == null) &#123;\n // 使⽤ synchronized 加锁\n synchronized (Singleton.class) &#123;\n // 第⼆重检查是否为 null\n     if (instance == null) &#123;\n // new 关键字创建对象不是原⼦操作\n instance = new Singleton();\n\t \t\t&#125;\n \t\t&#125;\n \t&#125;\n return instance;\n \t&#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼\n\n缺点：实现较复杂\n\n\n静态内部类//静态内部类实现单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、对外提供获取实例的公共⽅法\n public static Singleton getInstance() &#123;\n return InnerClass.INSTANCE;\n     \n // 定义静态内部类\n private static class InnerClass&#123;\n private final static Singleton INSTANCE = new\nSingleton();\n &#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼，实现简单\n\n静态内部类单例是如何实现懒加载的呢？⾸先，我们先了解下类的加载时机。虚拟机规范要求有且只有 5 种情况必须⽴即对类进⾏初始化（加载、验证、准备需要在此之前开始）：\n\n遇到 new 、 getstatic 、 putstatic 、 invokestatic 这 4 条字节码指令时。⽣成这 4 条指令最常⻅的 Java 代码场景是：使⽤ new 关键字实例化对象的时候、读取或设置⼀个类的静态字段（final 修饰除外，被final 修饰的静态字段是常量，已在编译期把结果放⼊常量池）的时候，以及调⽤⼀个类的静态⽅法的时候。\n使⽤ java.lang.reflect 包⽅法对类进⾏反射调⽤的时候。\n当初始化⼀个类的时候，如果发现其⽗类还没有进⾏过初始化，则需要先触发其⽗类的初始化。\n当虚拟机启动时，⽤户需要指定⼀个要执⾏的主类（包含 main()的那个类），虚拟机会先初始化这个主类。\n当使⽤ JDK 1.7 的动态语⾔⽀持时，如果⼀个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_getStatic 、 REF_putStatic 、 REF_invokeStatic 的⽅法句柄，则需要先触发这个⽅法句柄所对应的类的初始化。\n\n这 5 种情况被称为是类的主动引⽤，注意，这⾥《虚拟机规范》中使⽤的限定词是 “有且仅有”，那么，除此之外的所有引⽤类都不会对类进⾏初始化，称为被动引⽤。静态内部类就属于被动引⽤的情况。\n当 getInstance()⽅法被调⽤时，InnerClass 才在 Singleton 的运⾏时常量池⾥，把符号引⽤替换为直接引⽤，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()⽅法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中⼜是如何保证线程安全的呢？\n虚拟机会保证⼀个类的 () ⽅法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个类的 () ⽅法，其他线程都需要阻塞等待，直到活动线程执⾏() ⽅法完毕。如果在⼀个类的 () ⽅法中有耗时很⻓的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执⾏ () ⽅法后，其他线程唤醒之后不会再次进⼊ () ⽅法。同⼀个加载器下，⼀个类型只会初始化⼀次。)，在实际应⽤中，这种阻塞往往是很隐蔽的。\n所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯⼀性，同时也延迟了单例的实例化。\n枚举单例//枚举实现单例\npublic enum Singleton &#123;\n INSTANCE;\n public void doSomething(String str) &#123;\n System.out.println(str);\n &#125;\n&#125;\n\n\n优点：简单，⾼效，线程安全，可以避免通过反射破坏枚举单例\n\n枚举在 java 中与普通类⼀样，都能拥有字段与⽅法，⽽且枚举实例创建是线程安全的，在任何情况下，它都是⼀个单例，可以直接通过如下⽅式调⽤获取实例：\nSingleton singleton = Singleton.INSTANCE;\n使⽤下⾯的命令反编译枚举类\njavap Singleton.class\n得到如下内容\nCompiled from \"Singleton.java\"\npublic final class com.spring.demo.singleton.Singleton\nextends\njava.lang.Enum&lt;com.spring.demo.singleton.Singleton> &#123;\n public static final\ncom.spring.demo.singleton.Singleton INSTANCE;\n public static com.spring.demo.singleton.Singleton[]\nvalues();\n public static com.spring.demo.singleton.Singleton\nvalueOf(java.lang.String);\n public void doSomething(java.lang.String);\n static &#123;&#125;;\n&#125;\n\n从枚举的反编译结果可以看到，INSTANCE 被 static final 修饰，所以可以通过类名直接调⽤，因为static 类型的属性会在类被加载之后被初始化，当⼀个 Java 类第⼀次被真正使⽤到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的，所以创建⼀个 enum 类型是线程安全的。\n通过反射破坏枚举，实现代码如下：public class Test &#123;\n public static void main(String[] args) throws\nException &#123;\n Singleton singleton = Singleton.INSTANCE;\n singleton.doSomething(\"hello enum\");\n // 尝试使⽤反射破坏单例\n // 枚举类没有空参构造⽅法，反编译后可以看到枚举有⼀个两个\n参数的构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(String.class,\nint.class);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例，这⾥会报错，因为⽆法通过反射创建枚举的实例\n Singleton enumSingleton =\ndeclaredConstructor.newInstance();\n System.out.println(enumSingleton);\n &#125;\n&#125;\n\n运⾏结果报如下错误：\nException in thread \"main\"\njava.lang.IllegalArgumentException: Cannot reflectively\ncreate enum objects at\njava.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492) \nat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\nat com.spring.demo.singleton.Test.main(Test.java:24)\n\n所以⽆法通过反射创建枚举的实例。\n","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"064fd1f961f785b45ddfca5b3ce563ee","title":"spring事务失效的情况以及注意事项","content":"什么是spring事务？​\tSpring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。\n​\tSpring事务的核心思想是将事务管理从具体的数据访问代码中抽象出来。Spring提供了一种集中式的方式来管理事务，这使得我们可以在不修改具体数据访问代码的情况下轻松地添加或删除事务。\nspring事务的优点Spring事务具有以下优点：\n简单性 - Spring事务使得事务管理变得非常简单，只需要添加少量的注释就可以实现。\n可扩展性 - Spring事务提供了各种事务管理器，以适应各种不同的事务需求。它还允许我们自行扩展和定制事务管理器。\n独立性 - Spring事务提供了一种与底层数据访问技术无关的事务管理方式，因此我们可以轻松地更改数据库，而不需要更改事务管理方式。\nspring事务的类型Spring事务有以下常见的类型：\n\n声明式事务 - 该类型的事务是在配置文件或注释中声明的。这使得我们可以轻松地添加和删除事务。\n编程式事务 - 该类型的事务是通过编写代码来实现的。它提供了更细粒度的控制和更高的自定义程度。但是，编写代码会使得代码复杂化。\n\nspring事务失效的情况事务失效的八种场景1.抛出检查异常导致事务不能正确回滚补充什么是检查异常：\nJava中的异常分为两种类型：检查异常和非检查异常。\n检查异常需要使用try-catch语句或者throws声明来处理或抛出，否则编译器会报错。这种异常通常表示程序运行时必须解决的某些错误或不合法操作。例如：IOException、SQLException、ClassNotFoundException等。\n非检查异常是指RuntimeException及其子类异常，不需要在代码中进行特殊处理，程序在运行期间出现这种异常时，会自动触发JVM的异常处理机制。这种异常通常表示程序出现了逻辑或编程错误。例如：NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。\n@Service\npublic class Service1 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n无法事务回滚：Spring默认只会回滚非检查异常\n\n解法：\n配置rollbackFor属性 (什么错误需要回滚)：\n @Transactional(rollbackFor = Exception.class)\n\n\n2.方法内自己try-catch异常导致事务不能正确回滚@Service\npublic class Service2 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount)  &#123;\n        try &#123;\n            int fromBalance = accountMapper.findBalanceBy(from);\n            if (fromBalance - amount >= 0) &#123;\n                accountMapper.update(from, -1 * amount);\n                new FileInputStream(\"hj\");\n                accountMapper.update(to, amount);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n原因：事务通知只有捕捉到了目标方法抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉\n\n方法1：将catch到的异常，包装成运行时异常抛出\n\n在catch块里throw new RuntimeException(e);\n\n\n方法2：手动设置回滚\n\n在catch块添加\nTransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n\n\n\n\n3.aop切面顺序异常导致事务不能正确回滚@Service\npublic class Service3 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n@Aspect\npublic class MyAspect &#123;\n    @Around(\"execution(* transfer(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        LoggerUtils.get().debug(\"log:&#123;&#125;\", pjp.getTarget());\n        try &#123;\n            return pjp.proceed();\n        &#125; catch (Throwable e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.非public方法导致事务失效@Service\npublic class Service4 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n原因：Spring为方法创建代理，添加事务通知，前提条件都是方法为public\n\n方法1：方法改为public\n\n方法2：添加bean配置，不推荐使用\n\n@Bean\npublic TransactionAttributeSource transactionAttributeSource() &#123;\n    return new AnnotationTransactionAttributeSource(false);\n&#125;\n\n\n\n\n\n​\t拓展：AnnotationTransactionAttributeSource\n​\t\tAnnotationTransactionAttributeSource是Spring事务框架中的一个类，用于解析@Transactional注解并以此为基础生成TransactionAttribute对象。TransactionAttribute对象描述了一段方法执行时应该使用的事务属性，包括事务的名字、传播行为、隔离级别、超时时间、只读属性等。\n​\t\t在Spring的事务管理中，事务切面对象会调用AnnotationTransactionAttributeSource对象的getTransactionAttribute()方法，从而获取方法或类级别的事务属性。这种方式可以将事务属性与具体的业务代码解耦，使得业务代码更加简洁可读。\n​\t\tAnnotationTransactionAttributeSource对象有一个布尔类型的构造函数参数，它用于控制@Transactional注解的解析方式。如果这个参数为false，则AnnotationTransactionAttributeSource只会解析@Transactional注解，而不会考虑继承和重载关系，即只解析被注解类或方法上的@Transactional注解，而不考虑其基类和子类以及重载方法中的@Transactional注解。\n​\t\t默认情况下AnnotationTransactionAttributeSource对象的构造函数参数是true，即支持继承和重载的注解解析。但是，在某些特殊情况下，这种解析方式可能会导致一些问题，如事务传播、超时等不被正确解析。此时，可以通过设置构造函数参数为false来禁用这种解析机制，以确保正确地解析@Transactional注解。\n5.父子容器导致的事务失效6.调用本类方法导致传播行为失效7.@Transactional没有保证原子行为8.@Transactional方法导致的synchronized失效","slug":"spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","categories_index":"","tags_index":"Java,tx,Spring","author_index":"大宝贝的程序员"},{"id":"d92f9a82ea2d721c59e89ea931dfa8d4","title":"new page","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nmyHexoCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"}]