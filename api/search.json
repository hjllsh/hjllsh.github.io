[{"id":"84c6604e94d88eec227a0b74aad54f6e","title":"Spring MVC","content":"Spring MVCWebMvcConfigurerWebMvcConfigurer是一个Spring MVC的配置接口，它提供了一些方法来进行各种配置。WebConfig类实现了这个接口，因此可以利用这些方法来配置应用程序。例如：addInterceptors()：用于添加拦截器。addResourceHandlers()：用于配置静态资源处理器。configureContentNegotiation()：用于配置内容协商策略。configureDefaultServletHandling()：用于配置静态资源处理。通过实现这些方法，可以细粒度地控制Spring MVC框架的行为。WebConfig类可以被视为是一个替代Spring MVC框架默认配置的类，它可以根据开发者的需求来提供不同的配置，从而实现个性化的应用程序需求。\n","slug":"Spring-MVC","date":"2023-05-20T12:40:51.000Z","categories_index":"","tags_index":"Spring,Spring MVC","author_index":"大宝贝的程序员"},{"id":"12e6f0c825691db3e38970eadda0c57d","title":"InnoDB存储引擎_MVCC原理","content":"InnoDB引擎逻辑存储结构InnoDB的逻辑存储结构如下图所示:\n\n 表空间\n表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。\n段\n段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。\n区\n区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。\n 页\n页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。\n行\n行，InnoDB 存储引擎数据是按行进行存放的。\n在行中，默认有两个隐藏字段：\n​\t\tTrx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。\n​\t\tRoll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。\n架构MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。\n\n内存结构\n主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 \n Buffer Pool\nInnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O\n在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等\n缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：\n​\tfree page：空闲page，未被使用。\n​\tclean page：被使用page，数据没有被修改过。\n​\tdirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。\n在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：show variables like  &#39;innodb_buffer_pool_size&#39;;\nChange Buffer\nChange Buffer，更改缓冲区（针对于非唯一的二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。\nChange Buffer的意义是什么呢?\n与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。\n Adaptive Hash Index\n参数： adaptive_hash_index\n自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的InnoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。\nInnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。自适应哈希索引，无需人工干预，是系统根据情况自动完成。\n Log Buffer\ninnodb_log_buffer_size：缓冲区大小\ninnodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：\n​\t\t1: 日志在每次事务提交时写入并刷新到磁盘，默认值。\n​\t\t0: 每秒将日志写入并刷新到磁盘一次。\n​\t\t2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。\nLog Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。\n磁盘结构InnoDB体系结构的磁盘结构：\n\n System Tablespace\n参数：innodb_data_file_path\n系统表空间是一个特殊的InnoDB表空间，它是用来存储系统表和索引的地方。虽然你可以在其他表空间中创建表，在系统表空间中包含这些表和索引数据，允许InnoDB使用更少的内存和磁盘空间，因为系统表空间是被当做一个单独的文件处理。系统表空间，默认的文件名叫 ibdata1。\n当你使用InnoDB引擎时，系统表空间在存储InnoDB的缓存池中发挥着重要的作用。MySQL使用缓存机制来最小化对硬盘I&#x2F;O访问的次数，来提高InnoDB性能。系统表空间是其中之一，InnoDB会将读取的数据缓存到系统表空间中，并使用系统表空间将存储的数据进行共享，避免了不必要的副本。\n系统表空间是通过配置文件参数innodb_data_file_path来定义的。通常，系统表空间会被定义为一个更改缓冲区和一个UNDO日志空间的共同文件。在MySQL 5.x版本中，由于InnoDB存储一些特殊的元数据和事务信息，所以系统表空间还包含了InnoDB数据字典、undolog等，用来支持事务和锁等机制的实现。\nFile-Per-Table Tablespaces\n开关参数：innodb_file_per_table ，该参数默认开启。\n如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。我们每创建一个表，都会产生一个表空间文件\n General Tablespaces\n通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。\n创建表空间\nCREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name;\n-- 创建表时指定表空间\nCREATE TABLE xxx ... TABLESPACE ts_name;\n\nUndo Tablespaces\n撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间初始大小16M，用于存储undo log日志\nTemporary Tablespaces\nInnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。\nDoublewrite Buffer Files\n双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。\n涉及文件：#ib_16384_0.dblwr、#ib_16384_1.dblwr\nRedo Log\n重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用\n以循环方式写入重做日志文件，涉及两个文件：ib_logfile0、iblogfile1\n后台线程\n在InnoDB的后台线程中，分为4类：\nMaster Thread 、IO Thread、Purge Thread、Page Cleaner Thread\n Master Thread\n核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。\n IO Thread\n在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。\n查看到InnoDB的状态信息，其中就包含IO Thread信息\nshow engine innodb status \\G;\n\n\n\n\n线程类型\n默认个数\n职责\n\n\n\nRead thread\n4\n负责读操作\n\n\nWrite thread\n4\n负责写操作\n\n\nLog thread\n1\n负责将日志缓冲区刷新到磁盘\n\n\nInsert buffer thread\n1\n负责将写缓冲区内容刷新到磁盘\n\n\n Purge Thread\n主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。\nPage Cleaner Thread\n协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。\n事务原理我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。\n而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的。\n\nredo log\n重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。\n该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。\n如果没有redolog，可能会存在什么问题的？\n\n在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。\n在InnoDB中提供了一份日志 redo log，接下来我们再来看看，通过redolog如何解决这个问题。\n\n有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。\n那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?\n因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）\nundo log\n回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) \nundo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。\nUndo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。\nUndo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。\nMVCCMVCC全称为Multi-Version Concurrency Control，即多版本并发控制。它是一种用于实现数据库事务的并发控制方式，主要应用于多用户、多事务同时执行的环境下，用来保证事务的隔离性和并发性。\nMVCC的主要思想是为每个数据库记录维护多个版本，每个版本都对应着不同的事务更新。这样，即使有多个事务并发执行，每个事务看到的都是一致性的数据，而不会发生脏读、不可重复读等问题。\n当前读\n读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。\n\n即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。\n 快照读\n简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。\nRead Committed：每次select，都生成一个快照读。\nRepeatable Read：开启事务后第一个select语句才是快照读的地方。\nSerializable：快照读会退化为当前读。\n演示RR\n\n到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。\n MVCC\n全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。\n隐藏字段\n我们创建了一张表，在查看表结构的时候，就可以显式的看到这张表的字段。实际上除了显式字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是\n\n\n\n隐藏字段\n含义\n\n\n\nDB_TRX_ID\n最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。\n\n\nDB_ROLL_PTR\n回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本\n\n\nDB_ROW_ID\n隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段\n\n\n测试\n查看有主键的表 stu\n进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;hj&#x2F; , 查看stu的表结构信息, 通过如下指令:\nibd2sdi stu.ibd\n\n除了我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID隐藏字段\n查看没有主键的表 employee\nibd2sdi employee.ibd\n\n处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的\n 版本链\n有一张表原始数据为：\n\nDB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。\nDB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。\n有四个并发事务同时在访问这张表\n\n当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。\n\n紧接着事务三操作\n\n当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。\n\n最终发现不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。\nreadview\nReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的未提交事务的id。在使用 MVCC 进行事务并发控制时，数据库需要维护一个 ReadView(读视图)，它是快照读在 SQL 执行过程中提取数据的依据。\nReadView 记录着系统当前活跃的事务的 id。一个事务被视作“活跃”的条件是它已经启动，但尚未提交或回滚。也就是说，只有在提交或回滚时，事务才算结束，它的 id 才被从 ReadView 中移除。\nReadView 中的事务 id 用来判断一个快照读的数据版本是否可见。当一个事务执行快照读时，它会读取 ReadView 的事务 id，用于确定事务开始前那一刻的数据版本。如果在它之前启动的活跃事务已经对数据进行了修改，那么这些修改的数据版本对该事务来说是不可见的，因为它的事务 id 在 ReadView 中。而读视图只会看到在它之前启动的事务的更新，它之后启动的事务的更新它是不可见的。\n因此，保持 ReadView 中的 id 维护了系统当前的并发状态，使得快照读能够在一致性的基础上提取数据，避免了不合适的结果。\nReadView中包含了四个核心字段：\n\n\n\n字段\n含义\n\n\n\nm_ids\n当前活跃的事务ID集合\n\n\nmin_trx_id\n最小活跃事务ID\n\n\nmax_trx_id\n预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）\n\n\ncreator_trx_id\nReadView创建者的事务ID\n\n\n而在readview中就规定了版本链数据的访问规则：\n​\ttrx_id 代表当前undo log版本链对应事务ID。\n\n\n\n条件\n是否可以访问\n说明\n\n\n\ntrx_id &#x3D;&#x3D; creator_trx_id\n可以访问该版本\n成立，说明数据是当前这个事务更改的。\n\n\ntrx_id &lt; min_trx_id\n可以访问该版本\n成立，说明数据已经提交了。\n\n\ntrx_id &gt; max_trx_id\n不可以访问该版本\n成立，说明该事务是在ReadView生成后才开启。\n\n\nmin_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id\n如果trx_id不在m_ids中，是可以访问该版本的\n成立，说明数据已经提交。\n\n\n不同的隔离级别，生成ReadView的时机不同：\n​\tREAD COMMITTED ：在事务中每一次执行快照读时生成ReadView。\n​\tREPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。\n原理分析\nRC隔离级别\nRC隔离级别下，在事务中每一次执行快照读时生成ReadView。\n我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?\n在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。\n\n那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undo log版本链中匹配数据，最终决定此次快照读返回的数据。\n先来看第一次快照读具体的读取过程：\n\n\n在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：\n先匹配 DB_TRX_ID &#x3D; 4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。\n再匹配第二条DB_TRX_ID &#x3D; 3，将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条\n再匹配第三条DB_TRX_ID &#x3D; 2，将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据\n再来看第二次快照读具体的读取过程:\n\n\n在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：\n先匹配 DB_TRX_ID &#x3D; 4，将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。\n再匹配DB_TRX_ID &#x3D; 3，将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。\n RR隔离级别\nRR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。\n\n在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的\n所以MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证\n\n","slug":"InnoDB存储引擎-MVCC原理","date":"2023-05-20T02:00:56.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"083e3a4ebfcb19d327b53b7d73aaddd3","title":"MySQL_锁","content":"锁​\t\t锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\nMySQL中的锁，按照锁的粒度分，分为以下三类：\n\n全局锁：锁定数据库中的所有表。\n\n表级锁：每次操作锁住整张表。\n\n行级锁：每次操作锁住对应的行数据\n\n\n全局锁​\t\t全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\n​\t\t其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。\n为什么全库逻辑备份，就需要加全就锁呢？\n不加全局锁，可能存在的问题。\n假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。\n\n​\t\t在进行数据备份时，先备份了tb_stock库存表。\n​\t\t然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。\n​\t\t然后再执行备份 tb_order表的逻辑。\n​\t\t业务中执行插入订单日志操作。\n最后，又备份了tb_orderlog表。\n此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)\n此时就可以借助于MySQL的全局锁来解决\n\n对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。\n语法\n 加全局锁\nflush tables with read lock ;\n\n 数据备份\nmysqldump [--single-transaction] -uroot –p1234 hj > hj.sql\n--   mysqldump: 是MySQL备份工具。\n--   -u : 指定连接数据库所用的用户名\n--   –p : 指定连接数据库所用的密码\n--   hj : 要备份的数据库名称。\n--   > hj.sql : 将备份文件输出到itcast.sql文件中，使用\">\"符号是将备份文件的内容导出到指定文件。\n\n释放锁\nunlock tables;\n\n数据库中加全局锁，是一个比较重的操作，存在以下问题：\n\n如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。\n\n如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。\n\n\n在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。\n该命令执行期间，在备份开始时使用START TRANSACTION语句来开启一个事务，这个事务会在备份期间一直执行，隔离级别默认为“可重复读”级别。在备份完成后，使用COMMIT语句来提交事务，这样就可以保证备份是一致性的，不会受到正在进行的其他事务的影响。\n需要注意的是，使用--single-transaction参数只适用于没有写锁的表。如果有表正在执行DDL语句，或者有使用ALTER TABLE，OPTIMIZE TABLE等语句的话，这些表仍然会被加锁，备份也会受到影响。\n表级锁表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。\n对于表级锁，主要分为以下三类：\n\n表锁\n\n​\t\t- 表共享读锁（read lock）\n​\t\t- 表独占写锁（write lock）\n\n元数据锁（meta data lock，MDL）\n\n意向锁\n\n\n表锁语法：\n-- 加锁：\nlock tables 表名... read/write\n-- 释放锁\nunlock tables / 客户端断开连接\n\n 读锁\n\n读写演示：\n\n对指定表加了读锁，加锁的会话未解锁时执行DML&#x2F;DDL会报错；\n\n读锁不会影响其他会话的读，但是会阻塞（不是报错）其他会话的写。\n写锁\n\n左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。\n结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。\n元数据锁\t\nmeta data lock , 元数据锁，简写MDL。\nMDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。\nMDL锁能够确保在进行表结构修改时，不会同时存在其他读和写操作，避免并发操作导致的数据冲突和错误。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。\n常见的SQL操作时，所添加的元数据锁：\n\n\n\n对应SQL\n锁类型\n说明\n\n\n\nlock tables xxx read &#x2F; write\nSHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE\n\n\n\nselect 、select … lock in share mode\nSHARED_READ\n与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥\n\n\ninsert 、update、delete、select … for update\nSHARED_WRITE\n与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥\n\n\nalter table …\nEXCLUSIVE\n与其他的MDL都互斥\n\n\n我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：\nselect object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;\n\n锁的兼容演示\n\n\nSHARED_READ与SHARED_WRITE兼容\n\n\nSHARED_READ与EXCLUSIVE互斥\n意向锁\n为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。\n假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：\n首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。\n\n当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。\n\n有了意向锁之后 :\n客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。\n\n而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。\n\n 分类\n意向共享锁(IS): 由语句select … lock in share mode添加 。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。\n意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。\n一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。\n查看意向锁及行锁的加锁情况：\nselect object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;\n\n意向锁演示\n意向共享锁(IS)与表锁共享锁兼容，与表锁排他锁互斥\n\n\n 意向排他锁(IX)与表读锁、写锁都是互斥的\n\n\n行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中.\nInnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的\n锁。对于行级锁，主要分为以下三类：\n\n行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持\n\n\n\n间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持\n\n\n\n临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。\n\n\n行锁\nInnoDB实现了以下两种类型的行锁：\n\n共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。\n\n排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。\n\n\n两种行锁的兼容情况如下:\n\n\n\n当前锁的类型\n请求锁的类型\n兼容情况\n\n\n\nS(共享锁)\nS(共享锁)\n兼容\n\n\nS(共享锁)\nX(排他锁)\n冲突\n\n\nX(排他锁)\nX(排他锁)\n冲突\n\n\nX(排他锁)\nS(共享锁)\n冲突\n\n\n常见的SQL语句，在执行时，所加的行锁如下：\n\n\n\nSQL\n行锁类型\n说明\n\n\n\nINSERT …\n排他锁\n自动加锁\n\n\nUPDATE …\n排他锁\n自动加锁\n\n\nDELETE …\n排他锁\n自动加锁\n\n\nSELECT（正常）\n不加任何锁\n\n\n\nSELECT … LOCK IN SHARE MODE\n共享锁\n需要手动在SELECT之后加LOCK IN SHARE MODE\n\n\nSELECT … FOR UPDATE\n排他锁\n需要手动在SELECT之后加FOR UPDATE\n\n\n默认情况下，InnoDB使用next-key 锁来实现 REPEATABLE READ 隔离级别，它是一种组合锁，包含索引记录锁和间隙锁。该锁的主要作用是在执行索引扫描时，对于所查找的每条记录，都要获取记录锁以及对应的间隙锁，以保证事务在读取数据时不会出现幻读问题。\n\n针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。\n\nInnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。\n\n\n查看意向锁及行锁的加锁情况：\nselect object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;\n\n 演示：表结构如下\nCREATE TABLE `stu` (\n`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,\n`name` varchar(255) DEFAULT NULL,\n`age` int NOT NULL\n) ENGINE = InnoDB CHARACTER SET = utf8mb4;\n\n select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。\n\n\n共享锁与排他锁之间互斥。\n\n\n无索引行锁升级为表锁\n\n\n开启事务，并执行update语句，更新name为tom的数据 。然后在另一个会话中更新name为rose的记录，却不能直接执行，会处于阻塞状态。原因就是，会话一根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁（因为行锁是对索引项加的锁，而name没有索引）\n再针对name字段建立索引，索引建立之后，再次做一个测试：\n\n\n这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。\n间隙锁&amp;临键锁\n默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。临键锁（Next-Key Lock）是InnoDB引擎在实现间隙锁（Gap Lock）时所加的锁，其作用是锁定间隙并保护间隙内的下一个记录，以防止其他事务在间隙内插入记录。\n\n索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。\n\n索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key锁退化为间隙锁。\n\n索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。\n\n\n间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。\n示例演示\n 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。\n\n\n查询（加共享锁）或者更新不存在的记录时，行锁（S或者X）会优化成间隙锁（GAP）,当在加了间隙锁的范围内insert插入数据时会阻塞，update&#x2F;delete不会阻塞。\n索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key锁退化为间隙锁。 \nInnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。\n\n假设我们有一个索引列a，对于值1到5之间的区间，如果我们设置了临键锁，那么除了a&#x3D;1和a&#x3D;5两条索引记录上的锁，还会锁住1&lt;a&lt;2, 2&lt;a&lt;3, 3&lt;a&lt;4和4&lt;a&lt;5这四个间隙上，以保护在该区间范围内下一个可能插入的记录不被其他事务插入。\n示例\n\n\n索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止\n\n查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：\n[19]\n(19,25]\n(25,+∞]\n所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。\n","slug":"MySQL-锁","date":"2023-05-19T01:39:57.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"7a80ec680e8c46b9ee58692b58f8ab63","title":"基于session实现认证","content":"什么是认证认证 ：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。\n什么是会话用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。\n基于session的认证方式如下图：\n\n它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。\n基于token方式如下图：\n\n它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。\n优略分析\n基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。\n什么是授权授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问\n基于角色的访问控制\nRBAC基于角色的访问控制（Role-Based Access Control）是按角色进行授权，判断逻辑：\nif(主体.hasRole(\"总经理角色id\"))&#123;\n查询工资\n&#125;\n\n查询工资所需要的角色变化为总经理和部门经理\n需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”\nif(主体.hasRole(\"总经理角色id\") || 主体.hasRole(\"部门经理角色id\"))&#123;\n查询工资\n&#125;\n\n就需要修改授权的相关代码，系统可扩展性差。\n基于资源的访问控制\nRBAC基于资源的访问控制（Resource-Based Access Control）是按资源（或权限）进行授权。\n授权代码可以表示为：\nif(主体.hasPermission(&quot;查询工资权限标识&quot;))&#123;\n查询工资\n&#125;\n\n优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。\n基于Session的认证方式\n基于Session的认证机制由Servlet规范定制，Servlet容器已实现，用户通过HttpSession的操作方法即可实现。\n本案例工程使用maven进行构建，使用SpringMVC、Servlet3.0实现。\n","slug":"基于session实现认证","date":"2023-05-18T14:10:28.000Z","categories_index":"","tags_index":"认证授权","author_index":"大宝贝的程序员"},{"id":"ca0fb70bccc39b11cac4043db766085d","title":"MySQL_存储引擎_索引","content":"MySQL存储引擎MySQL体系结构\n连接层\n最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于\nTCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程\n池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务\n器也会为安全接入的每个客户端验证它所具有的操作权限。\n服务层\n第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部\n分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解\n析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，\n最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，\n这样在解决大量读操作的环境中能够很好的提升系统的性能。\n引擎层\n存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通\n信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库\n中的索引是在存储引擎层实现的\n存储层\n数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询\n日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。\n其他数据库相比\nMySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎\n存储引擎介绍存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是\n基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果\n没有指定将自动选择默认的存储引擎。\tMySQL默认存储引擎: InnoDB\n 建表时指定存储引擎\nCREATE TABLE 表名(\n字段1 字段1类型 [ COMMENT 字段1注释 ] ,\n......\n字段n 字段n类型 [COMMENT 字段n注释 ]\n) ENGINE = INNODB [ COMMENT 表注释 ] ;\n\n查询当前数据库支持的存储引擎\nshow engines;\n\n存储引擎特点InnoDB\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。\n特点\n\nDML操作遵循ACID模型，支持事务；\n\n行级锁，提高并发访问性能；\n\n支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n\n\n文件\nxxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。\n查看参数：innodb_file_per_table\nshow variables like 'innodb_file_per_table';\n\n如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 \n每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表show variables like ‘innodb_file_per_table’; \n 逻辑存储结构\n\n表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以\n包含多个Segment段。\n段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管\n理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。\n区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为\n16K， 即一个区中一共有64个连续的页。\n页 : 页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默\n认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。\n行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时\n所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)\nMyISAM\nMyISAM是MySQL早期的默认存储引擎。\n特点\n\n不支持事务，不支持外键\n\n支持表锁，不支持行锁\n\n访问速度快\n\n\n 文件\nxxx.sdi：存储表结构信息\nxxx.MYD：存储数据\nxxx.MYI：存储索引\nMemory\nMemory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用\n特点\n内存存放\n hash索引（默认）\n文件\nxxx.sdi：存储表结构信息\n区别及特点\n\n\n特点\nInnoDB\nMyISAM\nMemory\n\n\n\n存储限制\n64TB\n存在受限\n存在受限\n\n\n事务安全\n支持\n不支持\n不支持\n\n\n锁机制\n表锁，行锁\n表锁\n表锁\n\n\nB+tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\n全文索引\n支持(5.6版本之后)\n支持\n不支持\n\n\n空间使用\n高\n低\nN&#x2F;A\n\n\n内存使用\n高\n低\n中等\n\n\n批量插入速度\n低\n高\n高\n\n\n支持外键\n支持\n不支持\n不支持\n\n\n存储引擎选择\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\nInnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。\nMyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\nMEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n索引索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法这种数据结构就是索引。\n在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。\n索引的优略 \n优势\n\n提高数据检索的效率，降低数据库的IO成本\n通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。\n\n劣势\n\n索引列也是要占用空间的。\n索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。\n\n索引结构\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\n\n\n\n索引结构\n描述\n\n\n\nB+Tree索引\n最常见的索引类型，大部分引擎都支持 B+ 树索引\n\n\nHash索引\n底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询\n\n\nR-tree(空间索引）\n空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少\n\n\nFull-text(全文索引)\n是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES\n\n\n不同的存储引擎对于索引结构的支持情况。\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+tree索引\n支持\n支持\n支持\n\n\nHash 索引\n不支持\n不支持\n支持\n\n\nR-tree 索引\n不支持\n支持\n不支持\n\n\nFull-text\n5.6版本之后支持\n支持\n不支持\n\n\n我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。\n二叉树\n​\t假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：\n\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\n\n所以，如果选择二叉树作为索引结构，会存在以下缺点：\n\n顺序插入时，会形成一个链表，查询性能大大降低。\n\n大数据量情况下，层级较深，检索速度慢。\n\n\n我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下\n\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\n\n大数据量情况下，层级较深，检索速度慢\n\n所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree。\nB-Tree\n​\tB树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（树的度数指的是一个节点的子节点个数）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：\n\n特点：\n\n5阶的B树，每一个节点最多存储4个key，对应5个指针。\n\n一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。\n\n在B树中，非叶子节点和叶子节点都会存放数据。\n\n\nB+Tree\n​\tB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：\n\n我们可以看到，两部分：\n\n绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。\n\n红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\n\n\nB+Tree 与 B-Tree相比主要有以下三点区别：\n\n所有的数据都会出现在叶子节点。\n\n叶子节点形成一个单向链表。\n\n非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\n\n\nMySQL中优化之后的B+Tree\n​\tMySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。\n\nHash\n​\tMySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。\n 结构\n​\t哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n特点\n\nHash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）\n\n无法利用索引完成排序操作\n\n查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引\n\n\n 支持hash的存储引擎\n在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。\n为什么InnoDB存储引擎选择使用B+tree索引结构?\n\n相对于二叉树，层级更少，搜索效率高；\n\n对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储\n\n的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；\n\n相对Hash索引，B+tree支持范围匹配及排序操作；\n\n\n索引分类在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。\n\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建, 只能有一个\nPRIMARY\n\n\n唯一索引\n避免同一个表中某数据列中的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值\n可以有多个\nFULLTEXT\n\n\n聚集索引&amp;二级索引\n在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引(Clustered Index)\n将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据\n必须有,而且只有一个\n\n\n二级索引(Secondary Index)\n将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键\n可以存在多个\n\n\n聚集索引选取规则:\n\n如果存在主键，主键索引就是聚集索引。\n\n如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。\n\n如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引\n\n\n聚集索引和二级索引的具体结构如下：\n\n聚集索引的叶子节点下挂的是这一行的数据 。\n二级索引的叶子节点下挂的是该字段值对应的主键值。\n当我们执行如下的SQL语句时，具体的查找过程是这样子的：\n\n\n由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。\n\n由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。\n\n最终拿到这一行的数据，直接返回即可。\n\n\n回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。\nInnoDB主键索引的B+tree高度为多高呢?\n一般是三层，如果树的高度为3，则可以存储 2200w 左右的记录\n索引语法创建索引\nCREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;\n\n查看索引\nSHOW INDEX FROM table_name ;\n\n 删除索引\nDROP INDEX index_name ON table_name ;\n\n 小案例：\ncreate table tb_user(\nid int primary key auto_increment comment '主键',\nname varchar(50) not null comment '用户名',\nphone varchar(11) not null comment '手机号',\nemail varchar(100) comment '邮箱',\nprofession varchar(11) comment '专业',\nage tinyint unsigned comment '年龄',\ngender char(1) comment '性别 , 1: 男, 2: 女',\nstatus char(1) comment '状态',\ncreatetime datetime comment '创建时间'\n) comment '系统用户表';\n\n-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引\ncreate index idx_user_name on tb_user(name);\n-- phone手机号是非空，且唯一，为该字段创建唯一索引\ncreate unique index idx_user_phone on tb_user(phone);\n--  为profession、age、status创建联合索引。\ncreate index idx_user_pro_age_sta on tb_user(profession,age,status);\n-- 为email建立合适的索引来提升查询效率\ncreate index idx_email on tb_user(email);\n\nSQL性能分析SQL执行频率\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次\n-- session 是查看当前会话 ;\n-- global 是查询全局数据 ;\nSHOW GLOBAL STATUS LIKE 'Com_______';\n-- Com_delete: 删除次数\n-- Com_select: 查询次数\n-- Com_update: 更新次数\n-- Com_insert: 插入次数\n\n通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。\n慢查询日志\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志\nMySQL的慢查询日志默认没有开启，可以查看一下系统变量 slow_query_log\n如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：\n# 开启MySQL慢日志查询开关\nslow_query_log=1\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\nlong_query_time=2\n\n\n\nprofile详情\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：\nSELECT @@have_profiling ;\n-- 可以通过set语句在session/global级别开启profiling\nset profiling = 1;\n\n开关已经打开了，接下来所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：\nselect * from tb_user;\nselect * from tb_user where id = 1;\nselect * from tb_user where name = '白起';\nselect count(*) from tb_sku;\n\n\n-- 查看每一条SQL的耗时基本情况\nshow profiles;\n\n-- 查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n\n-- 查看指定query_id的SQL语句CPU的使用情况\nshow profile cpu for query query_id;\n\nexplain\nEXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n语法:\n-- 直接在select语句之前加上关键字 explain / desc\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;\n\nExplain 执行计划中各个字段的含义:\n\n\n\n字段\n含义\n\n\n\nid\nselect查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)\n\n\nselect_type\n表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等\n\n\ntype\n表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。\n\n\npossible_key\n显示可能应用在这张表上的索引，一个或多个。\n\n\nkey\n实际使用的索引，如果为NULL，则没有使用索引。\n\n\nkey_len\n表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\n\n\nrows\nMySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\n\n\nfiltered\n表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。\n\n\n索引使用tb_user 表所创建的索引\n\n最左前缀法则\n如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)\n在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。 \nexplain select * from tb_user where profession = '软件工程' and age = 31 and status= '0';\n\n\nexplain select * from tb_user where profession = '软件工程' and age = 31;\n\n\nexplain select * from tb_user where profession = '软件工程';\n\n\n只要联合索引最左边的字段 profession存在，索引就生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5。\nexplain select * from tb_user where age = 31 and status = '0';\n\n\nexplain select * from tb_user where status = '0';\n\n\n上面的这两组测试，索引并没有生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在\nexplain select * from tb_user where profession = '软件工程' and status = '0';\n\n\n存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。\n-- 打乱顺序测试\nexplain select * from tb_user where age = 31 and status = '0' and profession = '软件工程'；\n\n\n是完全满足最左前缀法则的，索引长度54，联合索引是生效的。\n最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。\n范围查询\n联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。\nexplain select * from tb_user where profession = '软件工程' and age > 30 and status = '0';\n\n\n范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，说明范围查询右边的status字段是没有走索引。\nexplain select * from tb_user where profession = '软件工程' and age >= 30 and status = '0';\n\n\n当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。\n所以，尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt;\n索引失效情况\n在索引列上进行运算操作， 索引将失效。\n在tb_user表中，还有一个phone字段的单列索引。\n当根据phone字段进行等值匹配查询时, 索引生效。\nexplain select * from tb_user where phone = '17799990015';\n\n\n 当根据phone字段进行函数运算操作之后，索引失效。·\nexplain select * from tb_user where substring(phone,10,2) = '15';\n\n\n字符串不加引号\n字符串类型字段使用时，不加引号，索引将失效。\nexplain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';\nexplain select * from tb_user where profession = '软件工程' and age = 31 and status = 0;\n\n\nexplain select * from tb_user where phone = '17799990015';\nexplain select * from tb_user where phone = 17799990015;\n\n\n如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效\n模糊查询\n仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效\n根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响\nexplain select * from tb_user where profession like '软件%';\nexplain select * from tb_user where profession like '%工程';\nexplain select * from tb_user where profession like '%工%';\n\n\n在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效\n or连接条件\n用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\nexplain select * from tb_user where id = 10 or age = 23;\nexplain select * from tb_user where phone = '17799990017' or age = 23;\n\n\n由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。\n然后，我们可以对age字段建立索引。\ncreate index idx_user_age on tb_user(age);\n\n我们再次执行上述的SQL语句，看看前后执行计划的变化。\nexplain select * from tb_user where id = 10 or age = 23;\nexplain select * from tb_user where phone = '17799990017' or age = 23;\n\n\n当or连接的条件，左右两侧字段都有索引时，索引才会生效。\n 数据分布影响\n如果MySQL评估使用索引比全表更慢，则不使用索引。\nselect * from tb_user where phone >= '17799990005';\nselect * from tb_user where phone >= '17799990015';\n\n\n\n相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样。\n就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。\nis null 与 is not null 操作\nexplain select * from tb_user where profession is null;\nexplain select * from tb_user where profession is not null;\n\n\n将profession字段值全部更新为null，再次执行上述的两条SQL，查看SQL语句的执行计划。\nupdate tb_user set profession = null;\nexplain select * from tb_user where profession is null;\nexplain select * from tb_user where profession is not null;\n\n\n一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。\nSQL提示目前tb_user表索引情况如下\n\nidx_user_age, idx_email 这两个索引直接删除\ndrop index idx_user_age on tb_user;\ndrop index idx_email on tb_user;\n\n执行SQL，查询走了联合索引\nexplain select * from tb_user where profession = '软件工程';\n\n\n创建profession的单列索引\ncreate index idx_user_pro on tb_user(profession);\n\n再次执行SQL语句，查看执行计划，看看到底走哪个索引\nexplain select * from tb_user where profession &#x3D; &#39;软件工程&#39;;\n\n\n我们可以看到，possible_keys中 idx_user_pro_age_sta，idx_user_pro 这两个索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。\n此时就可以借助于MySQL的SQL提示来完成来指定使用哪个索引\n use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。\nexplain select * from tb_user use index(idx_user_pro) where profession &#x3D; &#39;软件工程&#39;;\n\n\n ignore index ： 忽略指定的索引。\nexplain select * from tb_user ignore index(idx_user_pro) where profession &#x3D; &#39;软件工程&#39;;\n\n\n force index ： 强制使用索引。\nexplain select * from tb_user force index(idx_user_pro_age_sta) where profession &#x3D;\n&#39;软件工程&#39;;\n\n\n覆盖索引\n覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。\n尽量使用覆盖索引，减少select *\n查看一组SQL的执行计划\nexplain select id, profession from tb_user where profession = '软件工程' and age =\n31 and status = '0' ;\n\nexplain select id,profession,age, status from tb_user where profession = '软件工程'\nand age = 31 and status = '0' ;\n\nexplain select id,profession,age, status, name from tb_user where profession = '软\n件工程' and age = 31 and status = '0' ;\n\nexplain select * from tb_user where profession = '软件工程' and age = 31 and status\n= '0';\n\n执行结果为:\n\n这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。\n\n\n\nExtra\n含义\n\n\n\nUsing where; Using Index\n查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\n\n\nUsing index condition\n查找使用了索引，但是需要回表查询数据\n\n\n因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）\n什么是覆盖索引，什么是回表查询\n 表结构及索引示意图\n\nid是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。\n执行SQL :\nselect * from tb_user where id &#x3D; 2;\n\n\n根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。\n执行SQL\nselet id,name from tb_user where name &#x3D; &#39;Arm&#39;\n\n\n虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。\n执行SQL\nselet id,name,gender from tb_user where name &#x3D; &#39;Arm&#39;;\n\n\n由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点\n前缀索引\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n语法\ncreate index idx_xxxx on table_name(column(n)) ;\n\n为tb_user表的email字段，建立长度为5的前缀索引。\ncreate index idx_email_5 on tb_user(email(5));\n\n\n前缀长度\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\nselect count(distinct email) &#x2F; count(*) from tb_user ;\nselect count(distinct substring(email,1,5)) &#x2F; count(*) from tb_user ;\n\n前缀索引的查询流程\n\n单列索引与联合索引\n单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\ntb_user 表中的索引情况\n\n执行一条SQL语句，看看其执行计划：\nexplain select id,phone,name from tb_stu where phone &#x3D; &#39;17799990010&#39; and name &#x3D; &#39;韩信&#39;;\n\n在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。\n再创建一个phone和name字段的联合索引来查询一下执行计划\ncreate unique index idx_user_phone_name on tb_user(phone,name);\n\nexplain select id,phone,name from tb_stu where phone &#x3D; &#39;17799990010&#39; and name &#x3D; &#39;韩信&#39;;\n\n\n如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n联合索引具体的结构示意图如下：\n\n索引设计原则\n针对于数据量较大，且查询比较频繁的表建立索引。\n\n针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\n\n尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n\n如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。\n\n尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。\n\n\n","slug":"MySQL-存储引擎-索引","date":"2023-05-18T02:31:14.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"c1f6d722cc4602038235f2e7924e8ff2","title":"MySQL事务","content":"事务事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系\n统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐\n式的提交事务。\n事务操作未控制事务\n测试正常情况\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n可以看到数据操作前后是一致的。\n测试异常情况\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n出错了....\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n\n(出错了….) 这句话不符合SQL语法,执行就会报错，检查最终的数据情况, 发现数据在操作前后不一致了。\n控制事务\n查看&#x2F;设置事务提交方式\nselect @@autocommit;\n-- autocommit为1标识开启事务自动提交   为0表示手动提交事务\nset @@autocommit = 0;\n\n提交事务\ncommit;\n\n回滚事务\nrollback;\n\n开启事务\nstart transaction;\n-- 或者\nbegin;\n\n转账案例：\n-- 开启事务\nstart transaction\n-- 1. 查询张三余额\nselect * from account where name = '张三';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = '张三';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = '李四';\n-- 如果正常执行完毕, 则提交事务\ncommit;\n-- 如果执行过程中报错, 则回滚事务\n-- rollback;\n\n事务四大特性原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\n一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n上述就是事务的四大特性，简称ACID。\n并发事务问题\n 赃读：一个事务读到另外一个事务还没有提交的数据。\n\n比如B读取到了A未提交的数据。\n不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读\n\n 事务A两次读取同一条记录，但是读取到的数据却是不一样的。\n 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。\n\n事务隔离级别\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nRead uncommitted\n存在\n存在\n存在\n\n\nRead committed\n不存在\n存在\n存在\n\n\nRepeatable Read(default)\n不存在\n不存在\n存在\n\n\nSerializable\n不存在\n不存在\n不存在\n\n\n 查看事务隔离级别\nselect @@TRANSACTION_IOSLATION;\n\n设置事务隔离级别\nSET [SESSION | GLOBAL] TRANSACTION IOSLATION LEVEL\n[READ COMMITTED | READ UNCOMMITTED | REPEATABLE READ | SERIALIZABLE]\n\n事务隔离级别越高，数据越安全，但是性能越低。\n","slug":"MySQL-事务","date":"2023-05-17T13:51:38.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"f293b2fcfae54b8509d50db2914ed7a0","title":"MySQL_约束_多表查询","content":"约束概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n目的：保证数据库中数据的正确、有效性和完整性。\n\n\n\n约束\n描述\n关键词\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一、不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束(8.0.16版本之后)\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来让两张表的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。\ncreate table tb_user(\nid int primary key auto_increment comment 'ID唯一标识',\nname varchar(10) not null unique comment '姓名',\nage int check (age between 0 and 120) comment '年龄',\nstatus char(1) default 1 comment '状态',\ngender char(1) comment '性别'\n)comment '学生表';\n\n外键约束\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。\ncreate table dept(\n\tid int auto_increment primary key comment 'ID',\n    name varchar(50) not null comment '部门名称',    \n)comment '部门表';\n\nCREATE TABLE `emp` (\n  `id` int DEFAULT NULL COMMENT '编号',\n  `workno` varchar(10) DEFAULT NULL,\n  `name` varchar(10) DEFAULT NULL COMMENT '姓名',\n  `gender` char(1) DEFAULT NULL COMMENT '性别',\n  `age` tinyint unsigned DEFAULT NULL COMMENT '年龄',\n  `idcard` char(18) DEFAULT NULL COMMENT '身份证号',\n  `workaddress` varchar(50) DEFAULT NULL COMMENT '工作地址',\n  `entrydate` date DEFAULT NULL COMMENT '入职时间',\n  `dept_id` int DEFAULT '1' COMMENT '部门id'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表'\n\n为emp表的dept_id字段添加外键约束,关联dept表的主键id。\nalter table emp add constraint fk_emp_dept foreign key(dept_id) references dept(id);\n\n命令中的 “alter table emp” 表示将要修改的表是 emp，“add constraint” 表示添加一个约束，“fk_emp_dept_id” 是这个约束的名称，“foreign key (dept_id)” 表示这是一个外键约束，关联的列是 emp 表中的 dept_id 列，“references dept(id)” 表示外键引用了 dept 表的 id 列。这个约束的作用是确保 emp 表中的 dept_id 值必须在 dept 表的 id 列中存在，从而保证了参照完整性。\n添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。\n1451 - Cannot delete or update a parent row: a foreign key constraint fails (hj.emp, CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) REFERENCES dept (id))\n 删除外键\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\nalter table emp drop foreign key fk_emp_dept;\n\n删除&#x2F;更新行为\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除&#x2F;更新行为。\n具体的删除&#x2F;更新行为有以下几种:\n\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 RESTRICT 一致) 默认行为\n\n\nRESTRICT\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 NO ACTION 一致) 默认行为\n\n\nCASCADE\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录。\n\n\nSET NULL\n当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。\n\n\nSET DEFAULT\n父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)\n\n\n具体语法为:\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\n主表名 (主表字段名) ON UPDATE 行为 ON DELETE 行为;\n\n小案例：CASCADE行为下  修改父表id为1的记录，将id修改为6\nalter table emp add constraint kf_emp_dept_id foreign key (dept_id) references dept(id)\non update cascade on delete cascade;\n\nupdate dept set id = 6 where id = 1;\n\ndelete form dept where id = 6;\n\n我们发现:\n原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。\n父表的数据删除成功了，但是子表中关联的记录也被级联删除了。\n SET NULL\nalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id)\non update set null on delete set null;\n\ndelete from dept where id = 3;\n\nupdate dept set id = 7 where id = 5;\n\n父表的记录是可以正常的删除的，父表的数据删除&#x2F;跟新之后，再打开子表 emp，我们发现子表emp的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。\n多表查询多表关系一对多(多对一) \n如：部门 与 员工的关系，一个部门对应多个员工，一个员工对应一个部门\n实现: 在多的一方建立外键，指向一的一方的主键\ncreate table emp(\nid int auto_increment comment 'ID' primary key,\nname varchar(50) not null comment '姓名',\nage int comment '年龄',\njob varchar(20) comment '职位',\nsalary int comment '薪资',\nentrydate date comment '入职时间',\nmanagerid int comment '直属领导ID',\ndept_id int comment '部门ID',\nconstraint fk_emp_dept_id foreign key (dept_id) references dept(id)\non update cascade on delete cascade\n)comment '员工表';\n\ncreate table dept(\nid int auto_increment comment 'ID' primary key,\nname varchar(50) not null comment '部门名称'\n)comment '部门表';\n\n\n多对多\n如： 学生 与 课程的关系， 一个学生可以选修多门课程，一门课程也可以供多个学生选择\n实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\nreate table course(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '课程名称'\n) comment '课程表';\n\n\ncreate table tb_user(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '姓名',\nage int comment '年龄',\ngender char(1) comment '1: 男 , 2: 女',\nphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\n\ncreate table tb_user_edu(\nid int auto_increment primary key comment '主键ID',\ndegree varchar(20) comment '学历',\nmajor varchar(50) comment '专业',\nprimaryschool varchar(50) comment '小学',\nmiddleschool varchar(50) comment '中学',\nuniversity varchar(50) comment '大学',\nuserid int unique comment '用户ID',\nconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\n\n一对一\n如：用户 与 用户详情的关系， 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\ncreate table tb_user(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '姓名',\nage int comment '年龄',\ngender char(1) comment '1: 男 , 2: 女',\nphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\ncreate table tb_user_edu(\nid int auto_increment primary key comment '主键ID',\ndegree varchar(20) comment '学历',\nmajor varchar(50) comment '专业',\nprimaryschool varchar(50) comment '小学',\nmiddleschool varchar(50) comment '中学',\nuniversity varchar(50) comment '大学',\nuserid int unique comment '用户ID',\nconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\n多表查询概述要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept;\n 具体的执行结果如下:\n我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录(17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单介绍下笛卡尔积。\n笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\nselect * from emp , dept where emp.dept_id = dept.id;\n\n连接查询分类\n​\t内连接：相当于查询A、B交集部分数据 \n​\t外连接：\n​\t\t左外连接：查询左表所有数据，以及两张表交集部分数据\n​\t\t右外连接：查询右表所有数据，以及两张表交集部分数据\n​\t自连接：当前表与自身的连接查询，自连接必须使用表别名\n内连接\n内连接的语法分为两种: 隐式内连接、显式内连接。\n隐式内连接\nSELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;\n\n显式内连接\nSELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;\n\n小案例：查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)\n -- 隐式内连接实现\nselect emp.name, dept.name from emp,dept where emp.dept_id = dept.id;\n\nselect emp.name, dept.name from emp join dept on emp.dept_id = dept.id;\n\n外连接\n外连接分为两种，分别是：左外连接 和 右外连接\n具体的语法结构为：\n左外连接 \n相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\nSELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;\n\n 小案例：查询emp表的所有数据, 和对应的部门信息\n分析：要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\nselect e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;\n\nselect e.*, d.name from emp e left join dept d on e.dept_id = d.id;\n\n小案例： 查询dept表的所有数据, 和对应的员工信息(右外连接)\nselect dept.*, emp.* from emp right outer join dept on emp.dept_id = dept.id;\n\n左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n自连接\n顾名思义，就是自己连接自己，也就是把一张表连接查询多次。\n查询语法\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;\n\n小案例：查询员工 及其 所属领导的名字，如果员工没有领导, 也需要查询出来\nselect a.name, b.name from emp a left join emp b on a.managerid = b.id;\n\n在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。\n联合查询\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n语法：\nSELECT 字段列表 FROM 表A ...\nUNION [ ALL ]\nSELECT 字段列表 FROM 表B ....;\n\n对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。如果多条查询语句查询出来的结果，字段数量不一致，在进行union&#x2F;union all联合查询时，将会报错\nunion all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\n子查询\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询\n语法\nSELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );\n\n子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。\n根据子查询位置，分为：WHERE之后\t\t FROM之后\t\tSELECT之后\n标量子查询 ：子查询返回的结果是单个值\t\t常用的操作符：&#x3D;   &lt;&gt;   &gt;   &gt;&#x3D;   &lt;  &lt;&#x3D; \n案例：查询 “销售部” 的所有员工信息\nselect * from emp where dept_id = (select id from dept where name = '销售部');\n\n列子查询\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n\n\n操作符\n描述\n\n\n\nIN\n在指定的集合范围之内，多选一\n\n\nNOT IN\n不在指定的集合范围之内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n小案例：查询 “销售部” 和 “市场部” 的所有员工信息\nselect * from emp where id in\n(select id from dept where name = '销售部' or name = '市场部');\n\n 小案例：查询比 财务部 所有人工资都高的员工信息\nselect * from emp where salary > all ( select salary from emp where dept_id =\n(select id from dept where name = '财务部') );\n\n 小案例：查询比研发部其中任意一人工资高的员工信息\nselect * from emp where salary > any(select salary from emp where dept_id = \n(select id from dept where name = '研发部'));\n\n行子查询\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。\n常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN\n小案例：查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;\nselect * from emp where (salary,managerid) = (select salary, managerid from emp where name ='张无忌');\n\n表子查询\n子查询返回的结果是多行多列，这种子查询称为表子查询。常用的操作符：IN\n小案例：查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息\nselect * from emp where (job,salary) in ( select job, salary from emp where name =\n'鹿杖客' or name = '宋远桥' );\n\n小案例：查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息\n````\n\n 小案例：查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n\n小案例： 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）\n\n\n小案例：查询拥有员工的部门ID、部门名称\n\n\n小案例：查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)\n\n\n小案例：查询所有员工的工资等级\n\n\n小案例：查询 &quot;研发部&quot; 所有员工的信息及 工资等级\n\n\n小案例： 查询 &quot;研发部&quot; 员工的平均工资\n\n\n小案例： 查询工资比 &quot;灭绝&quot; 高的员工信息。\n\n\n小案例： 查询比平均薪资高的员工信息\n\n\n小案例：查询低于本部门平均工资的员工信息\n\n\n小案例：查询所有的部门信息, 并统计部门的员工人数\n\n\n小案例：查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n\n\n","slug":"MySQL-约束-多表联查","date":"2023-05-16T13:40:42.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"8f9e88b96addebc57d8b075bdae2d985","title":"MySQL_DCL_函数","content":"DCLData Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。\n管理用户查询用户\nselect * from mysql.user;\n\n\n其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。\n创建用户\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n修改用户密码\nALTER USER '用户名'@'主机号' IDENTIFIED WITH mysql_native_password BY '新密码';\n\n删除用户\nDROP USER '用户名'@'主机名';\n\n在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n主机名可以使用 % 通配。\n这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。\n权限控制\nMySQL中定义了很多种权限，但是常用的就以下几种\n\n\n\n权限\n说明\n\n\n\nALL,  ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\n\n授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n\n撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n\n 多个权限之间，使用逗号分隔\n授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\nSHOW GRANTS FOR 'hj'@'%';\n-- 运行结果：\n-- GRANT ALL PRIVILEGES ON `hj`.* TO `hj`@`%`\n-- 该命令为 MySQL 的授权语法，意思是授权用户 hj 在任何主机地址上（%）对数据库 hj 中所有表拥有所有权限（ALL PRIVILEGES）。可以执行如下 SQL 命令进行授权\n-- GRANT USAGE ON *.* TO `hj`@`%`\n-- 该命令为 MySQL 的授权语法，意思是授权用户 `hj` 在任何主机地址上（`%`）对所有的数据库、表、函数、存储过程等对象都拥有使用权限（`USAGE`）。\n\n函数MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。\n字符串函数\n\n\n\n函数\n功能\n\n\n\nCONCAT(S1,S2,…Sn)\n字符串拼接，将S1，S2，… Sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串str全部转为小写\n\n\nUPPER(str)\n将字符串str全部转为大写\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str,start,len)\n返回从字符串str从start位置起的len个长度的字符串\n\n\n concat : 字符串拼接\nselect concat('Hello' , ' MySQL');\n\nlpad : 左填充\nselect lpad('01', 5, '-');\n\n rpad : 右填充\nselect rpad('01',5,'23456789');\n-- 01234\nselect rpad('01',5,'23');\n-- 01232\n\n trim : 去除空格\nselect trim(' Hello MySQL ');\n-- 'Hello MySQL'\n\n substring : 截取子字符串\nselect substring('Hello MySQL',1,5);\n-- Hello\n\n案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001。\nupdate workno = lpad(workno, 5, '0');\n\n数值函数\n\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x,y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0~1内的随机数\n\n\nROUND(x,y)\n求参数x的四舍五入的值，保留y位小数\n\n\n ceil：向上取整\nselect ceil(1.1);\n\n floor：向下取整\nselect floor(1.9);\n\nmod：取模\nselect mod(7,4);\n\n rand：获取随机数\nselect rand();\n\nround：四舍五入\nselect round(2.344,2);\n\n小案例：通过数据库的函数，生成一个六位数的随机验证码。\nselect lpad('',6,substring(concat(rand(),''),3,9)) code;\n\n日期函数\n\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n获取指定date的年份\n\n\nMONTH(date)\n获取指定date的月份\n\n\nDAY(date)\n获取指定date的日期\n\n\nDATE_ADD(date,INTERVAL expr type)\n返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1,date2)\n返回起始时间date1 和 结束时间date2之间的天数\n\n\n curdate：当前日期\nselect curdate();\n\n curtime：当前时间\nselect curtime();\n\n now：当前日期和时间\nselect now();\n\nYEAR , MONTH , DAY：当前年、月、日\nselect year(now());\nselect month(now());\nselect day(now());\n\ndate_add：增加指定的时间间隔\nselect date_add(now(),INTERVAL 70 YEAR);\nselect date_add('2023-05-16', INTERVAL 29 DAY);\n\n datediff：获取两个日期相差的天数\nselect datediff('2023-05-16','2023-06-14');\n\n小案例：查询所有员工的入职天数，并根据入职天数倒序排序。\nselect name , datediff(curdate(), entrydate) workday from emp order by workday desc;\n\n流程函数\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(value1, value2)\n如果value1不为空，返回value1，否则返回value2\n\n\nCASE WHEN [vall] THEN [res1] … ELSE [default] END\n如果val1为true，返回res1，… 否则返回default默认值\n\n\nCASE [expr] WHEN [val1] THEN [res1] …  ELSE [default] END\n如果expr的值等于val1，返回res1，… 否则返回default默认值\n\n\n if\nselect if(false, 'Ok', 'Error');\n-- 默认的false值还有 0, '', null\n\n ifnull\nselect ifnull('Ok','Default');\nselect ifnull('','Default');\nselect ifnull(null,'Default')\n-- 只有null会被识别为空\n\n case when then else end\n查询emp表的员工姓名和工作地址 (北京&#x2F;上海   替换成   一线城市 , 其他   替换成   二线城市)\nselect name, (case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end) '工作地点' from emp;\n\n案例：将学生的各个学科的成绩分等级展示，大于等于85 为优秀，(85，60]为及格，否则不及格\ncreate table score(\nid int comment 'ID',\nname varchar(20) comment '姓名',\nmath  tinyint unsigned comment '数学',\nenglish tinyint unsigned comment '英语',\nchinese tinyint unsigned comment '语文'\n) comment '学生成绩表';\ninsert into score(id, name, math, english, chinese) VALUES \n(1, 'Tom', 67, 88, 95),\n (2, 'Rose' , 23, 66, 90),\n (3, 'Jack', 56, 98, 76);\n \n select name , \n(case when math >= 85 then '优秀' when math >=60 then '及格' else '不及格' end ) math_score,\n(case when english >= 85 then '优秀' when english >=60 then '及格' else '不及格' end ) english_score,\n(case when chinese >= 85 then '优秀' when chinese >=60 then '及格' else '不及格' end ) chinese_score \n from score;\n\n","slug":"MySQL-DCL-函数","date":"2023-05-16T08:56:15.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"b886b366f3cb34006709f66f49ec6b62","title":"状态模式","content":"状态模式它将对象的行为与其内部状态分离开来，使得对象可以根据其内部状态的变化而改变其行为。状态模式通过将状态的切换封装在状态类中，使得状态转换具有可扩展性和灵活性，并避免了由于状态转换所带来的“if-else”嵌套过多的问题。\n状态模式的基本机制是将状态抽象为一个接口或者抽象类，每个具体状态类都实现该接口或者抽象类，并且在具体状态类中实现其对应的行为。在状态模式中，对象的状态切换是通过改变对象持有的状态实例来实现的。当对象需要状态转换时，它会委托当前状态实例处理状态转换，从而使得对象的行为和状态相互解耦，具有更好的可扩展性和灵活性。\n状态模式符合“单一职责原则”和“开闭原则”两个软件设计原则。其中，“单一职责原则”指一个类只负责一个职责，状态模式将状态抽象为一个独立的类，使得每个状态类只负责处理一个状态，从而使得每个类都具有单一的职责；“开闭原则”指对扩展开放，对修改关闭，状态模式通过增加新的状态类来扩展状态转换过程，而不需要修改原有的代码，从而符合“开闭原则”。\n状态模式存在三个角色：\n\n环境（Context）角色：它定义了客户端所感兴趣的接口，通常包含一个状态实例并维护一个指向具体状态对象的引用。这个上下文类可以处理请求并将其委托给当前状态对象。\n抽象状态（State）角色：它把所有具体状态类的共同点抽象出来，定义了这些共同点对应的接口或抽象类，并在其中定义了该状态下对象的行为。\n具体状态（Concrete State）角色：它实现了抽象状态的接口或抽象类，并且定义了在该状态下对象的行为。\n\n假设我们要设计一个电灯类，电灯可以处于3个不同的状态：\n关闭状态、开启状态和闪烁状态。电灯类的代码如下：\npublic class Light &#123;\n    private State state;\n\n    public Light() &#123;\n        this.state = new OffState();\n    &#125;\n\n    public void setState(State state) &#123;\n        this.state = state;\n    &#125;\n\n    public void turnOn() &#123;\n        state.turnOn(this);\n    &#125;\n\n    public void turnOff() &#123;\n        state.turnOff(this);\n    &#125;\n\n    public void blink() &#123;\n        state.blink(this);\n    &#125;\n&#125;\n\n在这里，我们将电灯的状态抽象成了接口State，然后定义了3个具体的状态类：OffState、OnState和BlinkState，这3个类实现了State接口。\npublic interface State &#123;\n    void turnOn(Light light);\n    void turnOff(Light light);\n    void blink(Light light);\n&#125;\n\npublic class OffState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯开启\");\n        light.setState(new OnState());\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯已经关闭，不能再关闭\");\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯未开启，不能闪烁\");\n    &#125;\n&#125;\n\npublic class OnState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯已经开启，不需要再开启\");\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯关闭\");\n        light.setState(new OffState());\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯开始闪烁\");\n        light.setState(new BlinkState());\n    &#125;\n&#125;\n\npublic class BlinkState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯已经开启，不需要再开启\");\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯关闭\");\n        light.setState(new OffState());\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯停止闪烁\");\n        light.setState(new OnState());\n    &#125;\n&#125;\n\n在电灯类中，引入了一个State类型的变量state，表示当前电灯处于哪种状态。当电灯需要改变状态时，它会调用state的对应方法，然后将state设为新的状态。例如，当电灯需要开启时，它将调用OnState的turnOn方法，并将state设为OnState实例。\n下面是一个应用电灯类的例子：\npublic static void main(String[] args) &#123;\n    Light light = new Light();\n    light.turnOn();  // 电灯开启\n    light.turnOn();  // 电灯已经开启，不需要再开启\n    light.blink();   // 电灯开始闪烁\n    light.turnOff(); // 电灯关闭\n    light.blink();   // 电灯未开启，不能闪烁\n    light.turnOff(); // 电灯已经关闭，不能再关闭\n&#125;\n\n在这个例子中，我们首先创建了一个电灯实例light，然后通过调用它的turnOn、blink和turnOff方法，改变了它的状态，并输出了相应的信息。\n这个例子可以帮助我们理解状态模式的基本用法和原理，同时也能让我们感受到状态模式所提供的可扩展性和灵活性。当需要新增或修改状态时，我们只需要添加或修改相应的状态类，而不需要修改电灯类的代码，从而大大降低了代码的耦合度和维护成本。\n","slug":"状态模式","date":"2023-05-15T10:11:38.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"ab4a664e2e3638cd67bb057e6ee644aa","title":"迭代器模式","content":"迭代器模式它提供一种方便的方式来访问并遍历集合对象的元素，而无需暴露集合的内部表示。该模式将遍历集合的过程与集合的实现分离开来，使得可以在不影响客户端代码的情况下更改集合的内部实现。\n迭代器模式包括以下几个元素：\n1.迭代器接口（Iterator）：定义了用于访问和遍历集合元素的标准方法。\n2.具体迭代器（Concrete Iterator）：实现了Iterator接口，用于遍历集合中的元素。\n3.集合接口（Aggregate）：定义了一组用于集合管理和访问元素的方法。\n4.具体集合（Concrete Aggregate）：实现了Aggregate接口，用于管理和访问元素集合。\n通过使用迭代器模式，我们可以将遍历和集合的实现分离开来，从而使得可以方便地对集合进行修改而不会影响遍历的过程。另外，通过提供不同的迭代器实现，我们可以很容易地实现一些高级的遍历需求，比如倒序遍历、过滤遍历等。\n迭代器模式符合以下软件设计原则：\n1.单一职责原则：该模式将集合的遍历与集合本身的实现分离开来，保证每个对象只负责自己的单一职责。\n2.开闭原则：新增一种集合类型或修改现有集合类型的实现方式都不会影响到已有的迭代器实现，因此该模式对修改关闭，对扩展开放。\n3.依赖倒置原则：在迭代器模式中，客户端只依赖于迭代器接口，而不依赖于集合的内部表示，从而将高层次模块从底层模块中解耦出来。\n4.迪米特原则：该模式通过将遍历集合的访问方法委托给迭代器对象来遵循迪米特原则，即一个对象应该对其他对象有最少的了解。\n以下是一个简单的Java案例，演示了迭代器的使用方式：\n//迭代器接口\ninterface Iterator&lt;T> &#123;\n    boolean hasNext();\n    T next();\n&#125;\n\n//集合接口\ninterface Aggregate&lt;T> &#123;\n    void add(T element);\n    void remove(T element);\n    Iterator&lt;T> iterator();\n&#125;\n\n//具体集合\nclass MyList&lt;T> implements Aggregate&lt;T> &#123;\n    private T[] elements;\n    private int size;\n    private int capacity;\n\n    public MyList(int capacity) &#123;\n        this.elements = (T[]) new Object[capacity];\n        this.size = 0;\n        this.capacity = capacity;\n    &#125;\n\n    public void add(T element) &#123;\n        if(size &lt; capacity) &#123;\n            elements[size] = element;\n            size++;\n        &#125;\n    &#125;\n\n    public void remove(T element) &#123;\n        for(int i = 0; i &lt; size; i++) &#123;\n            if(elements[i].equals(element)) &#123;\n                for(int j = i; j &lt; size - 1; j++) &#123;\n                    elements[j] = elements[j+1];\n                &#125;\n                size--;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    public Iterator&lt;T> iterator() &#123;\n        return new MyListIterator();\n    &#125;\n\n    //具体迭代器\n    private class MyListIterator implements Iterator&lt;T> &#123;\n        private int index = 0;\n\n        public boolean hasNext() &#123;\n            return index &lt; size;\n        &#125;\n\n        public T next() &#123;\n            T element = elements[index];\n            index++;\n            return element;\n        &#125;\n    &#125;\n&#125;\n\n//客户端代码\npublic class IteratorDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建一个列表\n        MyList&lt;String> list = new MyList&lt;>(5);\n        list.add(\"One\");\n        list.add(\"Two\");\n        list.add(\"Three\");\n        list.add(\"Four\");\n        list.add(\"Five\");\n\n        // 遍历列表中的元素\n            Iterator&lt;String> iterator = list.iterator();\n    while (iterator.hasNext()) &#123;\n        String element = iterator.next();\n        System.out.println(\"Element: \" + element);\n    &#125;\n&#125;\n\n 在上述示例中，我们定义了一个具体集合类MyList，该类实现了Aggregate接口，并包含了一个具体迭代器类MyListIterator。我们还定义了客户端代码用于测试集合的遍历，创建了一个列表并添加了元素，然后使用迭代器遍历列表中的每一个元素。执行该程序，会输出以下结果： \nElement: One\nElement: Two\nElement: Three\nElement: Four\nElement: Five\n\n在迭代器模式中，集合和迭代器是紧密相关联的。集合提供了快速访问迭代器的方法，而迭代器则提供了遍历整个集合的方法。这样，我们可以通过创建不同的迭代器对象来实现不同的遍历方式，而不会影响到集合的底层实现。因此，迭代器模式非常适合于需要访问和遍历集合元素的场景，可以提供一种清晰且灵活的解决方案。\n","slug":"迭代器模式","date":"2023-05-15T09:44:26.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"35b7e7d45f0bf660fac88351c60754e3","title":"命令模式","content":"命令模式它允许将请求封装为对象，从而使得请求的发送者和接收者解耦，同时可实现请求的队列化、撤销和恢复。\n该模式的关键点是将请求与实现解耦并引入命令对象，以便将请求发送给不同的对象，并可随时进行撤销和恢复。通常情况下，命令对象包含执行请求的接收者、请求数据以及实现该请求的方法。\n命令模式包括以下几个元素：\n1.命令接口（Command）：此接口定义了一个execute()方法，当Command对象被调用时，该方法会调用具体命令的execute()方法。\n2.具体命令类（Concrete Command）：此类实现了Command接口的execute()方法，它包含了一个Receiver对象，并包含了执行所需的所有参数。\n3.接收者（Receiver）：该组件包含了实现命令所需的代码和逻辑。\n4.调用者（Invoker）：该组件负责发送命令，通常会包含一个Command对象的引用。它还可维护一个命令历史记录，以便支持撤销和恢复操作。\n5.客户端（Client）：该组件创建具体命令对象，并将其传递给调用者对象以执行所需的操作。\n通过使用命令模式，我们可以将请求者与实现者彻底解耦，使得请求者无需知道具体执行者的存在和实现细节，并且可以轻松地对请求进行控制、评估、测试和管理。同时，命令模式还能实现请求的撤销和恢复，大大提升系统的可靠性和可维护性。\n以下是一个简单的Java案例，演示了命令模式的使用方式：\n//命令接口\npublic interface Command &#123;\n    void execute();\n&#125;\n\n//具体命令类: 打开文件命令\npublic class OpenCommand implements Command &#123;\n    private Receiver receiver;\n\n    public OpenCommand(Receiver receiver) &#123;\n        this.receiver = receiver;\n    &#125;\n\n    public void execute() &#123;\n        receiver.open();\n    &#125;\n&#125;\n\n//具体命令类: 关闭文件命令\npublic class CloseCommand implements Command &#123;\n    private Receiver receiver;\n\n    public CloseCommand(Receiver receiver) &#123;\n        this.receiver = receiver;\n    &#125;\n\n    public void execute() &#123;\n        receiver.close();\n    &#125;\n&#125;\n\n//接收者：文件编辑器\npublic class Receiver &#123;\n    public void open() &#123;\n        System.out.println(\"打开文件\");\n    &#125;\n\n    public void close() &#123;\n        System.out.println(\"关闭文件\");\n    &#125;\n&#125;\n\n//调用者：文本编辑器\npublic class Invoker &#123;\n    private Command openCommand;\n    private Command closeCommand;\n\n    public Invoker(Command openCommand, Command closeCommand) &#123;\n        this.openCommand = openCommand;\n        this.closeCommand = closeCommand;\n    &#125;\n\n    public void clickOpen() &#123;\n        openCommand.execute();\n    &#125;\n\n    public void clickClose() &#123;\n        closeCommand.execute();\n    &#125;\n&#125;\n\n//客户端代码\npublic class CommandDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建接收者\n        Receiver receiver = new Receiver();\n\n        // 创建具体命令对象\n        Command openCommand = new OpenCommand(receiver);\n        Command closeCommand = new CloseCommand(receiver);\n\n        // 创建调用者并将具体命令对象传给它\n        Invoker invoker = new Invoker(openCommand, closeCommand);\n\n        // 点击打开文件按钮\n        invoker.clickOpen();\n\n        // 点击关闭文件按钮\n        invoker.clickClose();\n    &#125;\n&#125;\n\n在上述示例中，我们定义了命令接口Command及两个具体命令类OpenCommand和CloseCommand，对应于文件的打开和关闭操作。我们还定义了一个接收者Receiver，表示文件编辑器，拥有打开和关闭文件的操作。Invoker负责调用具体命令对象执行对应的操作，即点击打开或关闭文件按钮。客户端代码创建具体命令对象和调用者，并传入。\n","slug":"命令模式","date":"2023-05-15T09:17:29.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"d75c20296e97428894e8c62bab0f606e","title":"访问者模式","content":"访问者模式它将算法封装到独立的对象中，使其可以在不修改现有对象结构的情况下增加新的操作。访问者模式的核心思想是在被访问的对象上定义一个接受访问者对象的接口，然后访问者对象通过该接口访问被访问对象。这样可以使得被访问对象保持稳定，而访问者对象可以根据需要进行扩展。\n访问者模式包含以下几个元素：\n1.访问者（Visitor）：该组件定义了处理对象结构中各个元素所要执行的方法，这些方法接受的参数可以是元素本身，也可以是元素的特定属性。\n2.具体访问者（Concrete Visitor）：该组件实现了访问者定义的方法，以便可以对对象结构中的不同元素执行特定的操作。\n3.元素（Element）：该组件定义了访问者能够访问的接口，一般它包含一个 accept() 方法，该方法接受一个访问者作为参数。\n4.具体元素（Concrete Element）：该组件实现了元素的接口，它可以被一个具体访问者实例访问并执行特定的操作。\n5.对象结构（Object Structure）：该组件是元素的集合，它定义了元素的集合以及提供可以接受访问者访问的接口。\n以下是一个简单的Java案例，演示了访问者模式的使用方式：\n假设我们有一个图形类层次结构，包括Rectangle、Circle和Triangle三个具体类型。我们可以定义一个Visitor接口，将不同的操作定义为Visitor的方法。然后，我们可以实现具体的Visitor类 RectangleVisitor、CircleVisitor和TriangleVisitor，并为每个具体类提供accept()方法，该方法接受一个Visitor对象并调用visit()方法。\n// Element接口\ninterface Shape &#123;\n    void accept(Visitor v);\n&#125;\n\n// 具体元素类：矩形\nclass Rectangle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// 具体元素类：圆形\nclass Circle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// 具体元素类：三角形\nclass Triangle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// Visitor接口\ninterface Visitor &#123;\n    void visit(Rectangle r);\n    void visit(Circle c);\n    void visit(Triangle t);\n&#125;\n\n// 具体访问者类：用于计算图形面积\nclass AreaVisitor implements Visitor &#123;\n    public void visit(Rectangle r) &#123;\n        System.out.println(\"计算矩形的面积\");\n    &#125;\n    public void visit(Circle c) &#123;\n        System.out.println(\"计算圆形的面积\");\n    &#125;\n    public void visit(Triangle t) &#123;\n        System.out.println(\"计算三角形的面积\");\n    &#125;\n&#125;\n\n// 具体访问者类：用于计算图形周长\nclass PerimeterVisitor implements Visitor &#123;\n    public void visit(Rectangle r) &#123;\n        System.out.println(\"计算矩形的周长\");\n    &#125;\n    public void visit(Circle c) &#123;\n        System.out.println(\"计算圆形的周长\");\n    &#125;\n    public void visit(Triangle t) &#123;\n        System.out.println(\"计算三角形的周长\");\n    &#125;\n&#125;\n\n// 测试代码\npublic class VisitorDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建图形列表\n        Shape[] shapes = &#123; new Rectangle(), new Circle(), new Triangle() &#125;;\n\n        // 计算面积\n        Visitor areaVisitor = new AreaVisitor();\n        for (Shape shape : shapes) &#123;\n            shape.accept(areaVisitor);\n        &#125;\n\n        // 计算周长\n        Visitor perimeterVisitor = new PerimeterVisitor();\n        for (Shape shape : shapes) &#123;\n            shape.accept(perimeterVisitor);\n        &#125;\n    &#125;\n&#125;\n\n在上述示例中，我们定义了三个具体元素类：矩形、圆形和三角形，并定义了两个具体访问者类：用于计算面积和周长。在测试代码中，我们创建了一个图形列表，遍历该列表并分别使用AreaVisitor和PerimeterVisitor访问器计算每一个图形的面积和周长。执行该程序会输出如下结果：\n计算矩形的面积\n计算圆形的面积\n计算三角形的面积\n计算矩形的周长\n计算圆形的周长\n计算三角形的周长\n\n案例二\n下面是一个Java实现访问者模式的小案例。假设有一个电商平台，需要对用户购买记录进行分析，包括计算用户购买总金额、计算用户购买物品种类数等统计工作。首先定义被访问对象：购物车条目CartItem和用户购物车Cart：\npublic interface CartItem &#123;\n    void accept(Visitor visitor);\n&#125;\n\npublic class ProductCartItem implements CartItem &#123;\n    private String name;\n    private double price;\n\n    public ProductCartItem(String name, double price) &#123;\n        this.name = name;\n        this.price = price;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\npublic class ServiceCartItem implements CartItem &#123;\n    private String name;\n    private double fee;\n\n    public ServiceCartItem(String name, double fee) &#123;\n        this.name = name;\n        this.fee = fee;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public double getFee() &#123;\n        return fee;\n    &#125;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\npublic class Cart &#123;\n    private List&lt;CartItem> cartItems = new ArrayList&lt;>();\n\n    public void addItem(CartItem item) &#123;\n        cartItems.add(item);\n    &#125;\n\n    public void removeItem(CartItem item) &#123;\n        cartItems.remove(item);\n    &#125;\n\n    public void accept(Visitor visitor) &#123;\n        for (CartItem item : cartItems) &#123;\n            item.accept(visitor);\n        &#125;\n        visitor.visit(this);\n    &#125;\n&#125;\n\n其中，Cart类为购物车类，可以添加和删除购物项，accept方法接受Visitor访问。\n然后定义访问者Visitor，用来计算购物车中的统计数据：\npublic interface Visitor &#123;\n    void visit(ProductCartItem item);\n    void visit(ServiceCartItem item);\n    void visit(Cart cart);\n&#125;\n\npublic class CartStatisticsVisitor implements Visitor &#123;\n    private double totalAmount;\n    private int distinctProductCount;\n\n    public double getTotalAmount() &#123;\n        return totalAmount;\n    &#125;\n\n    public int getDistinctProductCount() &#123;\n        return distinctProductCount;\n    &#125;\n\n    @Override\n    public void visit(ProductCartItem item) &#123;\n        totalAmount += item.getPrice();\n        distinctProductCount++;\n    &#125;\n\n    @Override\n    public void visit(ServiceCartItem item) &#123;\n        totalAmount += item.getFee();\n    &#125;\n\n    @Override\n    public void visit(Cart cart) &#123;\n        System.out.printf(\"Total amount: $%.2f, distinct product count: %d%n\", \n            totalAmount, distinctProductCount);\n    &#125;\n&#125;\n\nCartStatisticsVisitor类实现了Visitor接口，计算购物车中的数量和总金额。visit方法根据被访问对象进行相应的计算，并将结果记录在中间变量中。最后，visit(Cart cart)方法输出结果。\n使用访问者模式统计购物车上的总金额和不同商品数量：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Cart cart = new Cart();\n        cart.addItem(new ProductCartItem(\"Apple\", 3.99));\n        cart.addItem(new ProductCartItem(\"Banana\", 2.99));\n        cart.addItem(new ServiceCartItem(\"Delivery fee\", 5.99));\n\n        CartStatisticsVisitor visitor = new CartStatisticsVisitor();\n        cart.accept(visitor);\n    &#125;\n&#125;\n\n输出结果为：\nTotal amount: $12.97, distinct product count: 2\n\n这样，通过访问者模式可以方便地对购物车数据进行统计分析，而不会修改现有代码。\n","slug":"访问者模式","date":"2023-05-15T08:21:18.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"ba45023a93415880bd8ff889992600c8","title":"中介者模式","content":"中介者模式它的作用是减少对象之间的直接耦合关系，通过引入一个中介者对象来协调多个对象之间的交互行为，从而将系统中复杂的网状关系变为简单的星型结构。\n中介者模式的机制基于以下两个关键点：\n\n抽象中介者（Mediator）：为了把各同事类的耦合度降到最低，将对象间通信的控制交给一个中介者来协调调度，具体同事类都依赖中介者，由中介者负责消息的转发和协调。\n具体中介者（Concrete Mediator）：它从具体的同事类接收消息，并向具体同事类发送命令。它将各个同事对象之间的交互过程所需的信息进行了封装，使得各个同事类不再需要显式地引用其他同事类。\n\n中介者模式的优点有：\n\n中介者模式简化了对象之间的交互关系，将对象之间复杂的网状结构转变为简单的星型结构。\n中介者模式使得各对象之间的耦合度大大降低，可以独立地变化和复用。\n中介者模式易于扩展，增加新的同事类时不需要修改原有的代码，只需要按照同样的方式实现新的同事类即可。\n\n中介者模式的缺点有：\n\n中介者模式会增加系统中对象的个数，使得系统变得复杂。\n中介者模式中，中介者对象可能会变得过于复杂，难以维护与更新。\n\n下面是一个简单的中介者模式的示例，假设有三个对象之间需要进行通信：买方、卖方和中介者。买方想要购买物品，卖方想要出售物品，而中介者作为协调者来帮助买卖双方进行交易。\n// 定义买方类\npublic class Buyer &#123;\n    private Mediator mediator;\n\n    public void setMediator(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void buyItem() &#123;\n        mediator.buyItem();\n    &#125;\n\n    public void receiveItem() &#123;\n        System.out.println(\"Received item from seller.\");\n    &#125;\n&#125;\n\n// 定义卖方类\npublic class Seller &#123;\n    private Mediator mediator;\n\n    public void setMediator(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void sellItem() &#123;\n        mediator.sellItem();\n    &#125;\n\n    public void receivePayment() &#123;\n        System.out.println(\"Received payment from buyer.\");\n    &#125;\n&#125;\n\n// 定义中介者接口\npublic interface Mediator &#123;\n    void buyItem();\n    void sellItem();\n&#125;\n\n// 定义具体中介者类\npublic class TradeMediator implements Mediator &#123;\n    private Buyer buyer;\n    private Seller seller;\n\n    public void setBuyer(Buyer buyer) &#123;\n        this.buyer = buyer;\n        buyer.setMediator(this);\n    &#125;\n\n    public void setSeller(Seller seller) &#123;\n        this.seller = seller;\n        seller.setMediator(this);\n    &#125;\n\n    public void buyItem() &#123;\n        seller.receivePayment();\n        buyer.receiveItem();\n    &#125;\n\n    public void sellItem() &#123;\n        buyer.receivePayment();\n        seller.receiveItem();\n    &#125;\n&#125;\n\n// 测试类\npublic class MediatorTest &#123;\n    public static void main(String[] args) &#123;\n        TradeMediator mediator = new TradeMediator();\n        Buyer buyer = new Buyer();\n        Seller seller = new Seller();\n\n        mediator.setBuyer(buyer);\n        mediator.setSeller(seller);\n\n        buyer.buyItem();\n        seller.sellItem();\n    &#125;\n&#125;\n\n在这个示例中，各个类分别代表了买方、卖方和中介者。买方需要购买物品并接收物品，卖方需要出售物品并接收付款，而中介者则负责调节买卖双方之间的交易。通过中介者模式，买方和卖方可以通过中介者来进行通信，它们不需要直接相互了解，从而降低了耦合度。\n","slug":"中介者模式","date":"2023-05-15T07:45:06.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"4fe76f7b940933ddf5de5f39814faa1c","title":"MySQL_DQL","content":"DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录\n基本语法DQL 查询语句，语法结构如下：\nSELET\n\t字段列表\nFROM\n\t表名列表\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n\n\n基本查询（不带任何条件）\n\n条件查询（WHERE）\n\n聚合函数（count、max、min、avg、sum）\n\n分组查询（group by）\n\n排序查询（order by）\n\n分页查询（limit）\n\n\n基础查询 * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）\n 查询多个字段\nSELECT 字段1, 字段2, 字段3 ... FROM 表名 ;\n\nSELECT * FROM 表名 ;\n\n字段设置别名\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名; \n\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\n\n去除重复记录(DISTINCT)\nSELECT DISTINCT 字段列表 FROM 表名;\n\n查询所有员工的工作地址,起别名,不重复\nSELECT DISTINCT workaddress '工作地址' from  emp;\n\n条件查询语法\nSELECT 字段名 from 表名 WHERE 条件列表; \n\n\n\n\n运算符\n功能\n\n\n\n&gt; 、&gt;&#x3D;\n大于、大于等于\n\n\n&lt; 、&lt;&#x3D;\n小于、小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt; 、!&#x3D;\n不等于\n\n\nBETWEEN … AND …\n在某个范围之内(包含最小、最大值)\n\n\nIN(…)\n在in之后的列表中的值\n\n\nLIKE  占位符\n模糊匹配(_匹配单个字符, %匹配任意个字符)\n\n\nIS  NOT NULL\n不是NULL\n\n\nIS  NULL\n是NULL\n\n\nAND 、&amp;&amp;\n并且 (多个条件同时成立)\n\n\nOR 、||\n或者 (多个条件任意一个成立)\n\n\nNOT 、!\n非 , 不是\n\n\n 小案例：查询没有身份证号的员工信息\n不可以使用 &#x3D; null\nSELECT * FROM emp WHERE idcard IS NULL;\n\n聚合函数\n将一列数据作为一个整体，进行纵向计算\n常见的聚合函数\n\n\n\n函数\n描述\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n语法\nSELECT 聚合函数(字段列表) FROM 表名 [条件查询] ...;\n\n注意 :NULL值是不参与所有聚合函数运算的\n对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字&#x2F;字符串)的形式进行统计查询\n小案例：统计该企业员工数量\nSELECT count(idcard) from emp;\t-- 字段值为NULL，是不参与所有聚合函数运算的\nSELECT count(*) from emp;\nSELECT count(1) from emp;\n\n分组查询\nSELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组\n后过滤条件 ];\n\n where与having区别\n\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤\n\n判断条件不同：where不能对聚合函数进行判断，而having可以\n\n\n注意事项:\n\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n\n执行顺序: where &gt; 聚合函数 &gt; having 。\n\n支持多字段分组, 具体语法为 : group by columnA,columnB\n\n\n小案例：查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址\nselect workaddress,count(*) number from emp \nwhere age &lt; 45 \ngroup by workaddress\nhaving number >= 3;\n\n小案例： 统计各个工作地址上班的男性及女性员工的数量\nselect workaddress,gender,count(*) number from emp GROUP BY workaddress, gender;\n\n排序查询 语法\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;\n\n 排序方式      ASC : 升序(默认值)      DESC: 降序\n如果是升序, 可以不指定排序方式ASC ;\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n小案例：根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序\nselect * from emp order by age desc, entrydate desc;\n\n分页查询语法\n起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。\n分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。\nSELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;\n\n小案例：查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数\nselect * from emp limit 10, 10;\n\n执行顺序\n验证  : 查询年龄大于15的员工姓名、年龄，并根据年龄进行升序排序\nselect name, age from emp where age > 15 order by age asc;\n\n在查询时，我们给emp表起一个别名 e，然后在select 及 where中使用该别名。\nselect e.name, e.age from emp e where e.age > 15 order by age asc;\n\n执行上述SQL语句后，我们看到依然可以正常的查询到结果，此时就说明： from 先执行, 然后where 和 select 执行。\n那 where 和 select 到底哪个先执行呢?\n此时，此时我们可以给select后面的字段起别名，然后在 where 中使用这个别名，然后看看是否可以执行成功。\nselect e.name, e.age eage from emp e where eage > 15 order by e.age asc;\n\n执行上述SQL报错了:1054 - Unknown column ‘eage’ in ‘where clause’\n说明是执行完from之后，到执行where。\n接下来，我们再执行如下SQL语句，查看执行效果：\nselect e.name ename , e.age eage from emp e where e.age > 15 order by eage asc;\n\n结果执行成功。 那么也就验证了: order by 是在select 语句之后执行的。\n综上所述，DQL语句的执行顺序为：\nfrom ... where ... group by ...having ... select ... order by ... limit ...\n\n","slug":"MySQL-DQL","date":"2023-05-14T06:22:31.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"676b4ad0d6495672245716dc73cc8c9e","title":"MySQL_DML","content":"DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进\n行增、删、改操作。\n添加数据 给指定字段添加数据\nINSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...);\n\n案例: 给employee表所有的字段添加数据\nINSERT INTO employee(id,workno,name,gender,age,idcard,entrydate)\nVALUES(1,'1','HJ','女',20,'450802200206141527','2023-05-14');\n\n给全部字段添加数据\nINSERT INTO employee \nvalues(2,'2','H','男',23,'45080220001121057X','2023-07-10');\n\n批量添加数据\nINSERT INTO 表名(字段1，字段2, ...) values\n(v1, v2, ...),(a1, a2, ...),(b1, b2, ...);\n/*\n或者\n*/\nINSERT INTO 表名\nVALUES (v1, v2, ...),(a1, a2, ...),(b1, b2, ...);\n\n执行DML语句，会检查插入的字段是否符合字段的类型，不符合会报错。\n 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n 字符串和日期型数据应该包含在引号中。\n插入的数据大小，应该在字段的规定范围内。\n日期类型要连续，否则会报错\n修改数据\nUPDATE 表名 SET 字段1 &#x3D; V1, 字段2 &#x3D; V2, ... [WHERE 条件];\n\n删除数据\nDELEDE FROM 表名 [WHERE 条件];\n\n• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n• DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n\n\n\n类型\n大小\n有符号范围\n无符号范围\n描述\n\n\n\nTINYINT\n1byte\n(-2^7，2^7-1)\n(0，2^8-1)\n小整数值\n\n\nSMALLINT\n2bytes\n(-2^15，2^15-1)\n(0，2^16-1)\n大整数值\n\n\nMEDIUMINT\n3bytes\n(-2^23，2^23-1)\n(0，2^24-1)\n大整数值\n\n\nINT&#x2F;INTEGER\n4bytes\n(-2^31，2^31-1)\n(0，2^32-1)\n大整数值\n\n\nBIGINT\n8bytes\n(-2^63，2^63-1)\n(0，2^64-1)\n大整数值\n\n\nFLOAT\n4bytes\n(-3.402823466 E+38，3.402823466351 E+38)\n\n双精度浮点数值\n\n\nDOUBLE\n8bytes\n(-1.7976931348623157E+308，1.7976931348623157E+308)\n\n单精度浮点数值\n\n\nDECIMAL\n\n依赖于M(精度)和D(标度)\n依赖于M(精度)和D(标度)\n小数值(精确定点数)\n\n\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0-255 bytes\n定长字符串(需要指定长度)\n\n\nVARCHAR\n0-65535 bytes\n变长字符串(需要指定长度)\n\n\nTINYBLOB\n0-255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0-255 bytes\n短文本字符串\n\n\nBLOB\n0-65 535 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0-65 535 bytes\n长文本数据\n\n\nMEDIUMBLOB\n0-16 777 215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0-16 777 215 bytes\n中等长度文本数据\n\n\nLONGBLOB\n0-4 294 967 295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0-4 294 967 295 bytes\n极大文本数据\n\n\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至 9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至 838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值，时间戳\n\n\n","slug":"MySQL-DML","date":"2023-05-14T01:30:25.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"56fbe19991b11dc0bb9030f36adcdf92","title":"MySQL_DDL_Linux","content":"启动MySQL服务启动mysql服务\nsystemctl start mysqld\n\n重启mysql服务\nsystemctl restart mysqld\n\n停止mysql服务\nsystemctl stop mysqld\n\n查询首次安装数据库自动生成的root密码grep 'temporary password' /var/log/mysqld.log\n\n命令行执行指令\nmysql [-h 127.0.0.1] -u root -p密码\n\n修改root用户密码登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码\nALTER USER 'root'@'localhost' IDENTIDFIED BY 'hj0614';\n\n执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。\n设置密码的复杂度为简单类型\nset global validate_password.policy = 0;\n\n设置密码长度为6\nset global validate_password.length = 6;\n\n再次执行上述修改密码的指令!\n创建用户默认的root用户只能当前节点localhost访问，是无法远程访问的\n我们还需要创建一个root账户，用户远程访问\ncreate user 'root'@'%' IDENTIFIDE WITH mysql_native_password BY 'hj0614';\n\n给用户分配权限grant all on root.* to 'root'@'%';\n\n重新连接mysql\n查看权限show grants for  'root'@'%';\n\n撤销权限revoke all on root.* from 'root'@'%'\n\nSQL通用语法\nSQL语句可以单行或多行书写，以分号 ; 结尾。\nSQL语句可以使用空格 &#x2F; 缩进来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释：\n单行注释：– 注释内容 或 # 注释内容\n多行注释：&#x2F;* 注释内容 *&#x2F;\n\nSQL分类SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL\n\n\n\nDDL：Data Definition Language\n数据定义语言，用来定义数据库对象(数据库，表，字段）\n\n\n\nDML：Data Manipulation  Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL：Data Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL：Data Control Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\nDDL语句查询所有数据库\nshow databases;\n\n查询当前数据库\nselect database();\n\n创建数据库 [表示可选项]\ncreate database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];\n\n示例：创一个数据库使用默认的字符集，默认排列\ncreate database if not exists test; \n\n删除数据库     如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists\ndrop database [if exists] 数据库名;\n\n切换数据库\nuse 数据库名;\n\n查询当前数据库所有表\nshow tables;\n\n查看指定表结构\n通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息\ndesc 表名;\n\n查询指定表的建表语句\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询\n到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\nshow create table 表名;\n\n小案例：查看employee表的建表语句\nemployee\tCREATE TABLE `employee` (\n  `id` int DEFAULT NULL COMMENT '编号',\n  `workno` varchar(10) DEFAULT NULL,\n  `name` varchar(10) DEFAULT NULL COMMENT '姓名',\n  `gender` char(1) DEFAULT NULL COMMENT '性别',\n  `age` tinyint unsigned DEFAULT NULL COMMENT '年龄',\n  `idcard` char(18) DEFAULT NULL COMMENT '身份证号',\n  `workaddress` varchar(50) DEFAULT NULL COMMENT '工作地址',\n  `entrydate` date DEFAULT NULL COMMENT '入职时间'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表'\n\n创建表结构\t\n最后一个字段后面没有逗号\nCREATE TABLE 表名(\n字段1 字段1类型 [COMMENT 字段1注释],\n字段2 字段2类型 [COMMENT 字段2注释],\n...\n字段n 字段n类型 [COMMENT 字段n注释]\n) [COMMENT 表注释];\n\n小案例：设计一张员工信息表，要求如下：\n\n编号（纯数字）\n\n员工工号 (字符串类型，长度不超过10位)\n\n员工姓名（字符串类型，长度不超过10位）\n\n性别（男&#x2F;女，存储一个汉字）\n\n年龄（正常人年龄，不可能存储负数）\n\n身份证号（二代身份证号均为18位，身份证中有X这样的字符）\n\n入职时间（取值年月日即可）\n\n\ncreate table emp(\n id int comment '编号',\n workno varchar(10) comment '员工工号',\n name varchar(10) comment '员工姓名',\n sex char(1) comment '性别',\n age tinyint comment '年龄',\n idcard char(18) comment '身份证',\n entrydate date  comment '入职时间'\n) comment '员工信息表'\n\n添加表字段(ADD)\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\n\n小案例：为emp添加一个新的字段”昵称”为nickname，类型为varchar(20);\nALTER TABLE emp ADD nickname varchar(20) comment '昵称';\n\n修改数据类型(MODIFY)\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n\n 修改字段名和字段类型(CHANGE)\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [comment 注释] [约束]\n\n小案例：将emp表的nickname字段修改为username，类型为varchar(30)\nALTER TABLE emp CHANGE nikename username varchar(30) comment '昵称';\n\n删除字段(DROP)\nALTER TABLE 表名 DROP 字段名;\n\n小案例：将emp表的字段username删除\nALTER TABLE emp DROP username;\n\n修改表名(RENAME TO)\nALTER TABLE 表名 RENAME TO 新表名;\n\n小案例：将emp表的表名修改为 employee\nALTER TABLE emp RANAME TO employee;\n\n 删除表\nDROP TABLE [IF EXISTS] 表名;\n\n小案例：如果tb_user表存在，则删除tb_user表\nDROP TABLE IF EXISTS tb_user;\n\n 删除指定表, 并重新创建表\nTRUNCATE TABLE 表名;\n\n","slug":"MySQL-DDL","date":"2023-05-13T10:36:19.000Z","categories_index":"","tags_index":"Linux,MySQL","author_index":"大宝贝的程序员"},{"id":"b847fc9b240aefdbf95225a3e7dc9026","title":"Spring Bean的生命周期","content":"Spring Bean的生命周期getBean方法都会调用doGetBean的逻辑\n    public &lt;T> T getBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object... args) throws BeansException &#123;\n        return this.doGetBean(name, requiredType, args, false);\n    &#125;\n\nprotected &lt;T> T doGetBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123;\n    ....\n    &#125;\n\nbean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：\n\n处理名称，检查缓存\n处理父子容器\n处理 dependsOn\n选择 scope 策略\n创建singleton\n创建prototype\n创建其他scope\n\n\n创建 bean\n创建bean实例\n依赖注入\n初始化\n登记可销毁的bean\n\n\n类型转换处理\n销毁 bean\n\n\n\n\n\n\n\n\n\n\n注意\n\n划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情\n\n1. 处理名称，检查缓存\n\n这一步会处理别名，将别名解析为实际名称\n对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品\n这里针对单例对象会检查一级、二级、三级缓存\nsingletonFactories 三级缓存，存放单例工厂对象\nearlySingletonObjects 二级缓存，存放单例工厂的产品对象\n如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象\n\n\nsingletonObjects 一级缓存，存放单例成品对象\n\n\n\n2. 处理父子容器\n\n如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程\n父子容器的 bean 名称可以重复\n\n3. 处理 dependsOn\n\n如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean \n所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序\n\n4. 选择 scope 策略\n\n对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程\n对于 prototype scope，每次都会进入创建流程\n对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程\n\npublic class TestScope &#123;\n    public static void main(String[] args) &#123;\n        testRequestScope();\n    &#125;\n\n    // 单例 bean 从 refresh 被创建, 到 close 被销毁, BeanFactory 会记录哪些 bean 要调用销毁方法\n    private static void testSingletonScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"bean1\", Bean1.class);\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh(); // getBean\n        context.close();\n    &#125;\n\n    // 多例 bean 从首次 getBean 被创建, 到调用 BeanFactory 的 destroyBean 被销毁\n    private static void testPrototypeScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setScope(\"prototype\"));\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh();\n\n        Bean1 bean = context.getBean(Bean1.class);\n        // 没谁记录该 bean 要调用销毁方法, 需要我们自行调用\n        context.getDefaultListableBeanFactory().destroyBean(bean);\n\n        context.close();\n    &#125;\n\n    // request bean 从首次 getBean 被创建, 到 request 结束前被销毁\n    private static void testRequestScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.getDefaultListableBeanFactory().registerScope(\"request\", new RequestScope());\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setScope(\"request\"));\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh();\n\n        for (int i = 0; i &lt; 2; i++) &#123;\n            new Thread(() -> &#123;\n                MockHttpServletRequest request = new MockHttpServletRequest();\n                // 每个 webRequest 对象会记录哪些 bean 要调用销毁方法\n                ServletWebRequest webRequest = new ServletWebRequest(request);\n                RequestContextHolder.setRequestAttributes(webRequest);\n\n                Bean1 bean = context.getBean(Bean1.class);\n                LoggerUtils.get().debug(\"&#123;&#125;\", bean);\n                LoggerUtils.get().debug(\"&#123;&#125;\", request.getAttribute(\"bean1\"));\n\n                // request 请求结束前调用这些销毁方法\n                webRequest.requestCompleted();\n            &#125;).start();\n        &#125;\n\n    &#125;\n\n    static class Bean1 &#123;\n        @PostConstruct\n        public void init() &#123;\n            LoggerUtils.get().debug(\"&#123;&#125; - init\", this);\n        &#125;\n\n        @PreDestroy\n        public void destroy() &#123;\n            LoggerUtils.get().debug(\"&#123;&#125; - destroy\", this);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n5.1 创建 bean - 创建 bean 实例   \t创建出空的实例\n\n\n\n要点\n总结\n\n\n\n有自定义 TargetSource 的情况\n由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回\n\n\nSupplier 方式创建 bean 实例\n为 Spring 5.0 新增功能，方便编程方式创建  bean  实例\n\n\nFactoryMethod 方式  创建 bean  实例\n① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选\n\n\nAutowiredAnnotationBeanPostProcessor\n① 优先选择带  @Autowired  注解的构造；② 若有唯一的带参构造，也会入选\n\n\nmbd.getPreferredConstructors\n选择所有公共构造，这些构造之间按权重筛选\n\n\n采用默认构造\n如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的\n\n\n5.2 创建 bean - 依赖注入\n\n\n\n要点\n总结\n\n\n\nAutowiredAnnotationBeanPostProcessor\n识别   @Autowired  及 @Value  标注的成员，封装为  InjectionMetadata 进行依赖注入\n\n\nCommonAnnotationBeanPostProcessor\n识别   @Resource  标注的成员，封装为  InjectionMetadata 进行依赖注入\n\n\nresolveDependency\n用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy  注解；④ @Value  注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）\n\n\nAUTOWIRE_BY_NAME\n根据成员名字（set方法的名字）找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员\n\n\nAUTOWIRE_BY_TYPE\n根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues\n\n\napplyPropertyValues\n根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref\n\n\n依赖注入的优先级// 测试如果对同一属性进行的 @Autowired 注入、AUTOWIRE_BY_NAME、精确指定注入名称, 优先级是怎样的\npublic class TestInjection &#123;\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.registerBean(\"bean1\", Bean1.class, bd -> &#123;\n            // 优先级最高的：精确指定注入 bean 的名称 &lt;property name=\"bean3\" ref=\"bean2\"/> \t\t\t\t//property标签也是根据set方法进行注入的\n            bd.getPropertyValues().add(\"bean3\", new RuntimeBeanReference(\"bean2\"));\n            // 优先级次之的：通过 AUTOWIRE_BY_NAME 匹配\n            ((RootBeanDefinition) bd).setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_NAME);\n        &#125;);\n        context.registerBean(\"bean2\", Bean2.class);\n        context.registerBean(\"bean3\", Bean3.class);\n        context.registerBean(\"bean4\", Bean4.class);\n\n        context.refresh();\n    &#125;\n\n    static class Bean1 &#123;\n        MyInterface bean;\n\n        // 优先级最低的：@Autowired 匹配\n        @Autowired @Qualifier(\"bean4\")\n        public void setBean3(MyInterface bean) &#123;\n            System.out.println(bean);\n            this.bean = bean;\n        &#125;\n    &#125;\n\n    interface MyInterface &#123;\n    &#125;\n\n    static class Bean2 implements MyInterface &#123;\n    &#125;\n\n    static class Bean3 implements MyInterface &#123;\n    &#125;\n\n    static class Bean4 implements MyInterface &#123;\n    &#125;\n&#125;\n\n精确匹配的优先级最高，其次到按名字匹配AUTOWIRE_BY_NAME，最后是注解方式\n5.3 创建 bean - 初始化\n\n\n\n要点\n总结\n\n\n\n内置 Aware 接口的装配\n包括 BeanNameAware，BeanFactoryAware 等\n\n\n扩展 Aware 接口的装配\n由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization\n\n\n@PostConstruct\n由 CommonAnnotationBeanPostProcessor 解析，执行时机在  postProcessBeforeInitialization\n\n\nInitializingBean\n通过接口回调执行初始化\n\n\ninitMethod\n根据 BeanDefinition 得到的初始化方法执行初始化，即 &lt;bean init-method&gt; 或 @Bean(initMethod)\n\n\n创建 aop 代理\n由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在  postProcessAfterInitialization\n\n\n初始化方法的执行顺序public class TestInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        // &lt;bean init-method=\"initMethod\">\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setInitMethodName(\"initMethod\"));\n        context.refresh();\n    &#125;\n\n    static class Bean1 implements InitializingBean, BeanFactoryAware &#123;\n\n        @Override\n        public void afterPropertiesSet() throws Exception &#123;\n            System.out.println(1);\n        &#125;\n\n        @PostConstruct\n        public void init() &#123;\n            System.out.println(2);\n        &#125;\n\n        public void initMethod() &#123;\n            System.out.println(3);\n        &#125;\n\n        @Override\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;\n            System.out.println(4);\n        &#125;\n    &#125;\n&#125;\n\n先执行内置 Aware 接口 -&gt;@PostConstruct -&gt;InitializingBean -&gt; initMethod\n4\n2\n1\n3\n\n5.4 创建 bean - 注册可销毁 bean\n在这一步判断并登记可销毁 bean\n\n判断依据\n如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean\n如果自定义了 destroyMethod，则为可销毁 bean\n如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）\n如果有 @PreDestroy 标注的方法\n\n\n存储位置\nsingleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中\n自定义 scope 的可销毁 bean 会存储于对应的域对象当中\nprototype scope 不会存储，需要自己找到此对象销毁\n\n\n存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配，体现了适配器模式\n\n6. 类型转换处理\n\n如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换\n\n7. 销毁 bean\n\n销毁时机\nsingleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁\n自定义 scope bean 的销毁在作用域对象生命周期结束时\nprototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁\n\n\n同一 bean 中不同形式销毁方法的调用次序\n优先后处理器销毁，即 @PreDestroy\n其次 DisposableBean 接口销毁\n最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）\n\n\n\n","slug":"Spring Bean的生命周期","date":"2023-05-13T04:32:54.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"ec47f8662f4dbcb9ad26f0a7bcc5e407","title":"Spring refresh流程","content":"refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：\n\nprepareRefresh –做好准备工作\n\nobtainFreshBeanFactory –创建或获取BeanFactory\n\nprepareBeanFactory –准备BeanFactory\n\npostProcessBeanFactory – 子类拓展BeanFactory\n\ninvokeBeanFactoryPostProcessors –后处理器拓展BeanFactory\n\nregisterBeanPostProcessors –准备Bean后处理器\n\ninitMessageSource –为ApplicationContext提供国际化功能\n\ninitApplicationEventMulticaster –为ApplicationContext提供事件发布器\n\nonRefresh – 留给子类拓展\n\nregisterListeners –为ApplicationContext准备监听器\n\nfinishBeanFactoryInitialization – 初始化单例Bean，执行Bean后处理器拓展\n\nfinishRefresh – 准备生命周期管理器，发布ContextRefreshed事件\n\n\n\n\n\n\n\n\n\n\n\n功能分类\n\n1 为准备环境\n\n2 3 4 5 6 为准备 BeanFactory\n\n7 8 9 10 12 为准备 ApplicationContext\n\n11 为初始化 BeanFactory 中非延迟单例 bean\n\n\n1. prepareRefresh\n\n这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量\n\nEnvironment 对象的作用之一是为后续 @Value，值注入时提供键值\n\nEnvironment 分成三个主要部分\n\nsystemProperties - 保存 java 环境键值\nsystemEnvironment - 保存系统环境键值\n自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值\n\n\n\n\n示例// 如何获得和解析 @Value 内容\npublic class TestEnvironment &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IOException &#123;\n        // 1) 获得 @Value 的值\n        System.out.println(\"=======================> 仅获取 @Value 值\");\n        QualifierAnnotationAutowireCandidateResolver resolver = new QualifierAnnotationAutowireCandidateResolver();\n        Object name = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"name\"), false));\n        System.out.println(name);\n\n        // 2) 解析 @Value 的值\n        System.out.println(\"=======================> 获取 @Value 值, 并解析$&#123;&#125;\");\n        Object javaHome = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"javaHome\"), false));\n        System.out.println(javaHome);\n        System.out.println(getEnvironment().resolvePlaceholders(javaHome.toString()));\n\n        // 3) 解析 SpEL 表达式\n        System.out.println(\"=======================> 获取 @Value 值, 并解析#&#123;&#125;\");\n        Object expression = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"expression\"), false));\n        System.out.println(expression);\n        String v1 = getEnvironment().resolvePlaceholders(expression.toString());\n        System.out.println(v1);\n        //解析 #&#123;&#125;\n        System.out.println(new StandardBeanExpressionResolver().evaluate(v1, new BeanExpressionContext(new DefaultListableBeanFactory(),null)));\n    &#125;\n\n    private static Environment getEnvironment() throws IOException &#123;\n        //是Environment的重要实现，默认只能识别系统的键值，无法解析自定义的键值\n        //需要知道自定义键值的位置才能解析\n        StandardEnvironment env = new StandardEnvironment();\n        //添加自定文件的键值\n        env.getPropertySources().addLast(new ResourcePropertySource(\"jdbc\", new ClassPathResource(\"jdbc.properties\")));\n        return env;\n    &#125;\n\n    static class Bean1 &#123;\n        @Value(\"hello\")\n        private String name;\n\n        @Value(\"$&#123;jdbc.username&#125;\")\n        private String javaHome;\n\t\t\t\t//SpEL表达式\n        @Value(\"#&#123;'class version:' + '$&#123;java.class.version&#125;'&#125;\")\n        private String expression;\n    &#125;\n&#125;\n\n结果=======================> 仅获取 @Value 值\nhello\n=======================> 获取 @Value 值, 并解析$&#123;&#125;\n$&#123;jdbc.username&#125;\nroot\n=======================> 获取 @Value 值, 并解析#&#123;&#125;\n#&#123;'class version:' + '$&#123;java.class.version&#125;'&#125;\n#&#123;'class version:' + '61.0'&#125;\nclass version:61.0\n\n首先，创建了一个 QualifierAnnotationAutowireCandidateResolver 的实例，用来解析@Value的候处理器。然后创建了一个 new DependencyDescriptor(Bean1.class.getDeclaredField(“name”), false) 的实例用来描述 Bean1 类的 name 属性，这个实例中包含了该属性所在类的信息、属性的名称等详细信息。调用 QualifierAnnotationAutowireCandidateResolver 的 getSuggestedValue 方法，并传入 DependencyDescriptor 的实例来获取一个推荐的属性值。\n2. obtainFreshBeanFactory\n\n这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量\nBeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义\nBeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等\nBeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加\n\n\n所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合\n\n\n// 演示各种 BeanDefinition 的来源\npublic class TestBeanDefinition &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"========================> 一开始\");\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 1) 从 xml 获取 \");\n        XmlBeanDefinitionReader reader1 = new XmlBeanDefinitionReader(beanFactory);\n        reader1.loadBeanDefinitions(new ClassPathResource(\"bd.xml\"));\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 2) 从配置类获取 \");\n        beanFactory.registerBeanDefinition(\"config1\", BeanDefinitionBuilder.genericBeanDefinition(Config1.class).getBeanDefinition());\n\n        ConfigurationClassPostProcessor postProcessor = new ConfigurationClassPostProcessor();\n        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 3) 扫描获取 \");\n        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanFactory);\n        scanner.scan(\"day04.refresh.sub\");\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n    &#125;\n\n    static class Bean1 &#123;\n\n    &#125;\n\n    static class Bean2 &#123;\n\n    &#125;\n\n    static class Config1 &#123;\n        @Bean\n        public Bean2 bean2() &#123;\n            return new Bean2();\n        &#125;\n    &#125;\n&#125;\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"bean1\" class=\"day04.refresh.TestBeanDefinition$Bean1\"/>\n\n&lt;/beans>\n\npackage day04.refresh.sub;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Bean3 &#123;\n&#125;\n\n结果&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 一开始\n[]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1) 从 xml 获取 \n[bean1]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 2) 从配置类获取 \n[bean1, config1, bean2]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 3) 扫描获取 \n[bean1, config1, bean2, bean3, org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory]\n\n\n3. prepareBeanFactory\n\n这一步会进一步完善 BeanFactory，为它的各项成员变量赋值\nbeanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver\npropertyEditorRegistrars 会注册类型转换器\n它在这里使用了 ResourceEditorRegistrar 实现类\n并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析\n\n\nregisterResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入\nbeanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：\nApplicationContextAwareProcessor 用来解析 Aware 接口\nApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean\n\n\n\n\n4. postProcessBeanFactory\n\n这一步是空实现，留给子类扩展。\n一般 Web 环境的 App0licationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory\n\n\n这里体现的是模板方法设计模式\n\n5. invokeBeanFactoryPostProcessors\n\n这一步会调用 beanFactory 后处理器\nbeanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition\n常见的 beanFactory 后处理器有\nConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等\nPropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }\nMapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition\n\n\n\n\n6. registerBeanPostProcessors\n\n这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中\nbean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：\nAutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解\nCommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy\nAnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理\n\n\n\n\n示例public class TestBeanPostProcessor &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n        beanFactory.registerBeanDefinition(\"bean1\", BeanDefinitionBuilder.genericBeanDefinition(Bean1.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"bean2\", BeanDefinitionBuilder.genericBeanDefinition(Bean2.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"bean3\", BeanDefinitionBuilder.genericBeanDefinition(Bean3.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"aspect1\", BeanDefinitionBuilder.genericBeanDefinition(Aspect1.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor1\",\n                BeanDefinitionBuilder.genericBeanDefinition(AutowiredAnnotationBeanPostProcessor.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor2\",\n                BeanDefinitionBuilder.genericBeanDefinition(CommonAnnotationBeanPostProcessor.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor3\",\n                BeanDefinitionBuilder.genericBeanDefinition(AnnotationAwareAspectJAutoProxyCreator.class).getBeanDefinition());\n\n        context.refresh();\n        beanFactory.getBean(Bean1.class).foo();\n    &#125;\n\n    static class Bean1 &#123;\n        Bean2 bean2;\n        Bean3 bean3;\n\n        @Autowired\n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"发生了依赖注入...\" + bean2);\n            this.bean2 = bean2;\n        &#125;\n\n        @Resource\n        public void setBean3(Bean3 bean3) &#123;\n            System.out.println(\"发生了依赖注入...\" + bean3);\n            this.bean3 = bean3;\n        &#125;\n\n        public void foo() &#123;\n            System.out.println(\"foo\");\n        &#125;\n    &#125;\n\n    static class Bean2 &#123;\n\n    &#125;\n\n    static class Bean3 &#123;\n\n    &#125;\n\n    @Aspect\n    static class Aspect1 &#123;\n        @Before(\"execution(* foo())\")\n        public void before() &#123;\n            System.out.println(\"before...\");\n        &#125;\n    &#125;\n&#125;\n\n结果发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean3@19b843ba\n发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean2@dc9876b\nbefore...\nfoo\n\n7. initMessageSource\n\n这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能\n去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现\n\n\n8. initApplicationContextEventMulticaster\n\n这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster\n它的作用是发布事件给监听器\n去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器\n之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件\n\n\n9. onRefresh\n\n这一步是空实现，留给子类扩展\nSpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器\n\n\n体现的是模板方法设计模式\n\n10. registerListeners\n\n这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster\n事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源\n事先编程添加的\n来自容器中的 bean\n来自于 @EventListener 的解析\n\n\n要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可\n\n\n11. finishBeanFactoryInitialization\n\n这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean\nconversionService 也是一套转换机制，作为对 PropertyEditor 的补充\nembeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能\nsingletonObjects 即单例池，缓存所有单例对象\n对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能\n\n\n\n\n12. finishRefresh\n\n这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean\n如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器\n准备好生命周期管理器，就可以实现\n调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start\n调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop\n\n\n发布 ContextRefreshed 事件，整个 refresh 执行完成\n\n\n","slug":"Spring-refresh流程","date":"2023-05-13T01:19:52.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"2846594611fd32071ec8e1a72cd8f17d","title":"Spring如何解决循环依赖","content":"Spring如何解决循环依赖解决Set循环依赖注入Spring一级缓存singletonObjects\nsingletonObjects是一级缓存，用于存储单例Bean的实例对象。也就是说，当Spring容器创建一个单例Bean时，会将该Bean的实例对象放入一级缓存中，在后续使用该Bean时，直接从缓存中获取实例对象，避免了重复创建实例对象的过程。\n当没有循环依赖注入时，可以正常创建Bean\n\n存在问题：无法解决循环依赖\n首先调用A的getBean()到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时B又需要用到A，又去一级缓存找A…..\n可见只有一级缓存是无法解决循环依赖注入的\n\n引入Spring的三级缓存singltonFactories\n解决循环依赖问题：\n先到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时创建的是一个半成品的A（工厂对象），把A放入三级缓存，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时创建的也是一个半成品的B，此时B又需要用到A，又去一级缓存找A发现没有，又去三级缓存找，找到了A，并完成依赖注入，把B的成品放入singletonObjects，然后清除singletonFactories内的半成品B。这是A就可以拿到B，完成初始化。把A放到一级缓存，并清除三级缓存的A。\n\n问题又来了：Spring注入的对象大多是代理对象，那么能否完成注入呢\n先到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时创建的是一个半成品的A（工厂对象），把A放入三级缓存，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时创建的也是一个半成品的B，此时B又需要用到A，又去一级缓存找A发现没有，又去三级缓存找，找到了A，并完成依赖注入（这时注入的并不是代理对象），初始化B并创建B的代理，把B的代理放入singletonObjects，然后清除singletonFactories内的半成品B。这是A就可以拿到B的代理，完成初始化。把A放到一级缓存，并清除三级缓存的A。可以看到，B注入的并不是代理，所有只有两个缓存是不可以解决Spring关于的代理对象的依赖注入。\n总的来说是因为存在循环依赖时，是依赖注入先发生，创建代理后发生\n\n引入Spring二级缓存earlySingletonObjects\n解决方法：提前创建代理\nSpring并不是对所有Bean的创建都提前创建代理，只有存在循环依赖时才提前创建代理\n\n解决Construct循环依赖注入A的构造依赖B，所有A无法创建工厂对象放入三级缓存，B的构造也依赖A，B也无法创建工厂对象放入缓存\n\nSpring的三级缓存无法解决构造器依赖注入。\n如何解决构造器的循环依赖呢？\n方法一\n可以给A注入一个B的代理对象（并不是真的B代理对象，而是创建了一个匿名内部类的TargetSource实现，当真正使用到B的方法时，会通过BeanFactory获取B，再调用），只要不妨碍A的创建以及初始化就行，当A成功创建之后，B也能成功创建，这时A想要用B的方法，只需要通过代理找到真正的B调用方法\n\n方法二\n可以给A注入一个工厂对象，只要不妨碍A的创建以及初始化就行，当A成功创建之后，B也能成功创建，这时A想要用B的方法，只需要通过工厂对象获取B，再调用方法\n\n以上两种都是通过延迟对象的创建来解析构造器循环依赖\n那么它们的延迟创建在Spring中如何体现呢？使用@Lazy\n在Spring中，可以在构造器循环依赖的其中一个对象的构造的参数上添加@Lazy来延迟对象的创建\n下面是一个在构造器循环依赖情况下使用 @Lazy 注解的示例代码：\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.AnnotationConfigUtils;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.context.support.GenericApplicationContext;\n\nimport javax.annotation.PostConstruct;\n\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private B b;;\n        public A(@Lazy B b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getClass());\n        System.out.println(context.getBean(B.class).getClass());\n\n\n    &#125;\n&#125;\n\n运行结果:[DEBUG] 23:49:27.836 [main] - A内的b>>>>class day04.boot.TestConstructDelayCreate$B$$EnhancerBySpringCGLIB$$f09826e3 \n[DEBUG] 23:49:27.842 [main] - init() \n[DEBUG] 23:49:27.845 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 23:49:27.845 [main] - init() \nclass day04.boot.TestConstructDelayCreate$B$$EnhancerBySpringCGLIB$$f09826e3\nclass day04.boot.TestConstructDelayCreate$B\n\n跟踪@Lazy\nObject result = this.getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);\n检查是否有@Lazy注解，是否需要创建代理\n\nreturn this.isLazy(descriptor) ? this.buildLazyResolutionProxy(descriptor, beanName) : null;\n是否需要创建代理\n\n看看创建代理的逻辑  buildLazyResolutionProxy\n创建了一个匿名内部类的TargetSource实现\n\n看看TargetSource的实现\n当调用getTarget()时，会通过BeanFactory获取B，再调用\n\n在上述代码中，可以给A注入一个B的代理对象，并不是真的B代理对象，而是创建了一个匿名内部类的TargetSource实现，内部关联了BeanFactory，当调用getTarget()时，会通过BeanFactory获取B，再调用。\n替换成ObjectFactory工厂对象\n下面是ObjectFactory示例代码：\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private ObjectFactory&lt;B> b;;\n        public A(ObjectFactory&lt;B> b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getObject());\n        System.out.println(context.getBean(B.class));\n    &#125;\n&#125;\n\n运行结果：\n[DEBUG] 16:33:27.224 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider \n[DEBUG] 16:33:27.230 [main] - init() \n[DEBUG] 16:33:27.233 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:33:27.234 [main] - init() \nday04.boot.TestConstructDelayCreate$B@7bd4937b\nday04.boot.TestConstructDelayCreate$B@7bd4937b\n\n优点：不会产生代理，减少内存开销\n替换成ObjectProvider对象（ObjectFactory的子类）\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;A&quot;);\n        private ObjectProvider&lt;B&gt; b;;\n        public A(ObjectProvider&lt;B&gt; b) &#123;\n            log.debug(&quot;A内的b&gt;&gt;&gt;&gt;&#123;&#125;&quot;, b.getClass());\n            this.b &#x3D; b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(&quot;init()&quot;);&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;B&quot;);\n        private A a;\n        public B(A a) &#123;\n            log.debug(&quot;B内的a&gt;&gt;&gt;&gt;&#123;&#125;&quot;, a.getClass());\n            this.a &#x3D; a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(&quot;init()&quot;);&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context &#x3D; new GenericApplicationContext();\n        context.registerBean(&quot;a&quot;,A.class);\n        context.registerBean(&quot;b&quot;,B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getObject());\n        System.out.println(context.getBean(B.class));\n    &#125;\n&#125;\n\n运行结果\n[DEBUG] 16:36:43.644 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider \n[DEBUG] 16:36:43.649 [main] - init() \n[DEBUG] 16:36:43.652 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:36:43.653 [main] - init() \nday04.boot.TestConstructDelayCreate$B@21e360a\nday04.boot.TestConstructDelayCreate$B@21e360a\n\nObjectProvider、ObjectFactory都是Spring提供的工厂接口\nProvider：Java官方提供的一套工厂接口\n&lt;dependency>\n          &lt;groupId>javax.inject&lt;/groupId>\n          &lt;artifactId>javax.inject&lt;/artifactId>\n          &lt;version>1&lt;/version>\n      &lt;/dependency>\n\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private Provider&lt;B> b;;\n        public A(Provider&lt;B> b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.get());\n        System.out.println(context.getBean(B.class));\n\n    &#125;\n&#125;\n\n运行结果：\n[DEBUG] 16:45:43.783 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$Jsr330Factory$Jsr330Provider \n[DEBUG] 16:45:43.788 [main] - init() \n[DEBUG] 16:45:43.792 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:45:43.792 [main] - init() \nday04.boot.TestConstructDelayCreate$B@43dac38f\nday04.boot.TestConstructDelayCreate$B@43dac38f\n\n分析：\npublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set&lt;String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException &#123;\n       descriptor.initParameterNameDiscovery(this.getParameterNameDiscoverer());\n       if (Optional.class == descriptor.getDependencyType()) &#123;\n           return this.createOptionalDependency(descriptor, requestingBeanName);\n       &#125; else if (ObjectFactory.class != descriptor.getDependencyType() &amp;&amp; ObjectProvider.class != descriptor.getDependencyType()) &#123;\n           \n           //创建Provider\n           if (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;\n               return (new DefaultListableBeanFactory.Jsr330Factory()).createDependencyProvider(descriptor, requestingBeanName);\n               \n               \n           &#125;\n\n//跟入 createDependencyProvider方法 是Jsr330Factory工厂的方法\nprivate class Jsr330Factory implements Serializable &#123;\n        private Jsr330Factory() &#123;\n        &#125;\n\n        public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) &#123;\n            return new DefaultListableBeanFactory.Jsr330Factory.Jsr330Provider(descriptor, beanName);\n        &#125;\n\n        private class Jsr330Provider extends DefaultListableBeanFactory.DependencyObjectProvider implements Provider&lt;Object> &#123;\n            public Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) &#123;\n                super(descriptor, beanName);\n            &#125;\n\n            @Nullable\n            public Object get() throws BeansException &#123;\n                return this.getValue();\n            &#125;\n        &#125;\n    &#125;\n\n//看看get方法的getvalue()的实现   \n@Nullable\n        protected Object getValue() throws BeansException &#123;\n            return this.optional ? DefaultListableBeanFactory.this.createOptionalDependency(this.descriptor, this.beanName) : DefaultListableBeanFactory.this.doResolveDependency(this.descriptor, this.beanName, (Set)null, (TypeConverter)null);\n        &#125;\n\n当b.get()被调用时，会进入DefaultListableBeanFactory.this.doResolveDependency(this.descriptor,  this.beanName, (Set)null, (TypeConverter)null)；使用已经创建好的Bean\n使用Scope注解，也会创建代理解决构造器循环依赖 \n在类上添加@Scope(ProxyMode &#x3D; ScopedProxyMode.TARGET.CLASS)\n不推荐使用，因为会产生额外的beanDefination，也会产生额外的单例bean\n","slug":"Spring如何解决循环依赖","date":"2023-05-11T13:26:38.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"a685b627e4865e5f328e43bd436e0d9e","title":"代理的创建时机","content":"代理的创建时机代理的创建时机\n创建 -&gt; ( * ) 依赖注入 -&gt; 初始化 ( * )\n\n初始化之后 (无循环依赖时)\n\n实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\n\n\npublic class A17_1 &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(Config.class);\n        context.refresh();\n        context.close();\n        // 创建 -> (*) 依赖注入 -> 初始化 (*)\n        /*\n            学到了什么\n                a. 代理的创建时机\n                    1. 初始化之后 (无循环依赖时)\n                    2. 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\n                b. 依赖注入与初始化不应该被增强, 仍应被施加于原始对象\n         */\n    &#125;\n\n    @Configuration\n    static class Config &#123;\n        @Bean // 解析 @Aspect、产生代理\n        public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() &#123;\n            return new AnnotationAwareAspectJAutoProxyCreator();\n        &#125;\n\n        @Bean // 解析 @Autowired\n        public AutowiredAnnotationBeanPostProcessor autowiredAnnotationBeanPostProcessor() &#123;\n            return new AutowiredAnnotationBeanPostProcessor();\n        &#125;\n\n        @Bean // 解析 @PostConstruct\n        public CommonAnnotationBeanPostProcessor commonAnnotationBeanPostProcessor() &#123;\n            return new CommonAnnotationBeanPostProcessor();\n        &#125;\n\n        @Bean\n        public Advisor advisor(MethodInterceptor advice) &#123;\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            return new DefaultPointcutAdvisor(pointcut, advice);\n        &#125;\n\n        @Bean\n        public MethodInterceptor advice() &#123;\n            return (MethodInvocation invocation) -> &#123;\n                System.out.println(\"before...\");\n                return invocation.proceed();\n            &#125;;\n        &#125;\n\n        @Bean\n        public Bean1 bean1() &#123;\n            return new Bean1();\n        &#125;\n\n        @Bean\n        public Bean2 bean2() &#123;\n            return new Bean2();\n        &#125;\n    &#125;\n\n    static class Bean1 &#123;\n        public void foo() &#123;\n\n        &#125;\n        public Bean1() &#123;\n            System.out.println(\"Bean1()\");\n        &#125;\n        /*\n        @Autowired \n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"Bean1 setBean2(bean2) class is: \" + bean2.getClass());\n        &#125;*/\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean1 init()\");\n        &#125;\n    &#125;\n\n    static class Bean2 &#123;\n        public Bean2() &#123;\n            System.out.println(\"Bean2()\");\n        &#125;\n        @Autowired \n        public void setBean1(Bean1 bean1) &#123;\n            System.out.println(\"Bean2 setBean1(bean1) class is: \" + bean1.getClass());\n        &#125;\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean2 init()\");\n        &#125;\n    &#125;\n&#125;\n\n以上例子是一个单向的依赖，Bean2的创建依赖Bean1。代理的创建时机为类的初始化之后\n输出结果&gt;&gt;&gt;&gt;创建Bean1\nBean1()\n&gt;&gt;&gt;&gt;完成初始化\nBean1 init()\n&gt;&gt;&gt;&gt;为bean1创建代理\n[TRACE] 21:09:48.069 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean &#39;bean1&#39; with 0 common interceptors and 2 specific interceptors \n&gt;&gt;&gt;&gt;创建Bean2\nBean2()\n&gt;&gt;&gt;&gt;完成Bean1属性的的依赖注入，注入的是代理\nBean2 setBean1(bean1) class is: class \norg.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$2c2cbac1\n&gt;&gt;&gt;&gt;完成初始化\nBean2 init()\n\n修改Bean1的代码，让Bean1，Bean2存在循环依赖\nstatic class Bean1 &#123;\n        public void foo() &#123;\n\n        &#125;\n        public Bean1() &#123;\n            System.out.println(\"Bean1()\");\n        &#125;\n        @Autowired \n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"Bean1 setBean2(bean2) class is: \" + bean2.getClass());\n        &#125;\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean1 init()\");\n        &#125;\n    &#125;\n\n运行结果如下：>>>创建Bean1，Spring的放入三级缓存，发现需要依赖Bean2，查找缓存没有Bean2，就创建Bean2\nBean1()\n>>>创建Bean2，Spring的放入三级缓存,需要Bean1，查找缓存有Bean1\nBean2()\n>>>创建Bean1的代理\n[TRACE] 21:16:39.601 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean 'bean1' with 0 common interceptors and 2 specific interceptors \n>>>>注入代理对象\nBean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$c459ff85\n>>>>完成初始化\nBean2 init()\n>>>>注入Bean2的代理\nBean1 setBean2(bean2) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean2\n>>>>完成初始化\nBean1 init()\n\n循环依赖时，代理的创建时机被提前到依赖注入之前\n依赖注入（set方法）与初始化（初始化方法）不应该被增强, 仍用原始对象的set和初始化方法\n\n\n","slug":"代理的创建时机","date":"2023-05-11T12:55:58.000Z","categories_index":"","tags_index":"Java,Spring,Proxy","author_index":"大宝贝的程序员"},{"id":"a95318a81b0b3097ed11bab255c7390f","title":"从@Aspect到Advisor","content":"@Aspect—&gt;&gt;AdvisorAnnotationAwareAspectJAutoProxyCreator\nAnnotationAwareAspectJAutoProxyCreator的作用是将高级切面转换成低级切面，使其能够被Spring框架所识别和使用。具体来说，它会读取应用中所有的@Aspect注解，并将这些注解解析成切面的定义。然后，它会对切面定义进行解析，并通过AspectJ编译器将切面转换成可执行的代码块和增强器，并将其绑定到目标对象的代理上。\nfindEligibleAdvisors \n从容器中获取所有的Advisor列表，然后通过匹配切点和目标对象，筛选出适用于该目标对象的Advisor列表。具体包括以下步骤：\n\n获取Spring容器中的所有Advisor。Spring容器中的Advisor代表着切面中定义的增强器，它们用于在目标对象的方法执行前后进行拦截并执行相应的增强逻辑。在这一步中，findEligibleAdvisors方法会从容器中获取所有Advisor对象列表。\n筛选使用AspectJ注解标注的Aspect对象。在这一步中，findEligibleAdvisors方法会遍历所有的Advisor对象，并检查是否是由使用AspectJ注解标注的Aspect对象创建的。如果是，则表示该Advisor属于切面定义的增强逻辑，需要参与目标对象的代理。\n\nwrapIfNecessary\n这个方法的作用是检查目标对象是否需要进行代理，如果需要，则创建代理对象。而目标对象是否需要进行代理，则取决于以下几个因素：\n\n是否启用代理。即是否使用&lt;aop:aspectj-autoproxy&gt;标签启用了自动代理的功能，或者在Java配置中使用@EnableAspectJAutoProxy注解启用了自动代理的功能。\n是否满足代理条件。在Spring框架中，只有当目标对象的类型是非final类或者实现了一个或多个接口时，才能够创建代理对象。否则，Spring框架无法通过动态代理实现对目标对象的增强。\n是否存在增强器。在这个步骤中，Spring框架会调用findAdvisorsThatCanApply方法，查找适合目标对象的增强器列表。如果找到了适合目标对象的增强器，则表示需要为该对象创建代理。\n\n如果目标对象需要创建代理，wrapIfNecessary方法就会根据目标对象的类型，采用不同的代理方式来创建代理对象。如果目标对象实现了一个或多个接口，则使用JDK动态代理的方式进行代理；否则，使用CGLIB代理的方式进行代理。\npackage org.springframework.aop.framework.autoproxy;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.aop.Advisor;\n\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationClassPostProcessor;\nimport org.springframework.context.support.GenericApplicationContext;\nimport org.springframework.core.annotation.Order;\n\nimport java.util.List;\n\npublic class TestAspect &#123;\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"aspect1\", Aspect1.class);\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        context.refresh();\n//        for (String name : context.getBeanDefinitionNames()) &#123;\n//            System.out.println(name);\n//        &#125;\n\n        /*\n            第一个重要方法 findEligibleAdvisors 找到有【资格】的 Advisors\n                a. 有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如下例中的 advisor3\n                b. 有【资格】的 Advisor 另一部分是高级的, 解析 @Aspect 后获得\n         */\n        AnnotationAwareAspectJAutoProxyCreator creator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        List&lt;Advisor> advisors = creator.findEligibleAdvisors(Target1.class, \"target1\");\n        for (Advisor advisor : advisors) &#123;\n            System.out.println(advisor);\n        &#125;\n\n        /*\n            第二个重要方法 wrapIfNecessary\n                a. 它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理\n         */\n        Object o1 = creator.wrapIfNecessary(new Target1(), \"target1\", \"target1\");\n        System.out.println(o1.getClass());\n        Object o2 = creator.wrapIfNecessary(new Target2(), \"target2\", \"target2\");\n        System.out.println(o2.getClass());\n\n        ((Target1) o1).foo();\n        /*\n            学到了什么\n                a. 自动代理后处理器 AnnotationAwareAspectJAutoProxyCreator 会帮我们创建代理\n                b. 通常代理创建的活在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行\n                c. 高级的 @Aspect 切面会转换为低级的 Advisor 切面, 理解原理, 大道至简\n         */\n    &#125;\n\n    static class Target1 &#123;\n        public void foo() &#123;\n            System.out.println(\"target1 foo\");\n        &#125;\n    &#125;\n\n    static class Target2 &#123;\n        public void bar() &#123;\n            System.out.println(\"target2 bar\");\n        &#125;\n    &#125;\n\n    @Aspect // 高级切面类\n//    @Order(1)\n    static class Aspect1 &#123;\n        @Before(\"execution(* foo())\")\n        public void before1() &#123;\n            System.out.println(\"aspect1 before1...\");\n        &#125;\n\n        @Before(\"execution(* foo())\")\n        public void before2() &#123;\n            System.out.println(\"aspect1 before2...\");\n        &#125;\n    &#125;\n\n    @Configuration\n    static class Config &#123;\n        @Bean // 低级切面\n        public Advisor advisor3(MethodInterceptor advice3) &#123;\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3);\n            return advisor;\n        &#125;\n        @Bean\n        public MethodInterceptor advice3() &#123;\n            return invocation -> &#123;\n                System.out.println(\"advice3 before...\");\n                Object result = invocation.proceed();\n                System.out.println(\"advice3 after...\");\n                return result;\n            &#125;;\n        &#125;\n    &#125;\n\n&#125;\n\n\n输出结果org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR\n>>>>>>>>>>>>>>>>>>>>>>>>>>>低级切面\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda$117/0x0000000800d64950@d41f816]\n>>>>>>>>>>>>>>>>>>>>>>>>>>>被解析成低级切面的高级切面\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before1()]; perClauseKind=SINGLETON\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before2()]; perClauseKind=SINGLETON\n>>>>>>>>>>>>>>>>>>>>>>>>Target1匹配切面，会创建代理\nclass org.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$$7efd35eb\n>>>>>>>>>>>>>>>>>>>>>>>>Target2不匹配切面，不会创建代理\nclass org.springframework.aop.framework.autoproxy.A17$Target2\nadvice3 before...\naspect1 before1...\naspect1 before2...\ntarget1 foo\nadvice3 after...\n\n  \n\n","slug":"从@Aspect到Advisor","date":"2023-05-11T12:04:08.000Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"},{"id":"d3cf2f31cfa6170a433ba0c99bf2326a","title":"切点匹配规则","content":"切点匹配规则AspectJ使用切点指示器（Pointcut Designator）来描述需要匹配的切点，切点指示器定义了切点的名称、参数、返回类型、标注等信息。切点指示器可以根据需要使用通配符、逻辑运算符、正则表达式等方式来描述切点。\nAspectJ中的切点指示符主要分为以下几种：\n\nexecution：匹配方法执行的连接点，以方法的访问修饰符、返回类型、类名、方法名和参数决定。\nwithin：匹配指定类型内的方法执行。\nthis：匹配当前AOP代理对象类型的执行方法。\ntarget：匹配当前目标对象类型的执行方法。\nargs：匹配当前执行的方法传入参数为指定类型的执行方法。\nannotation：匹配当前执行方法持有指定注解的方法执行。\nbean：匹配指定名称的bean中的方法执行。\ncflow：匹配满足条件的方法的任何调用。\nif：用于组合其他切点指示器。\n\n使用切点指示器可以非常方便的定义Spring中的切点表达式，如：@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)\npublic void servicePointcut() &#123;&#125;\n\n@Pointcut(&quot;execution(* com.example.dao.*.*(..))&quot;)\npublic void daoPointcut() &#123;&#125;\n\n@Pointcut(&quot;within(com.example.*)&quot;)\npublic void withinPointcut() &#123;&#125;\n\n@Pointcut(&quot;@annotation(com.example.annotation.Loggable)&quot;)\npublic void annotationPointcut() &#123;&#125;\n\n上面的代码定义了四个切点表达式，分别对应于拦截service包、dao包、com.example包下的所有方法和所有标有@Loggable注解的方法的拦截。在实际使用时，可以将这些切点表达式和Advice组合成Advisor，通过使用AOP来实现对目标方法的拦截。\naspectj 切点的局限性\n实际的 @Transactional 切点实现，无法匹配实现了接口添加了@Transactional注解的类的方法\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.support.StaticMethodMatcherPointcut;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.lang.reflect.Method;\n\npublic class A16 &#123;\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n//        AspectJExpressionPointcut无法处理加载类上的信息\n//        检查是否匹配成功  execution\n        AspectJExpressionPointcut pt1 = new AspectJExpressionPointcut();\n        pt1.setExpression(\"execution(* bar())\");\n        System.out.println(pt1.matches(T1.class.getMethod(\"foo\"), T1.class));//false\n        System.out.println(pt1.matches(T1.class.getMethod(\"bar\"), T1.class));//true\n//        根据方法注解进行匹配  @annotation表达式\n        AspectJExpressionPointcut pt2 = new AspectJExpressionPointcut();\n        pt2.setExpression(\"@annotation(org.springframework.transaction.annotation.Transactional)\");\n        System.out.println(pt2.matches(T1.class.getMethod(\"foo\"), T1.class));//true\n        System.out.println(pt2.matches(T1.class.getMethod(\"bar\"), T3.class));//false\n       \n    &#125;\n    static class T1 &#123;\n        @Transactional\n        public void foo() &#123;\n        &#125;\n        public void bar() &#123;\n        &#125;\n    &#125;\n\n    @Transactional\n    static class T2 &#123;\n        public void foo() &#123;\n        &#125;\n    &#125;\n\n    @Transactional\n    interface I3 &#123;\n        void foo();\n    &#125;\n    static class T3 implements I3 &#123;\n        public void foo() &#123;\n        &#125;\n    &#125;\n&#125;\n\nSpring如何解决\nStaticMethodMatcherPointcut是Spring框架中用于匹配静态方法的切点对象。在AOP编程中，切点用于定义在哪些方法执行时会被拦截并执行增强逻辑。StaticMethodMatcherPointcut基于指定的规则匹配静态方法并确定在这些方法执行时是否要进行拦截。\nStaticMethodMatcherPointcut的匹配规则根据传入的Class和方法Method对象进行判断，只有当方法符合预定义的规则时，切点才会拦截方法执行，否则会被忽略。通常，可以通过实现matches方法来自定义匹配规则，只拦截符合条件的目标方法。\n//        StaticMethodMatcherPointcut抽象类可以处理类上的信息，实现match方法\n        StaticMethodMatcherPointcut pt3 = new StaticMethodMatcherPointcut() &#123;\n            @Override               //方法                    类\n            public boolean matches(Method method, Class&lt;?> targetClass) &#123;\n                // 读取方法信息，检查方法上是否加了 Transactional 注解\n                MergedAnnotations annotations = MergedAnnotations.from(method);\n                if (annotations.isPresent(Transactional.class)) &#123;\n                    return true;\n                &#125;\n    \t\t\t// 读取方法信息类信息，查看类上是否加了 Transactional 注解\n                //默认只查看本类删是否含有相应信息，修改成SearchStrategy.TYPE_HIERARCHY\n                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n                if (annotations.isPresent(Transactional.class)) &#123;\n                    return true;\n                &#125;\n                return false;\n            &#125;\n        &#125;;\n\n        System.out.println(pt3.matches(T1.class.getMethod(\"foo\"), T1.class));//true\n        System.out.println(pt3.matches(T1.class.getMethod(\"bar\"), T1.class));//false\n        System.out.println(pt3.matches(T2.class.getMethod(\"foo\"), T2.class));//true\n        System.out.println(pt3.matches(T3.class.getMethod(\"foo\"), T3.class));//true\n\n\n\n\n底层切点实现是如何匹配的: 调用了 aspectj 的匹配方法\n\n比较关键的是它实现了 MethodMatcher 接口, 用来执行方法的匹配\n\n\n","slug":"切点匹配规则","date":"2023-05-11T09:35:15.000Z","categories_index":"","tags_index":"Java,Spring","author_index":"大宝贝的程序员"},{"id":"42403d33a4a316854760bf766fee144b","title":"JDK和CGlib在Spring中的统一","content":"JDK和CGlib在Spring中的统一Spring 中对切点、通知、切面的抽象如下\n\n切点：接口 Pointcut，典型实现 AspectJExpressionPointcut\n通知：典型接口为 MethodInterceptor 代表环绕通知\n切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut\n\nclassDiagram\n\nclass Advice\nclass MethodInterceptor\nclass Advisor\nclass PointcutAdvisor\n\nPointcut &lt;|-- AspectJExpressionPointcut\nAdvice &lt;|-- MethodInterceptor\nAdvisor &lt;|-- PointcutAdvisor\nPointcutAdvisor o-- \"一\" Pointcut\nPointcutAdvisor o-- \"一\" Advice\n\n&lt;&lt;interface>> Advice\n&lt;&lt;interface>> MethodInterceptor\n&lt;&lt;interface>> Pointcut\n&lt;&lt;interface>> Advisor\n&lt;&lt;interface>> PointcutAdvisor\n\n代理相关类图\n\nAopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现\nAopProxy 通过 getProxy 创建代理对象\n图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）\n调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor\n\nclassDiagram\n\nAdvised &lt;|-- ProxyFactory\nProxyFactory o-- Target\nProxyFactory o-- \"多\" Advisor\n\nProxyFactory --> AopProxyFactory : 使用\nAopProxyFactory --> AopProxy\nAdvised &lt;|-- 基于CGLIB的Proxy\n基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建\nAopProxy &lt;|-- ObjenesisCglibAopProxy\nAopProxy &lt;|-- JdkDynamicAopProxy\n基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建\nAdvised &lt;|-- 基于JDK的Proxy\n\nclass AopProxy &#123;\n   +getProxy() Object\n&#125;\n\nclass ProxyFactory &#123;\n\tproxyTargetClass : boolean\n&#125;\n\nclass ObjenesisCglibAopProxy &#123;\n\tadvised : ProxyFactory\n&#125;\n\nclass JdkDynamicAopProxy &#123;\n\tadvised : ProxyFactory\n&#125;\n\n&lt;&lt;interface>> Advised\n&lt;&lt;interface>> AopProxyFactory\n&lt;&lt;interface>> AopProxy\n\n\n\n在 Spring 中，JDK动态代理和CGLIB动态代理会被自动地统一使用。Spring框架会自动选择合适的代理方式，以确保代理对象的正确性和高效性。\n如果我们希望代理的对象实现了接口，那么我们可以选择使用 JDK 动态代理。相比 CGLIB 动态代理，JDK 动态代理的代理对象更加轻量级，因为直接实现了目标对象的接口。\n如果我们希望代理对象没有实现接口，那么我们只能使用 CGLIB 动态代理。CGLIB 动态代理会在运行时生成代理对象的子类，并重写目标对象的方法。所以 CGLIB 动态代理的代理对象比 JDK 动态代理的代理对象更加强大和灵活，但同时也更加重量级。\n总之，在使用 Spring 框架中的 AOP 时，我们只需要关注代理对象是否实现了接口，Spring 会根据情况自动选择使用 JDK 动态代理还是 CGLIB 动态代理。如果我们希望选择特定的代理方式，可以通过在 Spring 配置文件中进行配置来实现。\n模拟Spring创建代理的使用jdk或者cglib&#x2F;&#x2F;要注意导包：MethodInterceptor是与 cglib的 MethodInterceptor 同名的\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\n\npublic class TestSpringAop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;*\n            两个切面概念\n            aspect &#x3D;\n                通知1(advice) +  切点1(pointcut)\n                通知2(advice) +  切点2(pointcut)\n                通知3(advice) +  切点3(pointcut)\n                ...\n            advisor &#x3D; 更细粒度的切面，包含一个通知和切点\n         *&#x2F;\n\n        &#x2F;&#x2F; 1. 准备好切点\n        AspectJExpressionPointcut pointcut &#x3D; new AspectJExpressionPointcut();\n        pointcut.setExpression(&quot;execution(* foo())&quot;);\n        &#x2F;&#x2F; 2. 准备好通知  MethodInterceptor与cglib的MethodInterceptor不一样\n        &#x2F;&#x2F;本质上是环绕通知\n        MethodInterceptor advice &#x3D; new MethodInterceptor() &#123;\n            @Override\n            public Object invoke(MethodInvocation invocation) throws Throwable &#123;\n                System.out.println(&quot;before...&quot;);\n                Object result &#x3D; invocation.proceed(); &#x2F;&#x2F; 调用目标\n                System.out.println(&quot;after...&quot;);\n                return result;\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 3. 备好切面\n        DefaultPointcutAdvisor advisor &#x3D; new DefaultPointcutAdvisor(pointcut, advice);\n        &#x2F;&#x2F; 4. 创建代理\n        Target2 target &#x3D; new Target2();\n        ProxyFactory factory &#x3D; new ProxyFactory();\n        factory.setTarget(target);\n        factory.addAdvisor(advisor);\n        &#x2F;&#x2F;获取接口类型 factory无法判断是否实现了接口，需要手动设置\n        factory.setInterfaces(target.getClass().getInterfaces());\n        factory.setProxyTargetClass(false);\n        Target2 proxy &#x3D; (Target2) factory.getProxy();\n        &#x2F;&#x2F;cglib代理\n        System.out.println(proxy.getClass());\n        proxy.foo();\n        proxy.bar();\n        &#x2F;*\n            学到了什么\n                a. Spring 的代理选择规则\n                b. 底层的切点实现\n                c. 底层的通知实现\n                d. ProxyFactory 是用来创建代理的核心实现, 用 AopProxyFactory 选择具体代理实现\n                    - JdkDynamicAopProxy\n                    - ObjenesisCglibAopProxy\n         *&#x2F;\n    &#125;\n\n    interface I1 &#123;\n        void foo();\n\n        void bar();\n    &#125;\n\n    static class Target1 implements I1 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target1 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target1 bar&quot;);\n        &#125;\n    &#125;\n\n    static class Target2 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target2 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target2 bar&quot;);\n        &#125;\n    &#125;\n&#125;\n\nSpring 的代理选择规：\n\nproxyTargetClass &#x3D; false, 目标实现了接口, 用 jdk 实现\nproxyTargetClass &#x3D; false,  目标没有实现接口, 用 cglib 实现\nproxyTargetClass &#x3D; true, 总是使用 cglib 实现\n\n","slug":"JDK和CGlib在Spring中的统一","date":"2023-05-11T05:01:11.000Z","categories_index":"","tags_index":"Java,Spring,Proxy","author_index":"大宝贝的程序员"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags:\n\nAOP\nSpring\nJava\n\nAOP实现之proxyjdk动态代理\n动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。\n实现动态代理，需要用到以下类和接口：\n\njava.lang.reflect.Proxy：提供了用于创建动态代理的方法newProxyInstance()。\njava.lang.reflect.InvocationHandler：定义了代理对象的调用处理器，负责实现代理对象调用的逻辑以及需要增强的代码。\n\n代理对象调用的流程如下：\n\n当代理对象的方法被调用时，会被转发到InvocationHandler的invoke()方法。\n在invoke()方法中，根据调用的方法名和参数，判断需要执行什么样的业务逻辑。\n如果需要增强方法，将增强逻辑插入到调用方法前或后执行，否则直接调用目标对象的方法。\n\n优点\n使用jdk动态代理的好处是可以避免手动编写代理类，提高代码的复用度。同时，由于jdk动态代理是运行时动态生成代理对象，因此不需要针对每个被代理的类手动创建代理类，提高了开发效率。\n缺点\n\n代理对象必须实现接口：由于jdk动态代理是基于接口进行代理的，因此只能够为接口类型的类创建代理对象。如果需要对非接口类型的类进行代理，可以使用CGLib库。\n\n补充说明\nJDK 只能针对接口代理，代理对象和目标对象之间是平级兄弟关系，也就是说代理对象并不是目标对象的子类，而是实现了相同接口的新类型。因此，在理论上，代理对象和目标对象的类型可以是相同的，甚至目标对象可以被 final 修饰。\n示例import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\ninterface Hello &#123;\n    void sayHello();\n&#125;\n\nclass HelloImpl implements Hello &#123;\n    public void sayHello() &#123;\n        System.out.println(\"Hello world!\");\n    &#125;\n&#125;\n\nclass MyInvocationHandler implements InvocationHandler &#123;\n    private Object target;// 目标对象\n\n    public MyInvocationHandler(Object target) &#123;\n        this.target = target;\n    &#125;\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(\"Before Method Invoke\");\n        // 方法.invoke(目标, 参数);\n        Object result = method.invoke(target, args);\n        System.out.println(\"After Method Invoke\");\n        return result;\n    &#125;\n&#125;\n\npublic class ProxyTest &#123;\n    public static void main(String[] args) &#123;\n        HelloImpl hello = new HelloImpl();\n        MyInvocationHandler handler = new MyInvocationHandler(hello);\n        //参数（目标类的类加载器用于运行时动态生成字节码，接口类型，InvocationHandler的具体实现）\n        Hello proxyHello = Proxy.newProxyInstance(hello.getClass().getClassLoader(),\n                hello.getClass().getInterfaces(), handler);\n        proxyHello.sayHello();\n    &#125;\n&#125;\n\n\n\nCGlib代理CGlib是一个开源的Java字节码增强库，可以在运行时动态地生成一个目标类的子类，通过这个子类来实现对目标类的代理（代理的具体实现方式视情况而定）。与JDK动态代理相比，CGlib代理无需目标对象实现接口，能够代理目标对象的方法，包括private、protected修饰的方法。\nCGlib代理的实现中，需要使用到ASM库来生成代理类的字节码。具体而言，ASM是一个轻量级Java字节码操作和生成库，能够在运行时动态生成类的字节码，以达到动态修改类的目的。\n使用CGlib代理时，我们一般需要实现一个MethodInterceptor接口，用来对目标类的方法进行拦截和增强。\nCGLib实现代理的原理可以分为以下几个步骤：\n\n定义一个类，继承被代理类；\n在代理类中定义一个变量，用于持有被代理类的引用；\n在代理类中重写被代理类中的所有需要代理的方法；\n在重写的方法中加入额外的代理逻辑（例如记录方法调用的日志、进行权限验证等）。\n\nCGLib实现代理的步骤：\n\n设置CGLib的Enhancer对象的SuperClass和Callback属性，这样Enhancer就知道要代理哪个类以及代理的具体实现方式；\n使用Enhancer对象的create()方法来生成代理对象。\n\n通过实例了解一下cglib的工作大概流程\n示例1import net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\npublic class CGLibProxyDemo &#123;\n\n    public static void main(String[] args) &#123;\n        RealSubject realSubject = new RealSubject();\n        RealSubject proxy = (RealSubject) Enhancer.create(RealSubject.class, new MyMethodInterceptor(realSubject));\n        proxy.request();\n    &#125;\n\n    static class RealSubject &#123;\n        public void request() &#123;\n            System.out.println(\"RealSubject.request()\");\n        &#125;\n    &#125;\n\t//实现一个MethodInterceptor接口\n    static class MyMethodInterceptor implements MethodInterceptor &#123;\n        private Object target;//目标\n\n        public MyMethodInterceptor(Object target) &#123;\n            this.target = target;\n        &#125;\n\n        @Override\n        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n            System.out.println(\"Before method: \" + method);\n            Object result = method.invoke(target, objects);\n            System.out.println(\"After method: \" + method);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n在这个例子中，MyMethodInterceptor类是实现了CGLib的MethodInterceptor接口，它的作用是在代理类的方法执行时进行拦截和增强。\n通过调用Enhancer.create()方法，我们得到了一个代理对象，它拥有RealSubject类的全部方法，但是在执行request方法时会经过CGLib生成的MyMethodInterceptor拦截器，我们可以在这个拦截器中进行自己的逻辑处理。\n示例2import org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\npublic class CglibProxyDemo &#123;\n\n    static class Target &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n    &#125;\n\n    // 代理是子类型, 目标是父类型\n    public static void main(String[] param) &#123;\n//        Target target = new Target();\n\n        Target proxy = (Target) Enhancer.create(Target.class, new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//  Object result = method.invoke(target, args); // 用方法反射调用目标\n// methodProxy 它可以避免反射调用\n//  Object result = methodProxy.invoke(target, args); // 内部没有用反射, 需要目标 （spring）\n    Object result = methodProxy.invokeSuper(p, args); // 内部没有用反射, 需要代理\n                System.out.println(\"after...\");\n                return result;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n\n    &#125;\n&#125;\n\n有三种调用方式：method.invoke(target, args)  用反射调用目标，性能较低，需要目标对象\n​\t\t\t\t\t\t\t\tmethodProxy.invoke(target, args) 内部没有使用反射，需要目标对象  spring使用的方式\n​\t\t\t\t\t\t\t\tmethodProxy.invokeSuper(p, args) 内部没有使用反射，不需要目标对象\n代理是子类型, 目标是父类型：\n\n当目标使用final修饰，无法代理会报错\n\n当代理方法使用final修饰，不会把错，方法无法得到增强\n\n\n模拟jdk动态代理源码示例public class Test &#123;\n    public static void main(String[] param) &#123;\n        // ⬇️1. 创建代理，这时传入 InvocationHandler\n        Foo proxy = new $Proxy0(new InvocationHandler() &#123;    \n            // ⬇️5. 进入 InvocationHandler\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;\n                // ⬇️6. 功能增强\n                System.out.println(\"before...\");\n                // ⬇️7. 反射调用目标方法\n                return method.invoke(new Target(), args);\n            &#125;\n        &#125;);\n        // ⬇️2. 调用代理方法\n        proxy.foo();\n        proxy.bar();\n    &#125;\n&#125;\n\npublic interface Foo &#123;\n        void foo();\n        int bar();\n    &#125;\n\n\nstatic class Target implements Foo &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n\n        public int bar() &#123;\n            System.out.println(\"target bar\");\n            return 100;\n        &#125;\n    &#125;\n\n\n// ⬇️这就是 jdk 代理类的源码, 秘密都在里面\npublic class $Proxy0 extends Proxy implements Foo &#123;\n\n    public $Proxy0(InvocationHandler h) &#123;\n        super(h);\n    &#125;\n    // ⬇️3. 进入代理方法\n    public void foo() &#123;\n        try &#123;\n            // ⬇️4. 回调 InvocationHandler\n            h.invoke(this, foo, new Object[0]);\n        &#125; catch (RuntimeException | Error e) &#123;\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public int bar() &#123;\n        //用try-catch处理，把catch到的异常抛出，让外界知道代理有没有执行错误\n        try &#123;\n            Object result = h.invoke(this, bar, new Object[0]);\n            return (int) result;\n        &#125; catch (RuntimeException | Error e) &#123;//运行异常直接抛出\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);//检查异常要转换成运行异常再抛出\n        &#125;\n    &#125;\n\n    static Method foo;\n    static Method bar;\n    static &#123;\n        try &#123;\n            foo = A12.Foo.class.getMethod(\"foo\");\n            bar = A12.Foo.class.getMethod(\"bar\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n以上是模拟jdk动态代理对象的源码，通过接口回调将【增强逻辑】置于代理类之外\n但是在真实的场景中，代理对象是看不到的，是程序在运行期间通过asm技术动态生成代理对象的ASMfiled\n\n把ASMfiled导出成一个类（可以通过流读取字节数组，生成代理对象，查看里面的内容）\n\n在Java代理中，ASM框架通常是作为动态代理机制的底层实现，用来生成字节码并创建代理类。具体来说，使用ASM框架创建代理类的过程大致如下：\n\n定义一个ClassWriter对象作为ASM框架生成字节码的输出流；\n通过ClassWriter定义类名和父类名称等相关信息，创建类的定义；\n定义类的字段、构造函数和代理方法等元素，这些元素将会被编码成字节码；\n利用ASM的MethodVisitor类访问器生成方法的字节码实现。MethodVisitor是定义在ASM框架中的一个访问类，用于可以随时提供关于方法的信息；\n生成字节码并将其写入输出流；\n\n示例转载自黑马package com.itheima;\n\nimport org.springframework.asm.*;\n\npublic class $Proxy0Dump implements Opcodes &#123;\n\n    public static byte[] dump() throws Exception &#123;\n\n        ClassWriter cw = new ClassWriter(0);\n        FieldVisitor fv;\n        MethodVisitor mv;\n        AnnotationVisitor av0;\n\n        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"com/itheima/$Proxy0\", null, \"java/lang/reflect/Proxy\", new String[]&#123;\"com/itheima/Foo\"&#125;);\n\n        cw.visitSource(\"$Proxy0.java\", null);\n\n        &#123;\n            fv = cw.visitField(ACC_STATIC, \"foo\", \"Ljava/lang/reflect/Method;\", null, null);\n            fv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            mv.visitLabel(l0);\n            mv.visitLineNumber(11, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/Proxy\", \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", false);\n            Label l1 = new Label();\n            mv.visitLabel(l1);\n            mv.visitLineNumber(12, l1);\n            mv.visitInsn(RETURN);\n            Label l2 = new Label();\n            mv.visitLabel(l2);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l2, 0);\n            mv.visitLocalVariable(\"h\", \"Ljava/lang/reflect/InvocationHandler;\", null, l0, l2, 1);\n            mv.visitMaxs(2, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"foo\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/Throwable\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(17, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETFIELD, \"com/itheima/$Proxy0\", \"h\", \"Ljava/lang/reflect/InvocationHandler;\");\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitInsn(ACONST_NULL);\n            mv.visitMethodInsn(INVOKEINTERFACE, \"java/lang/reflect/InvocationHandler\", \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\", true);\n            mv.visitInsn(POP);\n            mv.visitLabel(l1);\n            mv.visitLineNumber(20, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(18, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/Throwable\"&#125;);\n            mv.visitVarInsn(ASTORE, 1);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(19, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/reflect/UndeclaredThrowableException\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/UndeclaredThrowableException\", \"&lt;init>\", \"(Ljava/lang/Throwable;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(21, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            Label l5 = new Label();\n            mv.visitLabel(l5);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/Throwable;\", null, l4, l3, 1);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l5, 0);\n            mv.visitMaxs(4, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_STATIC, \"&lt;clinit>\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/NoSuchMethodException\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(26, l0);\n            mv.visitLdcInsn(Type.getType(\"Lcom/itheima/Foo;\"));\n            mv.visitLdcInsn(\"foo\");\n            mv.visitInsn(ICONST_0);\n            mv.visitTypeInsn(ANEWARRAY, \"java/lang/Class\");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Class\", \"getMethod\", \"(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;\", false);\n            mv.visitFieldInsn(PUTSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitLabel(l1);\n            mv.visitLineNumber(29, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(27, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/NoSuchMethodException\"&#125;);\n            mv.visitVarInsn(ASTORE, 0);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(28, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/NoSuchMethodException\", \"getMessage\", \"()Ljava/lang/String;\", false);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"&lt;init>\", \"(Ljava/lang/String;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(30, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/NoSuchMethodException;\", null, l4, l3, 0);\n            mv.visitMaxs(3, 1);\n            mv.visitEnd();\n        &#125;\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    &#125;\n&#125;\n\n通过调用 代理类的$Proxy0Dump.dump()获取字节数组，用来的加载器加载字节数组\npublic class TestProxy &#123;\n    public static void main(String[] args) throws Exception &#123;\n        byte[] dump = $Proxy0Dump.dump();\n\n        /*FileOutputStream os = new FileOutputStream(\"$Proxy0.class\");\n        os.write(dump, 0, dump.length);\n        os.close();*/\n\n        ClassLoader loader = new ClassLoader() &#123;\n            @Override\n            protected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n                return super.defineClass(name, dump, 0, dump.length);\n            &#125;\n        &#125;;\n        Class&lt;?> proxyClass = loader.loadClass(\"com.itheima.$Proxy0\");\n\n        Constructor&lt;?> constructor = proxyClass.getConstructor(InvocationHandler.class);\n        Foo proxy = (Foo) constructor.newInstance(new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                System.out.println(\"before...\");\n                System.out.println(\"调用目标\");\n                return null;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n    &#125;\n&#125;\n\n\njdk反射方法的优化import java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\npublic class TestMethodInvoke &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Method foo = TestMethodInvoke.class.getMethod(\"foo\", int.class);\n        for (int i = 1; i &lt;= 17; i++) &#123;\n            show(i, foo);\n            foo.invoke(null, i);\n        &#125;\n        System.in.read();\n    &#125;\n\n    // 方法反射调用时, 底层 MethodAccessor 的实现类\n    private static void show(int i, Method foo) throws Exception &#123;\n        Method getMethodAccessor = Method.class.getDeclaredMethod(\"getMethodAccessor\");\n        getMethodAccessor.setAccessible(true);\n        Object invoke = getMethodAccessor.invoke(foo);\n        if (invoke == null) &#123;\n            System.out.println(i + \":\" + null);\n            return;\n        &#125;\n        Field delegate = Class.forName(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\").getDeclaredField(\"delegate\");\n        delegate.setAccessible(true);\n        System.out.println(i + \":\" + delegate.get(invoke));\n    &#125;\n\n    public static void foo(int i) &#123;\n        System.out.println(i + \":\" + \"foo\");\n    &#125;\n&#125;\n\n\n\n前 16 次反射性能较低，是基于Java的MethodAccessor调用的\n\n第 17 次调用会生成代理类，优化为非反射调用\n\n\n模拟 CGlib代理和 jdk 动态代理原理查不多\n\n回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor\n\n调用目标时有所改进，见下面代码片段\n\nmethod.invoke 是反射调用，必须调用到足够次数才会进行优化\n\nmethodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）\n\nmethodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象\n\n\n\n\n//代理对象\npublic class Proxy extends Target &#123;\n    private MethodInterceptor methodInterceptor;\n\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) &#123;\n        this.methodInterceptor = methodInterceptor;\n    &#125;\n\n    static Method save0;\n    static Method save1;\n    static Method save2;\n    static MethodProxy save0Proxy;\n    static MethodProxy save1Proxy;\n    static MethodProxy save2Proxy;\n    static &#123;\n        try &#123;\n            save0 = Target.class.getMethod(\"save\");\n            save1 = Target.class.getMethod(\"save\", int.class);\n            save2 = Target.class.getMethod(\"save\", long.class);\n            save0Proxy = MethodProxy.create(Target.class, Proxy.class, \"()V\", \"save\", \"saveSuper\");\n            save1Proxy = MethodProxy.create(Target.class, Proxy.class, \"(I)V\", \"save\", \"saveSuper\");\n            save2Proxy = MethodProxy.create(Target.class, Proxy.class, \"(J)V\", \"save\", \"saveSuper\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带原始功能的方法\n    public void saveSuper() &#123;\n        super.save();\n    &#125;\n    public void saveSuper(int i) &#123;\n        super.save(i);\n    &#125;\n    public void saveSuper(long j) &#123;\n        super.save(j);\n    &#125;\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带增强功能的方法\n    @Override\n    public void save() &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save0, new Object[0], save0Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(int i) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save1, new Object[]&#123;i&#125;, save1Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(long j) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save2, new Object[]&#123;j&#125;, save2Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n&#125;\n\n//目标对象\npublic class Target &#123;\n    public void save() &#123;\n        System.out.println(\"save()\");\n    &#125;\n\n    public void save(int i) &#123;\n        System.out.println(\"save(int)\");\n    &#125;\n\n    public void save(long j) &#123;\n        System.out.println(\"save(long)\");\n    &#125;\n&#125;\n\npublic class A13 &#123;\n\n    public static void main(String[] args) &#123;\n        Proxy proxy = new Proxy();\n        Target target = new Target();\n        proxy.setMethodInterceptor(new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args,\n                                    MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//                return method.invoke(target, args); // 反射调用\n                // FastClass\n//                return methodProxy.invoke(target, args); // 内部无反射, 结合目标用\n                return methodProxy.invokeSuper(p, args); // 内部无反射, 结合代理用\n            &#125;\n        &#125;);\n\n        proxy.save();\n        proxy.save(1);\n        proxy.save(2L);\n    &#125;\n&#125;\n\nMethodProxy 的 invoke 或 invokeSuper 方法时如何避免反射的调用\nimport org.springframework.cglib.core.Signature;\n\npublic class ProxyFastClass &#123;\n    static Signature s0 = new Signature(\"saveSuper\", \"()V\");\n    static Signature s1 = new Signature(\"saveSuper\", \"(I)V\");\n    static Signature s2 = new Signature(\"saveSuper\", \"(J)V\");\n\n    // 获取代理方法的编号\n    /*\n        Proxy\n            saveSuper()              0\n            saveSuper(int)           1\n            saveSuper(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object proxy, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Proxy) proxy).saveSuper();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Proxy) proxy).saveSuper((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Proxy) proxy).saveSuper((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        ProxyFastClass fastClass = new ProxyFastClass();\n        int index = fastClass.getIndex(new Signature(\"saveSuper\", \"()V\"));\n        System.out.println(index);\n\n        fastClass.invoke(index, new Proxy(), new Object[0]);\n    &#125;\n&#125;\n\n\nimport org.springframework.cglib.core.Signature;\n\npublic class TargetFastClass &#123;\n    static Signature s0 = new Signature(\"save\", \"()V\");\n    static Signature s1 = new Signature(\"save\", \"(I)V\");\n    static Signature s2 = new Signature(\"save\", \"(J)V\");\n\n    // 获取目标方法的编号\n    /*\n        Target\n            save()              0\n            save(int)           1\n            save(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object target, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Target) target).save();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Target) target).save((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Target) target).save((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TargetFastClass fastClass = new TargetFastClass();\n        int index = fastClass.getIndex(new Signature(\"save\", \"(I)V\"));\n        System.out.println(index);\n        fastClass.invoke(index, new Target(), new Object[]&#123;100&#125;);\n    &#125;\n&#125;\n\n\n当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类\nProxyFastClass 配合代理对象一起使用, 避免反射\nTargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)\n\n\nTargetFastClass 记录了 Target 中方法与编号的对应关系\nsave(long) 编号 2\nsave(int) 编号 1\nsave() 编号 0\n首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号\n然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射\n\n\nProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法\nsaveSuper(long) 编号 2，不增强，仅是调用 super.save(long)\nsaveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)\nsaveSuper() 编号 0，不增强, 仅是调用 super.save()\n查找方式与 TargetFastClass 类似\n\n\n为什么有这么麻烦的一套东西呢？\n避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法\n用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死\n\n\n\njdk动态代理和cglib的对比\n\njdk不是一上来就优化，先要调用16次，第17次才会针对一个方法产生一个代理类 ，后面的调用都无需反射\n\ncglib是一开始就产生代理，一个代理类对应两个fastclass,一个配合代理对象使用，另一个配合目标本身，每个fastclass匹配到多个方法，所有产生的代理类的数目相对jdk代理要少\n\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;jdk 和 cglib 在 Spring 中的统一&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"},{"id":"d7e2802c58918040c31b14740192f666","title":"AOP实现之agent类加载","content":"AOP实现之agent类加载","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","categories_index":"","tags_index":"Java,Spring,AOP","author_index":"大宝贝的程序员"},{"id":"594a23198fd2599edc1d35598ede3148","title":"模板方法的设计模式","content":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。\n模板方法设计模式的优点\n\n将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。\n通过把通用方法提取到抽象类中，避免了重复代码的出现，提高了代码的可重用性。\n提高了代码的可扩展性，可以在不修改算法骨架结构的情况下替换部分内容。\n使得算法的实现更加灵活，允许不同子类实现算法骨架的不同部分。\n\n模板方法设计模式的缺点\n\n由于将算法细节分离开，代码的难度可能会增加，这会导致代码的维护成本增加。\n子类对父类的依赖性较高，使得继承的滥用可能会导致代码的复杂性和不可读性增加。\n如果算法骨架的修改较多，可能会导致大量的类都需要进行调整，这会带来一定的开销。\n\n示例首先，创建一个抽象模板类，它定义了一个算法的骨架，并包含一些抽象方法，这些方法将在子类中实现。\npublic abstract class AlgorithmTemplate &#123;\n    public void executeAlgorithm() &#123;\n        initialize();\n        process();\n        finalize();\n    &#125;\n\n    protected abstract void initialize();\n\n    protected abstract void process();\n\n    protected abstract void finalize();\n&#125;\n\n然后，创建几个继承自抽象模板类的具体子类，并实现抽象方法。\npublic class ConcreteAlgorithmA extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Finalizing...&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteAlgorithmB extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Finalizing...&quot;);\n    &#125;\n&#125;\n\n最后，在主程序中使用这些子类来演示模板方法设计模式。\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        AlgorithmTemplate algorithmA = new ConcreteAlgorithmA();\n        AlgorithmTemplate algorithmB = new ConcreteAlgorithmB();\n\n        algorithmA.executeAlgorithm();\n        algorithmB.executeAlgorithm();\n    &#125;\n&#125;\n\n当执行该程序时，输出如下：\nConcreteAlgorithmA: Initializing...\nConcreteAlgorithmA: Processing...\nConcreteAlgorithmA: Finalizing...\nConcreteAlgorithmB: Initializing...\nConcreteAlgorithmB: Processing...\nConcreteAlgorithmB: Finalizing...\n\n可以看出，多个具体子类都通过继承抽象模板类来实现相同的算法骨架。这使得更改算法骨架变得更加容易，并且可以避免重复编写相似的算法代码。\n","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"8ced7c3b7dad33d06ee59bde7028cd4a","title":"策略模式","content":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。\n在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。\n优点\n\n封装了一系列算法：将一系列算法封装在不同的策略类中，使得这些算法可以互相替换而不影响客户端使用。\n可以动态切换算法：客户端可以在运行时动态选择使用哪个算法，实现了算法的动态切换。\n减少了复杂的条件语句：在不使用策略模式时，常常需要使用大量的条件语句来实现不同的算法，这样会使代码变得复杂而难以维护，策略模式可以避免这种情况的发生。\n提高了代码的可复用性：不同的策略类可以被多个客户端使用，提高了代码的重用性和可扩展性。\n\n缺点\n\n增加了类的数量：每个算法都需要一个对应的策略类，这样就会增加类的数量，使代码更加复杂，因此需要适当考虑其使用情况。\n客户端必须了解不同的策略类：客户端必须知道所有可用的策略类，并且自己决定哪一个策略类最适合解决当前的问题，这将增加客户端的困难。\n策略模式无法完全解决复杂的问题：虽然策略模式可以很好地解决简单的问题，但在某些情况下，可能需要多个算法之间的协调和处理，这时使用策略模式就很难实现。\n\n示例//创建一个接口，实现所有算法类都要实现的方法\ninterface Operation &#123;\n    double calculate(double a, double b);\n&#125;\n\n//创建算法类和实现Operation接口\nclass Addition implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\nclass Subtraction implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a - b;\n    &#125;\n&#125;\n\nclass Multiplication implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a * b;\n    &#125;\n&#125;\n\n//创建一个Context类，用来设置实际的策略\nclass Calculator &#123;\n    private Operation operation;\n\n    public void setOperation(Operation operation) &#123;\n        this.operation = operation;\n    &#125;\n\n    public double calculate(double a, double b) &#123;\n        return operation.calculate(a, b);\n    &#125;\n&#125;\n\n//使用示例\npublic class StrategyExample &#123;\n    public static void main(String[] args) &#123;\n        double a = 1.5;\n        double b = 2.0;\n\n        Calculator calculator = new Calculator();\n\n        //设置加法运算策略\n        calculator.setOperation(new Addition());\n        System.out.println(calculator.calculate(a, b)); //3.5\n\n        //设置减法运算策略\n        calculator.setOperation(new Subtraction());\n        System.out.println(calculator.calculate(a, b)); //-0.5\n\n        //设置乘法运算策略\n        calculator.setOperation(new Multiplication());\n        System.out.println(calculator.calculate(a, b)); //3.0\n    &#125;\n&#125;\n\n","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"观察者模式它允许一个对象（称为被观察者或主题）维护一组依赖于它的对象（称为观察者），当被观察者发生变化时，它会通知所有观察者以便更新它们自己的状态。\n优点：\n\n在观察者模式中，被观察者和观察者之间是松耦合的关系，使得它们之间的交互变得简单而灵活。\n观察者模式支持广播通信，当一个对象发生改变时，多个观察者会同时得到通知，可以在不同的处理逻辑对其进行响应，提高了系统的可扩展性。\n观察者模式符合面向对象设计原则，将业务分离，使得代码更易于维护和扩展。\n\n缺点：\n\n观察者模式可能会导致系统中的观察者对象过多，造成性能上的问题。\n观察者模式需要考虑到开发效率与运行效率的平衡，在一些特定的场景下，使用观察者模式并不是最佳实践。\n\n应用场景：\n\n一个对象的改变需要同时改变其他对象的时候，可以考虑使用观察者模式。\n当系统中多个对象之间存在着一对多关系：一个对象的改变会影响到其他对象的时候，可以使用观察者模式。\n在分层架构中，可以使用观察者模式来解耦各层之间的关系。\n当需要将一个对象的状态同步到其他对象中，而又不希望耦合太多代码的时候，可以使用观察者模式。\n\n下面是一个Java代码示例首先，我们定义一个主题接口（Subject），定义主题必须实现的方法：\npublic interface Subject &#123;\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers(String msg);\n&#125;\n\n其中，attach(Observer)方法和detach(Observer)方法用于注册和注销观察者，notifyObservers(String)方法用于通知所有注册的观察者主题发生了变化。\n然后，我们定义一个观察者接口（Observer），观察者必须实现的方法：\npublic interface Observer &#123;\n    void update(String msg);\n&#125;\n\n其中，update(String)方法用于接收主题发生变化的通知并进行相应的处理。\n接下来，我们实现Subject接口：\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer> observers = new ArrayList&lt;>();\n    private String state;\n\n    public void attach(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    public void detach(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    public void notifyObservers(String msg) &#123;\n        for (Observer observer : observers) &#123;\n            observer.update(msg);\n        &#125;\n    &#125;\n\n    public void setState(String state) &#123;\n        this.state = state;\n        notifyObservers(\"State changed to \" + state);\n    &#125;\n&#125;\n\n其中，observers是用于存储所有观察者对象的列表，state是主题的状态。\nattach(Observer)方法和detach(Observer)方法用于添加和删除观察者对象，notifyObservers(String)方法用于通知所有观察者主题发生了变化。在setState(String)方法中，每次设置主题状态时都会调用notifyObservers(String)方法通知所有观察者。\n最后，我们实现Observer接口：\npublic class ConcreteObserver implements Observer &#123;\n    private String name;\n\n    public ConcreteObserver(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void update(String msg) &#123;\n        System.out.println(name + \" received message: \" + msg);\n    &#125;\n&#125;\n\n其中，update()方法用于接收主题发生变化的通知并进行相应的处理。\n下面是一个使用观察者模式的示例：\npublic static void main(String[] args) &#123;\n    ConcreteSubject subject = new ConcreteSubject();\n\n    ConcreteObserver observer1 = new ConcreteObserver(\"Observer 1\");\n    ConcreteObserver observer2 = new ConcreteObserver(\"Observer 2\");\n\n    subject.attach(observer1);\n    subject.attach(observer2);\n\n    subject.setState(\"New state\");\n\n    subject.detach(observer1);\n\n    subject.setState(\"Another new state\");\n&#125;\n\n在这个示例中，我们首先创建了一个ConcreteSubject对象，并创建了两个ConcreteObserver对象。然后，我们将两个观察者对象注册到主题对象中，并设置主题状态为“New state”，所有观察者都会收到通知并进行相应的处理。接着，我们将其中一个观察者对象从主题对象中注销，设置主题状态为“Another new state”，只有一个观察者对象会收到通知并进行相应的处理。\n","slug":"观察者模式","date":"2023-05-09T12:47:06.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"2b09bf65e737f820cf301fb7434c8c8e","title":"责任链模式","content":"责任链模式责任链模式是一种行为设计模式，用于将请求从一个处理程序传递到另一个处理程序，直到找到能够处理请求的处理程序。每个处理程序都将请求传递给下一个处理程序，直到请求被处理为止。\n责任链模式的特点\n\n请求发送者不必知道请求在何时、何处以及如何被处理。\n可以动态增加或修改请求的处理流程，增强了系统的灵活性、可维护性、可扩展性。\n处理程序之间解耦，互相独立，易于单元测试和调试。\n可以避免请求的发送者和接收者的耦合关系，提高系统的灵活性。\n\n责任链模式的优点\n\n单一职责原则：每个处理程序只负责处理自己专业领域内的请求。\n开闭原则：可以很方便地增加或删除处理程序，同时不会影响到其他处理程序。\n易于扩展：可以根据需要动态地增加或修改请求的处理流程。具有很好的灵活性和可扩展性。\n代码复用性高：能够避免大量重复代码的产生，减少了系统的维护成本。\n\n责任链模式的缺点\n\n无法保证请求一定被处理：如果链中没有任何一个处理程序能够处理请求，那么请求可能会被忽略或者丢失。\n可能导致系统性能下降：由于处理程序是动态添加的，可能会导致系统的处理过程比较缓慢、效率较低。\n可能会产生很多细粒度的对象：如果责任链比较长，那么可能会产生很多细粒度的对象，导致系统资源的浪费。\n\n示例public abstract class Handler &#123;\n \n    protected Handler successor;\n \n    public void setSuccessor(Handler successor) &#123;\n        this.successor = successor;\n    &#125;\n \n    public abstract void handleRequest(Request request);\n&#125;\n\npublic class ConcreteHandler1 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE1) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler1\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class ConcreteHandler2 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE2) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler2\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class Request &#123;\n     \n    private RequestType type;\n    private String name;\n \n    public Request(RequestType type, String name) &#123;\n        this.type = type;\n        this.name = name;\n    &#125;\n \n    public RequestType getType() &#123;\n        return type;\n    &#125;\n \n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;\n\npublic enum RequestType &#123;\n    TYPE1, TYPE2\n&#125;\n\npublic class Main &#123;\n \n    public static void main(String[] args) &#123;\n        Handler handler1 = new ConcreteHandler1();\n        Handler handler2 = new ConcreteHandler2();\n         \n        handler1.setSuccessor(handler2);\n \n        Request request1 = new Request(RequestType.TYPE1, \"Request 1\");\n        Request request2 = new Request(RequestType.TYPE2, \"Request 2\");\n \n        handler1.handleRequest(request1);\n        handler1.handleRequest(request2);\n    &#125;\n&#125;\n\n在上面的示例中，我们定义了一个抽象处理程序类Handler，它包含一个指向下一个处理程序的引用。然后我们创建了两个具体的处理程序类ConcreteHandler1和ConcreteHandler2，它们都继承了Handler类并实现了handleRequest()方法。\n我们还创建了一个Request类和一个枚举类型RequestType用于模拟请求对象。最后，我们在Main类中创建了两个请求对象并将它们传递给链中的第一个处理程序ConcreteHandler1。\n在上面的示例中，如果请求类型是TYPE1，则它由ConcreteHandler1处理，否则它将传递给下一个处理程序。如果请求类型是TYPE2，则它由ConcreteHandler2处理，否则它将传递给下一个处理程序，直到找到能够处理请求的处理程序。\n","slug":"责任链模式","date":"2023-05-09T12:16:17.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"424f199f6c88af138e76cfdf85fb4fa5","title":"代理模式","content":"代理模式它为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，可以进行一些附加的工作，例如访问控制、远程访问、缓存等。\n以下是一个简单的代理模式的Java例子：interface Image &#123;\n    void display();\n&#125;\n\nclass RealImage implements Image &#123;\n    private String filename;\n\n    public RealImage(String filename) &#123;\n        this.filename = filename;\n        loadFromDisk();\n    &#125;\n\n    private void loadFromDisk() &#123;\n        System.out.println(\"Loading \" + filename);\n    &#125;\n\n    public void display() &#123;\n        System.out.println(\"Displaying \" + filename);\n    &#125;\n&#125;\n\nclass ImageProxy implements Image &#123;\n    private String filename;\n    private RealImage image;\n\n    public ImageProxy(String filename) &#123;\n        this.filename = filename;\n    &#125;\n\n    public void display() &#123;\n        if (image == null)\n            image = new RealImage(filename);\n        image.display();\n    &#125;\n&#125;\n\npublic class ProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        Image image = new ImageProxy(\"test.jpg\");\n        image.display();\n    &#125;\n&#125;\n\n在上面的例子中，我们定义了一个Image接口，其中RealImage是实现此接口的具体对象，它代表了一个真实的图片文件。ImageProxy类也实现了Image接口，但是它并不是真正的图片，而是一个代理。它可以延迟加载RealImage对象，并且在需要时，通过代理实现对RealImage对象的访问。这样，我们就可以控制对RealImage对象的访问并且可以做一些附加的工作。当客户端调用Image的display()方法时，ImageProxy会判断是否已经加载了RealImage对象，如果没有，则创建RealImage对象并调用它的display()方法。\n","slug":"代理模式","date":"2023-05-09T11:52:50.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"af957b16e3777023cafc3b1e9179b2cd","title":"装饰器模式","content":"装饰器模式装饰者模式（Decorator Pattern）\n​\t它允许你向现有对象添加新的功能，同时又不改变其结构。装饰者模式的核心思想是将功能进行分离，让各个类只专注于自己的职责。通过这种方式，我们可以以非常灵活的方式扩展系统的功能，而不必修改原有代码。\n​\t装饰器模式的主要目的是为对象动态地添加额外的功能，不需要修改原始对象的结构。装饰器接收一个原始对象，并在其上添加一些额外的装饰操作，从而增强了原始对象的功能。装饰器模式避免了使用子类继承的方式进行功能扩展，因为这种方式可能导致类层次结构过于复杂，而且无法动态修改对象的行为。\n下面是一个简单的示例：\n首先，我们需要定义一个具有基本功能的接口Component和该接口的一个实现类ConcreteComponent：\npublic interface Component &#123;\n    void operation();\n&#125;\n\npublic class ConcreteComponent implements Component &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"This is a Concrete Component\");\n    &#125;\n&#125;\n\n然后，我们需要创建装饰器Decorator，它持有一个Component实例，并重新实现operation方法：\npublic class Decorator implements Component &#123;\n    private Component component;\n\n    public Decorator(Component component) &#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        component.operation();\n    &#125;\n&#125;\n\n最后，我们创建一个具体的装饰器ConcreteDecorator，它添加了额外的功能：\npublic class ConcreteDecorator extends Decorator &#123;\n    public ConcreteDecorator(Component component) &#123;\n        super(component);\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        super.operation();\n        addedFunction();\n    &#125;\n\n    private void addedFunction() &#123;\n        System.out.println(\"This is an added function\");\n    &#125;\n&#125;\n\n我们可以通过以下方式使用装饰器模式：\nComponent c1 = new ConcreteComponent();\nc1.operation();\n\nComponent c2 = new ConcreteDecorator(new ConcreteComponent());\nc2.operation();\n\nComponent c3 = new ConcreteDecorator(new ConcreteDecorator(new ConcreteComponent()));\nc3.operation();\n\n输出结果：\nThis is a Concrete Component\nThis is a Concrete Component\nThis is an added function\nThis is a Concrete Component\nThis is an added function\nThis is an added function\n\n从输出结果可以看出，通过装饰器模式，我们可以动态地添加额外的功能，而不需要修改原有代码。\n总结一下，装饰器模式是一种非常有用的设计模式，它可以让我们以一种灵活的方式扩展系统的功能。同时，装饰器模式让各个类的职责更加清晰，可以更加方便地进行维护。但是，在使用装饰器模式时，我们需要注意不要过度使用，避免造成代码过于复杂和混乱。\n","slug":"装饰器模式","date":"2023-05-09T11:12:05.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"890198f3e29403fa2d961081f54ed8cd","title":"组合模式","content":"组合模式组合模式 \n主要通过将对象组合成树形结构来表示“整体-部分”的关系，让客户端能够以一致的方式对待单个对象和对象合。\n下面是一个简单的例子import java.util.ArrayList;\nimport java.util.List;\n\npublic interface Employee &#123;\n    void showDetails();\n&#125;\n\nclass Leaf implements Employee &#123;\n    private String name;\n    private String position;\n\n    Leaf(String name, String position) &#123;\n        this.name = name;\n        this.position = position;\n    &#125;\n\n    @Override\n    public void showDetails() &#123;\n        System.out.println(name + \" is a \" + position);\n    &#125;\n&#125;\n\nclass Composite implements Employee &#123;\n    private List&lt;Employee> employees = new ArrayList&lt;Employee>();\n\n    @Override\n    public void showDetails() &#123;\n        for (Employee employee : employees) &#123;\n            employee.showDetails();\n        &#125;\n    &#125;\n\n    public void addEmployee(Employee employee) &#123;\n        employees.add(employee);\n    &#125;\n\n    public void removeEmployee(Employee employee) &#123;\n        employees.remove(employee);\n    &#125;\n&#125;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Composite organization = new Composite();\n        organization.addEmployee(new Leaf(\"John Doe\", \"Manager\"));\n        Composite department = new Composite();\n        department.addEmployee(new Leaf(\"Jane Smith\", \"Team Lead\"));\n        department.addEmployee(new Leaf(\"Bob Johnson\", \"Engineer\"));\n        Composite subDepartment = new Composite();\n        subDepartment.addEmployee(new Leaf(\"Tina Turner\", \"Engineer\"));\n        subDepartment.addEmployee(new Leaf(\"Steve Rogers\", \"Engineer\"));\n        department.addEmployee(subDepartment);\n        organization.addEmployee(department);\n        organization.showDetails();\n    &#125;\n&#125;\n\n在上面的示例中，Employee是一个接口，有两个实现类：Leaf和Composite。Leaf代表的是单个员工，而Composite代表的是员工组合。composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成\n使用组合模式，我们可以创建一个包含多个员工和部门的组织结构，并可以方便地对整个组织结构进行操作。在示例中，我们创建了一个根节点organization，它包含一个员工John Doe和一个部门department。部门department包含一个团队领导Jane Smith和一个工程师Bob Johnson，以及一个子部门subDepartment，子部门subDepartment包含两个工程师Tina Turner和Steve Rogers。最后，我们通过调用organization.showDetails()方法来打印组织结构中每个员工的详细信息。\n","slug":"组合模式","date":"2023-05-09T10:42:25.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"a8b2eb4f810dce05fcecb16e8edfd126","title":"适配器模式","content":"适配器模式适配器模式（Adapter Pattern）是一种结构型设计模式，它用于将一个类的接口转换成客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作。在适配器模式中，适配器充当了两个不兼容接口之间的桥梁，它负责允许这些接口间能够相互协作。\n在Java中，适配器模式常用于将不兼容的接口进行转换，通常包含以下三个角色：\n\nTarget（目标抽象类）：客户端所期望的接口，定义客户端所需的操作。\nAdapter（适配器类）：适配器，将Adaptee转换成Target所期望的接口。它维护了一个指向Adaptee对象的引用，并实现Target接口，使得客户端能够通过Adapter来访问Adaptee对象。\nAdaptee（原本的类）：需要被适配的类，包含原本的方法或接口。\n\n示例我们模拟了一个旧版的Android手机（OldAndroidPhone）和一个新版的iOS手机（NewiPhone），它们分别有不同的音乐播放器接口，而我们需要使用一个适配器（MusicPlayerAdapter）来兼容它们的操作：\n//原有音乐播放接口 \ninterface MusicPlayer &#123;\n    void playMP3(String fileName);\n&#125;\n\n//旧版Android手机\nclass OldAndroidPhone implements MusicPlayer &#123;\n    public void playMP3(String fileName) &#123;\n        System.out.println(\"Old Android phone is playing MP3 file: \" + fileName);\n    &#125;\n&#125;\n\n//新版iPhone手机 \ninterface NewiPhonePlayer &#123;\n    void playAAC(String fileName);\n&#125;\n\nclass NewiPhone implements NewiPhonePlayer &#123;\n    public void playAAC(String fileName) &#123;\n        System.out.println(\"New iPhone is playing AAC file: \" + fileName);\n    &#125;\n&#125;\n\n//适配器，将旧版手机的操作适配成新版手机可以使用的形式\nclass MusicPlayerAdapter implements NewiPhonePlayer &#123;\n    private MusicPlayer player;\n    \n    public MusicPlayerAdapter(MusicPlayer player)&#123;\n        this.player = player;\n    &#125;\n    \n    //适配器将AAC文件转化为MP3文件，并调用原有的播放方法\n    public void playAAC(String fileName) &#123;\n        String mp3File = convertAACtoMP3(fileName);\n        player.playMP3(mp3File);\n    &#125;\n    \n    private String convertAACtoMP3(String fileName)&#123;\n        System.out.println(\"Converting AAC to MP3: \" + fileName);\n        return fileName.replace(\".aac\", \".mp3\");\n    &#125;\n&#125;\n\n//客户端使用例子\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        //旧版Android手机播放MP3\n        MusicPlayer oldPhone = new OldAndroidPhone();\n        oldPhone.playMP3(\"old_phone_music.mp3\");\n        \n        //新版iPhone手机播放AAC，使用适配器兼容播放MP3文件\n        NewiPhonePlayer newPhone = new NewiPhone();\n        MusicPlayerAdapter adapter = new MusicPlayerAdapter(oldPhone);\n        newPhone.playAAC(\"new_phone_music.aac\");\n        adapter.playAAC(\"new_phone_music.aac\");\n    &#125;\n&#125;\n\n在上面的代码中，我们首先定义了两个已有的音乐播放器接口 MusicPlayer 和 NewiPhonePlayer，它们分别被 OldAndroidPhone 和 NewiPhone 实现。然后，我们使用 MusicPlayerAdapter 类将 OldAndroidPhone 类的 playMP3 方法适配成 NewiPhonePlayer 接口的 playAAC 方法，通过这个适配器，新版 iPhone 手机可以兼容旧版 Android 手机的音乐播放功能。在客户端使用时，我们分别调用了 OldAndroidPhone 的 playMP3 方法（旧版 Android 手机）和 NewiPhonePlayer 的 playAAC 方法（新版 iPhone 手机，使用 MusicPlayerAdapter 适配器）。\n我们可以看出适配器模式的优点：\n\n可以让原有的接口和新接口之间不发生冲突地协同工作，从而让代码更好地拓展和维护。\n\n","slug":"适配器模式","date":"2023-05-09T08:09:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"3dbdc722104d94fc07273118e255f7fd","title":"工厂模式","content":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数\n简单工厂UML类图\n\n适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需\n要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较\n复杂。\n简单工厂的例子:\nCalendar类的getInstance方法使用了一种简单工厂的方式来创建不同地区的日历对象。\n具体来说，Calendar类本身是一个抽象类，它定义了一些方法来处理日期和时间。由于不同地区有不同的日历，因此Calendar类并没有直接实现具体的日历，而是通过getInstance方法来获取指定地区的Calendar实例。getInstance方法接受一个Locale类型的参数，它根据不同的Locale参数调用createCalendar方法创建具体的日历实例。createCalendar方法是一个protected方法，由Calendar类的子类来实现。在具体的子类中，根据传入的Locale参数创建相应的日历对象，然后返回。这里，createCalendar方法就扮演了一个简单工厂模式中的工厂的角色，而Calendar类则相当于一个创建工厂，负责整个日历对象的生成过程的调度。\n工厂方法模式在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是提供一个工厂接口，由不同的子类来实现工厂接口中的方法来创建不同的对象。这样做的好处是增加了系统的扩展性和灵活性，可以根据实际需求来增加相应的子类和工厂实现。\n工厂方法模式通常由四部分组成：抽象产品、具体产品、抽象工厂、具体工厂。其中，抽象产品是需要创建的对象的通用接口，具体产品是实现抽象产品接口的具体类，抽象工厂是创建产品的接口，具体工厂是实现抽象工厂接口的具体类。\n工厂方法UML类图：\n\n使用工厂方法模式的好处是：\n\n可扩展性更好。使用工厂方法模式可以更加容易地扩展和添加新的产品类，而不会影响原有的代码结构。\n\n易于维护。工厂方法模式将创建对象的代码集中在一个地方，易于维护。当需要修改时，只需要修改对应的工厂类即可，而不需要修改客户端代码。\n\n降低耦合度。使用工厂方法模式可以将客户端代码和具体产品的实现解耦，使得客户端代码不需要了解每个具体产品类的细节。\n\n\n抽象工厂方法模式抽象工厂模式是工厂方法模式的扩展，旨在提供一个工厂接口来创建一系列相关的产品，而不是单一的产品类。\n抽象工厂模式中会存在多个产品族，每个产品族包含多个产品等级结构。产品等级结构是指具有相同功能的产品组成的集合，例如大众汽车、奥迪汽车和奔驰汽车组成了一个产品族，而每种汽车都具有车轮、车身和发动机等等组成的产品等级结构。\n在抽象工厂模式中，定义一个抽象工厂接口，它包含了一组用于创建产品族中每个产品等级结构的方法。每个具体的工厂类实现这个接口，负责实现自己的产品族生产过程。而具体产品则由具体工厂类中的具体方法实现来创建。\n通过抽象工厂模式，我们可以创造一个家族的对象，这个家族可以看做是一个产品族，而每个家族成员可以看做是这个产品族中的某个产品等级结构。抽象工厂模式保证了各种产品之间的兼容性，即一个工厂创建的产品都是该工厂创建的其他产品的兼容组合。\n抽象工厂UML类图：\n\n示例代码:首先是汽车工厂的抽象类（Abstract Factory）：\n// 定义汽车工厂的抽象类\nabstract class CarFactory &#123;\n    abstract Wheel createWheel();\n    abstract Body createBody();\n    abstract Engine createEngine();\n&#125;\n\n然后是具体的大众汽车工厂类（Volkswagen Car Factory）和奥迪汽车工厂类（Audi Car Factory）：\n// 定义大众汽车工厂\nclass VolkswagenFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new VolkswagenWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new VolkswagenBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new VolkswagenEngine();\n    &#125;\n&#125;\n\n// 定义奥迪汽车工厂\nclass AudiFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new AudiWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new AudiBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new AudiEngine();\n    &#125;\n&#125;\n\n然后是汽车组件的抽象类（Abstract Product）：\n// 定义汽车的组件抽象类\nabstract class Wheel &#123;\n    public abstract void create();\n&#125;\nabstract class Body &#123;\n    public abstract void create();\n&#125;\nabstract class Engine &#123;\n    public abstract void create();\n&#125;\n\n具体的大众和奥迪汽车组件的类：\n// 定义大众汽车组件\nclass VolkswagenWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车轮\");\n    &#125;\n&#125;\nclass VolkswagenBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车身\");\n    &#125;\n&#125;\nclass VolkswagenEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众发动机\");\n    &#125;\n&#125;\n\n// 定义奥迪汽车组件\nclass AudiWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车轮\");\n    &#125;\n&#125;\nclass AudiBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车身\");\n    &#125;\n&#125;\nclass AudiEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪发动机\");\n    &#125;\n&#125;\n\n最后，我们可以使用这些类来创建不同品牌的汽车：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        // 创建大众汽车\n        CarFactory vwFactory = new VolkswagenFactory();\n        vwFactory.createWheel().create();\n        vwFactory.createBody().create();\n        vwFactory.createEngine().create();\n        \n        // 创建奥迪汽车\n        CarFactory audiFactory = new AudiFactory();\n        audiFactory.createWheel().create();\n        audiFactory.createBody().create();\n        audiFactory.createEngine().create();\n    &#125;\n&#125;\n\n","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"b00cac0eae3b04411014ea36945005af","title":"建造者模式","content":"Java建造者模式Java中的建造者模式(Builder Pattern)\n主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。\n该模式包含以下几个角色：\n\nBuilder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。\n\nConcreteBuilder(具体建造者)：实现Builder接口，实现具体产品的创建过程，以及返回具体产品的方法。\n\nDirector(导演者)：负责调用建造者生成产品。\n\nProduct(产品)：表示被生成的复杂对象，包含多个部件。\n\n\n以下是Java中的建造者模式示例代码：\n// Product\nclass Car &#123;\n    private String engine;\n    private String chassis;\n    private String body;\n\n    public void setEngine(String engine) &#123;\n        this.engine = engine;\n    &#125;\n\n    public void setChassis(String chassis) &#123;\n        this.chassis = chassis;\n    &#125;\n\n    public void setBody(String body) &#123;\n        this.body = body;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Car &#123;engine='\" + engine + \"', chassis='\" + chassis + \"', body='\" + body + \"'&#125;\";\n    &#125;\n&#125;\n\n// Builder\ninterface CarBuilder &#123;\n    void buildEngine();\n    void buildChassis();\n    void buildBody();\n    Car getCar();\n&#125;\n\n// ConcreteBuilders\nclass SportsCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SportsCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"3.0L V6\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Aluminum\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Carbon Fiber\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\nclass SedanCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SedanCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"2.4L 4-cylinder\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Steel\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Metal\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\n\n// Director\nclass AutomotiveEngineer &#123;\n    public void build (CarBuilder builder) &#123;\n        builder.buildEngine();\n        builder.buildChassis();\n        builder.buildBody();\n    &#125;\n&#125;\n\npublic class BuilderPatternExample &#123;\n    public static void main(String[] args) &#123;\n        AutomotiveEngineer engineer = new AutomotiveEngineer();\n\n        CarBuilder sportsCarBuilder = new SportsCarBuilder();\n        engineer.build (sportsCarBuilder);\n        System.out.println(sportsCarBuilder.getCar()); \n        // Output: Car &#123;engine='3.0L V6', chassis='Aluminum', body='Carbon Fiber'&#125;\n\n        CarBuilder sedanCarBuilder = new SedanCarBuilder();\n        engineer.build (sedanCarBuilder);\n        System.out.println(sedanCarBuilder.getCar()); \n        // Output: Car &#123;engine='2.4L 4-cylinder', chassis='Steel', body='Metal'&#125;\n    &#125;\n&#125;\n\n在这个示例中，CarBuilder表示抽象建造者，SportsCarBuilder和SedanCarBuilder分别表示具体建造者，AutomotiveEngineer表示导演者，Car表示产品。通过导演者调用具体建造者的构建方法，即可建造出不同的Car实例。\n它的主要亮点有三处：\n\n较为灵活的构建产品对象\n\n在不执行最后 build 方法前，产品对象都不可用\n\n构建过程采用链式调用，看起来比较爽\n\n\n","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"0c6e8405652937a86cc3782f838cf782","title":"spring中常见的设计模式","content":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别\n\n根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it\n\n就是确保只有一个实例提供给全局使用\n\n显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例\n Spring中也有用到单例模式\n\norg.springframework.transaction.TransactionDefinition#withDefaults\n\norg.springframework.aop.TruePointcut#INSTANCE\n\norg.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR\n\norg.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE\n\norg.springframework.core.OrderComparator#INSTANCE\n\n\n2.Spring中的Builder（建造者模式）定义 Separate the construction of a complex object from its representation so that the same construction process can create different representations 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。\n优点：\n\n较为灵活的构建产品对象\n在不执行最后 build 方法前，产品对象都不可用\n构建过程采用链式调用，看起来比较爽\n\nSpring 中体现 Builder 模式的地方：\n\norg.springframework.beans.factory.support.BeanDefinitionBuilder\norg.springframework.web.util.UriComponentsBuilder\norg.springframework.http.ResponseEntity.HeadersBuilder\norg.springframework.http.ResponseEntity.BodyBuilder\n\n3.Spring中的Factory Method(工厂方法模式)定义Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。\nSpring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现\nSpring 中其它工厂：\n\norg.springframework.beans.factory.FactoryBean\n\n@Bean 标注的静态方法及实例方法\n\nObjectFactory 及 ObjectProvider\n\n\n前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题\n4.Spring中的Adapter(适配器模式)定义 Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。\n典型的实现有两处:\n\norg.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有\n@RequestMapping 标注的控制器实现\n传统的基于 Controller 接口（不是 @Controller注解啊）的实现\n较新的基于 RouterFunction 接口的实现\n它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口\n\n\norg.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法\n\n5.Spring中的Composite(组合模式)定义 Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly  即将对象组合成树形结构来表示部分-整体层次结构。组合模式可以让客户端统一地对待单个对象和对象组合。\n典型实现有：\n\norg.springframework.web.method.support.HandlerMethodArgumentResolverComposite\norg.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite\norg.springframework.web.servlet.handler.HandlerExceptionResolverComposite\norg.springframework.web.servlet.view.ViewResolverComposite\n\ncomposite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是：与具体干活的类实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的类实现来完成                                                                     \n6.Spring中的Decorator(装饰器模式)定义 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality 即 向对象动态地附加职责。 装饰器提供了一种灵活的替代继承的方式，以扩展功能。\n典型实现：\n\norg.springframework.web.util.ContentCachingRequestWrapper\n\nContentCachingRequestWrapper 通过包装 HttpServletRequest 对象，提供了对输入流进行重复读取和缓存的功能。其构造函数需要传入一个原始的 HttpServletRequest 对象，然后使用自己的 ByteArrayOutputStream 缓存请求体，同时提供了多个方法来获取请求信息。例如：\n\ngetContentAsByteArray() : 获取请求的内容（byte 数组），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetContentAsStream() : 返回请求的内容流（ServletInputStream），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetReader() : 返回一个读取请求内容的 BufferedReader 实例，如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\n\n总的来说，ContentCachingRequestWrapper 的实现非常好地体现了装饰器模式的思想，通过包装原始请求对象，提供了额外的功能，并且不改变原始对象的行为，从而实现了请求体的缓存和多次读取。\n7.Spring中的Proxy(代理模式)定义 Provide a surrogate or placeholder for another object to control access to it 即，为另一个对象提供一个代理或占位符来控制对它的访问。\n代理模式的主要目的是控制对目标对象的访问，在不改变原有代码的情况下，为对象提供一种间接访问的方式。代理模式在客户端和目标对象之间创建了一个代理对象，客户端通过代理对象来访问目标对象，从而可以对访问进行控制。代理模式可以用于保护目标对象的访问性、缓存对象等。\n与装饰器模式的区别\n装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问\n典型实现：\n\norg.springframework.aop.framework.JdkDynamicAopProxy\norg.springframework.aop.framework.ObjenesisCglibAopProxy\n\n8.Spring中的Chain of Responsibility(责任链模式)定义 Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it 即 避免使用一个对象直接调用另一个对象，而是通过将请求传递给多个对象中的一个来处理请求。将接收对象链接在一起，并将请求沿着链传递，直到一个对象能够处理它。\n典型实现：\n\norg.springframework.web.servlet.HandlerInterceptor\n\nHandlerInterceptor支持责任链模式，通过链式调用多个HandlerInterceptor，可以处理同一个请求的多个这样的拦截器。\n当一个请求到达后端控制器前，可以通过多个HandlerInterceptor按照特定的顺序进行处理。每个HandlerInterceptor可以处理请求，然后将处理结果传递给下一个HandlerInterceptor。这样，就形成了一个责任链。\n在责任链模式中，我们可以动态添加或删除HandlerInterceptor，并且可以定义多个拦截器链。这样，我们可以实现一些复杂的处理逻辑，将请求按照不同的方式进行处理，以达到更好的效果。\n9.Spring 中的 Observer(观察者模式)定义 Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically 即 定义一种一对多的对象依赖关系，这样当一个对象改变状态时，所有其依赖者将自动得到通知并更新。\n典型实现：\n\norg.springframework.context.ApplicationListener\norg.springframework.context.event.ApplicationEventMulticaster\norg.springframework.context.ApplicationEvent\n\n一个事件（ApplicationEvent）可以被ApplicationContext中的一个或多个ApplicationListener所监听。ApplicationContext会在事件发生时通知已注册的ApplicationListener，并由ApplicationListener来负责对该事件做出响应。\n为了实现这种模式，Spring提供了以下几个核心组件：\n\nApplicationEvent：代表了一个应用程序中发生的事件，包含了事件的信息。\nApplicationListener：负责处理事件，并进行响应的组件。\nApplicationEventMulticaster：用于管理事件监听器，负责将事件分发给对应的监听器进行处理。\n\n当一个事件被触发时，ApplicationEventMulticaster会调用所有已注册的ApplicationListener实例的onApplicationEvent()方法来进行处理。当事件被多个ApplicationListener监听时，ApplicationEventMulticaster会按顺序调用它们的onApplicationEvent()方法。\n因此，Spring的事件驱动模型就体现了观察者模式的特征，其中ApplicationListener充当了观察者的角色，ApplicationEventMulticaster充当了被观察者的角色。\n10. Spring 中的 Strategy(策略模式)定义 Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it 即，定义一个算法族，将每个算法封装起来，使它们可以互换。策略模式能够让算法的变化独立于使用它们的客户端。\n典型实现：\n\norg.springframework.beans.factory.support.InstantiationStrategy\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy\norg.springframework.boot.autoconfigure.condition.SearchStrategy\n\norg.springframework.beans.factory.support.InstantiationStrategy：存在多个实现InstantiationStrategy接口的类，这些类都实现了不同的实例化策略，比如：CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy和SmartInstantiationStrategy等。这些实现类可以根据实际情况取舍，通过策略模式实现了实例化策略的动态切换。\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的注解查找策略，比如：TypeMappedAnnotationChecker、RepeatableContainers、DirectlyDeclaredAnnotations和SynthesizedAnnotationDetection等。这些实现类可以根据实际情况取舍，通过策略模式实现了注解查找策略的动态切换。\norg.springframework.boot.autoconfigure.condition.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的条件判断策略，比如：OnClassCondition、ConditionalOnWebApplication和ConditionalOnProperty等。这些实现类可以根据实际情况取舍，通过策略模式实现了条件判断策略的动态切换。\n11. Spring 中的 Template Method(模板方法)定义 Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure  在一个操作中定义算法的框架，将某些步骤延迟到子类中。模板方法让子类重新定义算法的某些步骤，而不改变算法的结构。\n典型实现：\n\n大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate\n很多以 Abstract 命名的类，如 AbstractApplicationContext\n\n在JdbcTemplate中，模板方法是execute()方法，它封装了执行SQL语句的流程，具体的SQL语句可以通过传入不同的参数来实现。execute()方法中包含了一些固定的步骤，如获取连接、创建Statement、执行SQL语句、关闭资源等，这些步骤是不变的，但是具体的SQL语句和参数是可以变化的。通过这种方式，JdbcTemplate将重复的、泛化的操作封装到模板方法中，使得使用者只需要关注具体的SQL语句和参数。\nTransactionTemplate也是类似的，在Spring事务管理中，它封装了执行事务的流程，具体的事务操作可以通过传入不同的参数来实现。TransactionTemplate中的模板方法是execute()方法，它包含了获取事务、执行方法、提交&#x2F;回滚事务等固定步骤，这些步骤是每个事务操作都必须要执行的，但是具体的事务操作可以改变。通过这种方式，TransactionTemplate将事务管理的复杂性封装到模板方法中，使用者只需要关注自己的业务逻辑，而不需要关心事务的管理。\n在AbstractApplicationContext中，模板方法是refresh()方法，该方法包含了Spring容器的初始化流程，具体的初始化过程可以通过继承AbstractApplicationContext的子类来实现。refresh()方法中包含了一些固定的步骤，比如读取配置文件、创建&#x2F;初始化BeanFactory、加载Bean定义、注册BeanPostProcessor等，这些步骤是不变的，但是具体的实现可以改变。子类根据自己的需要，可以通过重写refresh()方法中的一些步骤来实现自己的初始化过程，比如读取不同的配置文件、使用不同的BeanFactory等。\n通过这种方式，AbstractApplicationContext将Spring容器的初始化过程封装到模板方法中，使得使用者只需要关注具体的Bean的配置和使用，而不需要关心Spring容器的初始化过程。这样可以大大简化代码的编写和维护，提高开发效率。\n","slug":"Spring中的设计模式","date":"2023-05-09T04:00:50.000Z","categories_index":"","tags_index":"Java,设计模式,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，\n构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀\n个静态公有⽅法获取实例。\n优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的\n情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，\n与单⼀职责原则冲突。\n单例模式的常⻅写法有哪些？饿汉式顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间。\n\n优点：线程安全，没有加锁，执⾏效率较⾼\n\n缺点：不是懒加载，类加载时就初始化，浪费内存空间\n\n\n\n线程安全：饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程\n的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。\n\n\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123;&#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private final static Singleton instance = new\nSingleton();\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n return instance;\n &#125;\n&#125;\n\n使⽤反射破坏单例public class Test &#123;\n public static void main(String[] args) throws\nException&#123;\n // 使⽤反射破坏单例\n // 获取空参构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(null);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例\n Singleton singleton =\ndeclaredConstructor.newInstance();\n System.out.println(\"反射创建的实例\" + singleton);\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n &#125;\n&#125;\n\n输出结果如下反射创建的实例\ncom.example.spring.demo.single.Singleton@6267c3bb\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n\n线程不安全的懒汉式这种⽅式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的，这⾥列出来是为了和后⾯使⽤锁保证线程安全的单例做对⽐\n\n优点：懒加载\n缺点：线程不安全\n\n//线程不安全的懒汉式单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 判断为 null 的时候再创建对象\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n &#125;\n&#125;\n\n线程安全的懒汉式懒汉式单例如何保证线程安全呢？通过 synchronized 关键字加锁保证线程\n安全， synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这\n⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时\n都需要加锁和释放锁，这样是⾮常影响性能的。\n\n优点：懒加载，线程安全\n\n缺点：效率较低\n\n\n//懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public synchronized static Singleton getInstance() &#123;\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n    &#125;\n&#125;\n\n双重检查锁(DCL)这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么\n要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就\n不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进\n⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调\n⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同\n步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创\n建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单\n例。\n关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁\n竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对\n象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返\n回已创建的单例对象。\n其中最关键的⼀个点就是 volatile 关键字的使⽤，关于 volatile 的详细介\n绍可以直接搜索 volatile 关键字即可，有很多写的⾮常好的⽂章，这⾥不做\n详细介绍，简单说明⼀下，双重检查锁中使⽤ volatile 的两个重要特性：\n可⻅性、禁⽌指令重排序\n当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令\n的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对\nvolatile 修饰的变量的修改对其他任何线程都是可⻅的\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private volatile static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 第⼀重检查是否为 null\n if (instance == null) &#123;\n // 使⽤ synchronized 加锁\n synchronized (Singleton.class) &#123;\n // 第⼆重检查是否为 null\n     if (instance == null) &#123;\n // new 关键字创建对象不是原⼦操作\n instance = new Singleton();\n\t \t\t&#125;\n \t\t&#125;\n \t&#125;\n return instance;\n \t&#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼\n\n缺点：实现较复杂\n\n\n静态内部类//静态内部类实现单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、对外提供获取实例的公共⽅法\n public static Singleton getInstance() &#123;\n return InnerClass.INSTANCE;\n     \n // 定义静态内部类\n private static class InnerClass&#123;\n private final static Singleton INSTANCE = new\nSingleton();\n &#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼，实现简单\n\n静态内部类单例是如何实现懒加载的呢？⾸先，我们先了解下类的加载时机。虚拟机规范要求有且只有 5 种情况必须⽴即对类进⾏初始化（加载、验证、准备需要在此之前开始）：\n\n遇到 new 、 getstatic 、 putstatic 、 invokestatic 这 4 条字节码指令时。⽣成这 4 条指令最常⻅的 Java 代码场景是：使⽤ new 关键字实例化对象的时候、读取或设置⼀个类的静态字段（final 修饰除外，被final 修饰的静态字段是常量，已在编译期把结果放⼊常量池）的时候，以及调⽤⼀个类的静态⽅法的时候。\n使⽤ java.lang.reflect 包⽅法对类进⾏反射调⽤的时候。\n当初始化⼀个类的时候，如果发现其⽗类还没有进⾏过初始化，则需要先触发其⽗类的初始化。\n当虚拟机启动时，⽤户需要指定⼀个要执⾏的主类（包含 main()的那个类），虚拟机会先初始化这个主类。\n当使⽤ JDK 1.7 的动态语⾔⽀持时，如果⼀个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_getStatic 、 REF_putStatic 、 REF_invokeStatic 的⽅法句柄，则需要先触发这个⽅法句柄所对应的类的初始化。\n\n这 5 种情况被称为是类的主动引⽤，注意，这⾥《虚拟机规范》中使⽤的限定词是 “有且仅有”，那么，除此之外的所有引⽤类都不会对类进⾏初始化，称为被动引⽤。静态内部类就属于被动引⽤的情况。\n当 getInstance()⽅法被调⽤时，InnerClass 才在 Singleton 的运⾏时常量池⾥，把符号引⽤替换为直接引⽤，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()⽅法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中⼜是如何保证线程安全的呢？\n虚拟机会保证⼀个类的 () ⽅法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个类的 () ⽅法，其他线程都需要阻塞等待，直到活动线程执⾏() ⽅法完毕。如果在⼀个类的 () ⽅法中有耗时很⻓的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执⾏ () ⽅法后，其他线程唤醒之后不会再次进⼊ () ⽅法。同⼀个加载器下，⼀个类型只会初始化⼀次。)，在实际应⽤中，这种阻塞往往是很隐蔽的。\n所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯⼀性，同时也延迟了单例的实例化。\n枚举单例//枚举实现单例\npublic enum Singleton &#123;\n INSTANCE;\n public void doSomething(String str) &#123;\n System.out.println(str);\n &#125;\n&#125;\n\n\n优点：简单，⾼效，线程安全，可以避免通过反射破坏枚举单例\n\n枚举在 java 中与普通类⼀样，都能拥有字段与⽅法，⽽且枚举实例创建是线程安全的，在任何情况下，它都是⼀个单例，可以直接通过如下⽅式调⽤获取实例：\nSingleton singleton = Singleton.INSTANCE;\n使⽤下⾯的命令反编译枚举类\njavap Singleton.class\n得到如下内容\nCompiled from \"Singleton.java\"\npublic final class com.spring.demo.singleton.Singleton\nextends\njava.lang.Enum&lt;com.spring.demo.singleton.Singleton> &#123;\n public static final\ncom.spring.demo.singleton.Singleton INSTANCE;\n public static com.spring.demo.singleton.Singleton[]\nvalues();\n public static com.spring.demo.singleton.Singleton\nvalueOf(java.lang.String);\n public void doSomething(java.lang.String);\n static &#123;&#125;;\n&#125;\n\n从枚举的反编译结果可以看到，INSTANCE 被 static final 修饰，所以可以通过类名直接调⽤，因为static 类型的属性会在类被加载之后被初始化，当⼀个 Java 类第⼀次被真正使⽤到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的，所以创建⼀个 enum 类型是线程安全的。\n通过反射破坏枚举，实现代码如下：public class Test &#123;\n public static void main(String[] args) throws\nException &#123;\n Singleton singleton = Singleton.INSTANCE;\n singleton.doSomething(\"hello enum\");\n // 尝试使⽤反射破坏单例\n // 枚举类没有空参构造⽅法，反编译后可以看到枚举有⼀个两个\n参数的构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(String.class,\nint.class);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例，这⾥会报错，因为⽆法通过反射创建枚举的实例\n Singleton enumSingleton =\ndeclaredConstructor.newInstance();\n System.out.println(enumSingleton);\n &#125;\n&#125;\n\n运⾏结果报如下错误：\nException in thread \"main\"\njava.lang.IllegalArgumentException: Cannot reflectively\ncreate enum objects at\njava.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492) \nat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\nat com.spring.demo.singleton.Test.main(Test.java:24)\n\n所以⽆法通过反射创建枚举的实例。\n","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"064fd1f961f785b45ddfca5b3ce563ee","title":"spring事务失效的情况以及注意事项","content":"什么是spring事务？​\tSpring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。\n​\tSpring事务的核心思想是将事务管理从具体的数据访问代码中抽象出来。Spring提供了一种集中式的方式来管理事务，这使得我们可以在不修改具体数据访问代码的情况下轻松地添加或删除事务。\nspring事务的优点Spring事务具有以下优点：\n简单性 - Spring事务使得事务管理变得非常简单，只需要添加少量的注释就可以实现。\n可扩展性 - Spring事务提供了各种事务管理器，以适应各种不同的事务需求。它还允许我们自行扩展和定制事务管理器。\n独立性 - Spring事务提供了一种与底层数据访问技术无关的事务管理方式，因此我们可以轻松地更改数据库，而不需要更改事务管理方式。\nspring事务的类型Spring事务有以下常见的类型：\n\n声明式事务 - 该类型的事务是在配置文件或注释中声明的。这使得我们可以轻松地添加和删除事务。\n编程式事务 - 该类型的事务是通过编写代码来实现的。它提供了更细粒度的控制和更高的自定义程度。但是，编写代码会使得代码复杂化。\n\nspring事务失效的情况事务失效的八种场景1.抛出检查异常导致事务不能正确回滚补充什么是检查异常：\nJava中的异常分为两种类型：检查异常和非检查异常。\n检查异常需要使用try-catch语句或者throws声明来处理或抛出，否则编译器会报错。这种异常通常表示程序运行时必须解决的某些错误或不合法操作。例如：IOException、SQLException、ClassNotFoundException等。\n非检查异常是指RuntimeException及其子类异常，不需要在代码中进行特殊处理，程序在运行期间出现这种异常时，会自动触发JVM的异常处理机制。这种异常通常表示程序出现了逻辑或编程错误。例如：NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。\n@Service\npublic class Service1 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n无法事务回滚：Spring默认只会回滚非检查异常\n\n解法：\n配置rollbackFor属性 (什么错误需要回滚)：\n @Transactional(rollbackFor = Exception.class)\n\n\n2.方法内自己try-catch异常导致事务不能正确回滚@Service\npublic class Service2 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount)  &#123;\n        try &#123;\n            int fromBalance = accountMapper.findBalanceBy(from);\n            if (fromBalance - amount >= 0) &#123;\n                accountMapper.update(from, -1 * amount);\n                new FileInputStream(\"hj\");\n                accountMapper.update(to, amount);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n原因：事务通知只有捕捉到了目标方法抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉\n\n方法1：将catch到的异常，包装成运行时异常抛出\n\n在catch块里throw new RuntimeException(e);\n\n\n方法2：手动设置回滚\n\n在catch块添加\nTransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n\n\n\n\n3.aop切面顺序异常导致事务不能正确回滚@Service\npublic class Service3 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n@Aspect\npublic class MyAspect &#123;\n    @Around(\"execution(* transfer(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        LoggerUtils.get().debug(\"log:&#123;&#125;\", pjp.getTarget());\n        try &#123;\n            return pjp.proceed();\n        &#125; catch (Throwable e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.非public方法导致事务失效@Service\npublic class Service4 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n原因：Spring为方法创建代理，添加事务通知，前提条件都是方法为public\n\n方法1：方法改为public\n\n方法2：添加bean配置，不推荐使用\n\n@Bean\npublic TransactionAttributeSource transactionAttributeSource() &#123;\n    return new AnnotationTransactionAttributeSource(false);\n&#125;\n\n\n\n\n\n​\t拓展：AnnotationTransactionAttributeSource\n​\t\tAnnotationTransactionAttributeSource是Spring事务框架中的一个类，用于解析@Transactional注解并以此为基础生成TransactionAttribute对象。TransactionAttribute对象描述了一段方法执行时应该使用的事务属性，包括事务的名字、传播行为、隔离级别、超时时间、只读属性等。\n​\t\t在Spring的事务管理中，事务切面对象会调用AnnotationTransactionAttributeSource对象的getTransactionAttribute()方法，从而获取方法或类级别的事务属性。这种方式可以将事务属性与具体的业务代码解耦，使得业务代码更加简洁可读。\n​\t\tAnnotationTransactionAttributeSource对象有一个布尔类型的构造函数参数，它用于控制@Transactional注解的解析方式。如果这个参数为false，则AnnotationTransactionAttributeSource只会解析@Transactional注解，而不会考虑继承和重载关系，即只解析被注解类或方法上的@Transactional注解，而不考虑其基类和子类以及重载方法中的@Transactional注解。\n​\t\t默认情况下AnnotationTransactionAttributeSource对象的构造函数参数是true，即支持继承和重载的注解解析。但是，在某些特殊情况下，这种解析方式可能会导致一些问题，如事务传播、超时等不被正确解析。此时，可以通过设置构造函数参数为false来禁用这种解析机制，以确保正确地解析@Transactional注解。\n5.父子容器导致的事务失效6.调用本类方法导致传播行为失效7.@Transactional没有保证原子行为8.@Transactional方法导致的synchronized失效","slug":"Spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"94364c933b9df4578d2492ddcb35178f","title":"How to use Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nmyHexoCreate a new post$ hexo new \"title\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"}]