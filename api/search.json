[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags:\n\nAOP\nSpring\nJava\n\nAOP实现之proxyjdk动态代理\n动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。\n实现动态代理，需要用到以下类和接口：\n\njava.lang.reflect.Proxy：提供了用于创建动态代理的方法newProxyInstance()。\njava.lang.reflect.InvocationHandler：定义了代理对象的调用处理器，负责实现代理对象调用的逻辑以及需要增强的代码。\n\n代理对象调用的流程如下：\n\n当代理对象的方法被调用时，会被转发到InvocationHandler的invoke()方法。\n在invoke()方法中，根据调用的方法名和参数，判断需要执行什么样的业务逻辑。\n如果需要增强方法，将增强逻辑插入到调用方法前或后执行，否则直接调用目标对象的方法。\n\n优点\n使用jdk动态代理的好处是可以避免手动编写代理类，提高代码的复用度。同时，由于jdk动态代理是运行时动态生成代理对象，因此不需要针对每个被代理的类手动创建代理类，提高了开发效率。\n缺点\n\n代理对象必须实现接口：由于jdk动态代理是基于接口进行代理的，因此只能够为接口类型的类创建代理对象。如果需要对非接口类型的类进行代理，可以使用CGLib库。\n\n补充说明\nJDK 只能针对接口代理，代理对象和目标对象之间是平级兄弟关系，也就是说代理对象并不是目标对象的子类，而是实现了相同接口的新类型。因此，在理论上，代理对象和目标对象的类型可以是相同的，甚至目标对象可以被 final 修饰。\n示例import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\ninterface Hello &#123;\n    void sayHello();\n&#125;\n\nclass HelloImpl implements Hello &#123;\n    public void sayHello() &#123;\n        System.out.println(\"Hello world!\");\n    &#125;\n&#125;\n\nclass MyInvocationHandler implements InvocationHandler &#123;\n    private Object target;// 目标对象\n\n    public MyInvocationHandler(Object target) &#123;\n        this.target = target;\n    &#125;\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(\"Before Method Invoke\");\n        // 方法.invoke(目标, 参数);\n        Object result = method.invoke(target, args);\n        System.out.println(\"After Method Invoke\");\n        return result;\n    &#125;\n&#125;\n\npublic class ProxyTest &#123;\n    public static void main(String[] args) &#123;\n        HelloImpl hello = new HelloImpl();\n        MyInvocationHandler handler = new MyInvocationHandler(hello);\n        //参数（目标类的类加载器用于运行时动态生成字节码，接口类型，InvocationHandler的具体实现）\n        Hello proxyHello = Proxy.newProxyInstance(hello.getClass().getClassLoader(),\n                hello.getClass().getInterfaces(), handler);\n        proxyHello.sayHello();\n    &#125;\n&#125;\n\n\n\nCGlib代理CGlib是一个开源的Java字节码增强库，可以在运行时动态地生成一个目标类的子类，通过这个子类来实现对目标类的代理（代理的具体实现方式视情况而定）。与JDK动态代理相比，CGlib代理无需目标对象实现接口，能够代理目标对象的方法，包括private、protected修饰的方法。\nCGlib代理的实现中，需要使用到ASM库来生成代理类的字节码。具体而言，ASM是一个轻量级Java字节码操作和生成库，能够在运行时动态生成类的字节码，以达到动态修改类的目的。\n使用CGlib代理时，我们一般需要实现一个MethodInterceptor接口，用来对目标类的方法进行拦截和增强。\nCGLib实现代理的原理可以分为以下几个步骤：\n\n定义一个类，继承被代理类；\n在代理类中定义一个变量，用于持有被代理类的引用；\n在代理类中重写被代理类中的所有需要代理的方法；\n在重写的方法中加入额外的代理逻辑（例如记录方法调用的日志、进行权限验证等）。\n\nCGLib实现代理的步骤：\n\n设置CGLib的Enhancer对象的SuperClass和Callback属性，这样Enhancer就知道要代理哪个类以及代理的具体实现方式；\n使用Enhancer对象的create()方法来生成代理对象。\n\n通过实例了解一下cglib的工作大概流程\n示例1import net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\npublic class CGLibProxyDemo &#123;\n\n    public static void main(String[] args) &#123;\n        RealSubject realSubject = new RealSubject();\n        RealSubject proxy = (RealSubject) Enhancer.create(RealSubject.class, new MyMethodInterceptor(realSubject));\n        proxy.request();\n    &#125;\n\n    static class RealSubject &#123;\n        public void request() &#123;\n            System.out.println(\"RealSubject.request()\");\n        &#125;\n    &#125;\n\t//实现一个MethodInterceptor接口\n    static class MyMethodInterceptor implements MethodInterceptor &#123;\n        private Object target;//目标\n\n        public MyMethodInterceptor(Object target) &#123;\n            this.target = target;\n        &#125;\n\n        @Override\n        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n            System.out.println(\"Before method: \" + method);\n            Object result = method.invoke(target, objects);\n            System.out.println(\"After method: \" + method);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n在这个例子中，MyMethodInterceptor类是实现了CGLib的MethodInterceptor接口，它的作用是在代理类的方法执行时进行拦截和增强。\n通过调用Enhancer.create()方法，我们得到了一个代理对象，它拥有RealSubject类的全部方法，但是在执行request方法时会经过CGLib生成的MyMethodInterceptor拦截器，我们可以在这个拦截器中进行自己的逻辑处理。\n示例2import org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\npublic class CglibProxyDemo &#123;\n\n    static class Target &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n    &#125;\n\n    // 代理是子类型, 目标是父类型\n    public static void main(String[] param) &#123;\n//        Target target = new Target();\n\n        Target proxy = (Target) Enhancer.create(Target.class, new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//  Object result = method.invoke(target, args); // 用方法反射调用目标\n// methodProxy 它可以避免反射调用\n//  Object result = methodProxy.invoke(target, args); // 内部没有用反射, 需要目标 （spring）\n    Object result = methodProxy.invokeSuper(p, args); // 内部没有用反射, 需要代理\n                System.out.println(\"after...\");\n                return result;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n\n    &#125;\n&#125;\n\n有三种调用方式：method.invoke(target, args)  用反射调用目标，性能较低，需要目标对象\n​\t\t\t\t\t\t\t\tmethodProxy.invoke(target, args) 内部没有使用反射，需要目标对象  spring使用的方式\n​\t\t\t\t\t\t\t\tmethodProxy.invokeSuper(p, args) 内部没有使用反射，不需要目标对象\n代理是子类型, 目标是父类型：\n\n当目标使用final修饰，无法代理会报错\n\n当代理方法使用final修饰，不会把错，方法无法得到增强\n\n\n模拟jdk动态代理源码示例public class Test &#123;\n    public static void main(String[] param) &#123;\n        // ⬇️1. 创建代理，这时传入 InvocationHandler\n        Foo proxy = new $Proxy0(new InvocationHandler() &#123;    \n            // ⬇️5. 进入 InvocationHandler\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;\n                // ⬇️6. 功能增强\n                System.out.println(\"before...\");\n                // ⬇️7. 反射调用目标方法\n                return method.invoke(new Target(), args);\n            &#125;\n        &#125;);\n        // ⬇️2. 调用代理方法\n        proxy.foo();\n        proxy.bar();\n    &#125;\n&#125;\n\npublic interface Foo &#123;\n        void foo();\n        int bar();\n    &#125;\n\n\nstatic class Target implements Foo &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n\n        public int bar() &#123;\n            System.out.println(\"target bar\");\n            return 100;\n        &#125;\n    &#125;\n\n\n// ⬇️这就是 jdk 代理类的源码, 秘密都在里面\npublic class $Proxy0 extends Proxy implements Foo &#123;\n\n    public $Proxy0(InvocationHandler h) &#123;\n        super(h);\n    &#125;\n    // ⬇️3. 进入代理方法\n    public void foo() &#123;\n        try &#123;\n            // ⬇️4. 回调 InvocationHandler\n            h.invoke(this, foo, new Object[0]);\n        &#125; catch (RuntimeException | Error e) &#123;\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public int bar() &#123;\n        //用try-catch处理，把catch到的异常抛出，让外界知道代理有没有执行错误\n        try &#123;\n            Object result = h.invoke(this, bar, new Object[0]);\n            return (int) result;\n        &#125; catch (RuntimeException | Error e) &#123;//运行异常直接抛出\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);//检查异常要转换成运行异常再抛出\n        &#125;\n    &#125;\n\n    static Method foo;\n    static Method bar;\n    static &#123;\n        try &#123;\n            foo = A12.Foo.class.getMethod(\"foo\");\n            bar = A12.Foo.class.getMethod(\"bar\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n以上是模拟jdk动态代理对象的源码，通过接口回调将【增强逻辑】置于代理类之外\n但是在真实的场景中，代理对象是看不到的，是程序在运行期间通过asm技术动态生成代理对象的ASMfiled\n\n把ASMfiled导出成一个类（可以通过流读取字节数组，生成代理对象，查看里面的内容）\n\n在Java代理中，ASM框架通常是作为动态代理机制的底层实现，用来生成字节码并创建代理类。具体来说，使用ASM框架创建代理类的过程大致如下：\n\n定义一个ClassWriter对象作为ASM框架生成字节码的输出流；\n通过ClassWriter定义类名和父类名称等相关信息，创建类的定义；\n定义类的字段、构造函数和代理方法等元素，这些元素将会被编码成字节码；\n利用ASM的MethodVisitor类访问器生成方法的字节码实现。MethodVisitor是定义在ASM框架中的一个访问类，用于可以随时提供关于方法的信息；\n生成字节码并将其写入输出流；\n\n示例转载自黑马package com.itheima;\n\nimport org.springframework.asm.*;\n\npublic class $Proxy0Dump implements Opcodes &#123;\n\n    public static byte[] dump() throws Exception &#123;\n\n        ClassWriter cw = new ClassWriter(0);\n        FieldVisitor fv;\n        MethodVisitor mv;\n        AnnotationVisitor av0;\n\n        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"com/itheima/$Proxy0\", null, \"java/lang/reflect/Proxy\", new String[]&#123;\"com/itheima/Foo\"&#125;);\n\n        cw.visitSource(\"$Proxy0.java\", null);\n\n        &#123;\n            fv = cw.visitField(ACC_STATIC, \"foo\", \"Ljava/lang/reflect/Method;\", null, null);\n            fv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            mv.visitLabel(l0);\n            mv.visitLineNumber(11, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/Proxy\", \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", false);\n            Label l1 = new Label();\n            mv.visitLabel(l1);\n            mv.visitLineNumber(12, l1);\n            mv.visitInsn(RETURN);\n            Label l2 = new Label();\n            mv.visitLabel(l2);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l2, 0);\n            mv.visitLocalVariable(\"h\", \"Ljava/lang/reflect/InvocationHandler;\", null, l0, l2, 1);\n            mv.visitMaxs(2, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"foo\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/Throwable\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(17, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETFIELD, \"com/itheima/$Proxy0\", \"h\", \"Ljava/lang/reflect/InvocationHandler;\");\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitInsn(ACONST_NULL);\n            mv.visitMethodInsn(INVOKEINTERFACE, \"java/lang/reflect/InvocationHandler\", \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\", true);\n            mv.visitInsn(POP);\n            mv.visitLabel(l1);\n            mv.visitLineNumber(20, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(18, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/Throwable\"&#125;);\n            mv.visitVarInsn(ASTORE, 1);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(19, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/reflect/UndeclaredThrowableException\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/UndeclaredThrowableException\", \"&lt;init>\", \"(Ljava/lang/Throwable;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(21, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            Label l5 = new Label();\n            mv.visitLabel(l5);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/Throwable;\", null, l4, l3, 1);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l5, 0);\n            mv.visitMaxs(4, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_STATIC, \"&lt;clinit>\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/NoSuchMethodException\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(26, l0);\n            mv.visitLdcInsn(Type.getType(\"Lcom/itheima/Foo;\"));\n            mv.visitLdcInsn(\"foo\");\n            mv.visitInsn(ICONST_0);\n            mv.visitTypeInsn(ANEWARRAY, \"java/lang/Class\");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Class\", \"getMethod\", \"(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;\", false);\n            mv.visitFieldInsn(PUTSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitLabel(l1);\n            mv.visitLineNumber(29, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(27, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/NoSuchMethodException\"&#125;);\n            mv.visitVarInsn(ASTORE, 0);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(28, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/NoSuchMethodException\", \"getMessage\", \"()Ljava/lang/String;\", false);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"&lt;init>\", \"(Ljava/lang/String;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(30, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/NoSuchMethodException;\", null, l4, l3, 0);\n            mv.visitMaxs(3, 1);\n            mv.visitEnd();\n        &#125;\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    &#125;\n&#125;\n\n通过调用 代理类的$Proxy0Dump.dump()获取字节数组，用来的加载器加载字节数组\npublic class TestProxy &#123;\n    public static void main(String[] args) throws Exception &#123;\n        byte[] dump = $Proxy0Dump.dump();\n\n        /*FileOutputStream os = new FileOutputStream(\"$Proxy0.class\");\n        os.write(dump, 0, dump.length);\n        os.close();*/\n\n        ClassLoader loader = new ClassLoader() &#123;\n            @Override\n            protected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n                return super.defineClass(name, dump, 0, dump.length);\n            &#125;\n        &#125;;\n        Class&lt;?> proxyClass = loader.loadClass(\"com.itheima.$Proxy0\");\n\n        Constructor&lt;?> constructor = proxyClass.getConstructor(InvocationHandler.class);\n        Foo proxy = (Foo) constructor.newInstance(new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                System.out.println(\"before...\");\n                System.out.println(\"调用目标\");\n                return null;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n    &#125;\n&#125;\n\n\njdk反射方法的优化import java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\npublic class TestMethodInvoke &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Method foo = TestMethodInvoke.class.getMethod(\"foo\", int.class);\n        for (int i = 1; i &lt;= 17; i++) &#123;\n            show(i, foo);\n            foo.invoke(null, i);\n        &#125;\n        System.in.read();\n    &#125;\n\n    // 方法反射调用时, 底层 MethodAccessor 的实现类\n    private static void show(int i, Method foo) throws Exception &#123;\n        Method getMethodAccessor = Method.class.getDeclaredMethod(\"getMethodAccessor\");\n        getMethodAccessor.setAccessible(true);\n        Object invoke = getMethodAccessor.invoke(foo);\n        if (invoke == null) &#123;\n            System.out.println(i + \":\" + null);\n            return;\n        &#125;\n        Field delegate = Class.forName(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\").getDeclaredField(\"delegate\");\n        delegate.setAccessible(true);\n        System.out.println(i + \":\" + delegate.get(invoke));\n    &#125;\n\n    public static void foo(int i) &#123;\n        System.out.println(i + \":\" + \"foo\");\n    &#125;\n&#125;\n\n\n\n前 16 次反射性能较低，是基于Java的MethodAccessor调用的\n\n第 17 次调用会生成代理类，优化为非反射调用\n\n\n模拟 CGlib代理和 jdk 动态代理原理查不多\n\n回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor\n\n调用目标时有所改进，见下面代码片段\n\nmethod.invoke 是反射调用，必须调用到足够次数才会进行优化\n\nmethodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）\n\nmethodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象\n\n\n\n\n//代理对象\npublic class Proxy extends Target &#123;\n    private MethodInterceptor methodInterceptor;\n\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) &#123;\n        this.methodInterceptor = methodInterceptor;\n    &#125;\n\n    static Method save0;\n    static Method save1;\n    static Method save2;\n    static MethodProxy save0Proxy;\n    static MethodProxy save1Proxy;\n    static MethodProxy save2Proxy;\n    static &#123;\n        try &#123;\n            save0 = Target.class.getMethod(\"save\");\n            save1 = Target.class.getMethod(\"save\", int.class);\n            save2 = Target.class.getMethod(\"save\", long.class);\n            save0Proxy = MethodProxy.create(Target.class, Proxy.class, \"()V\", \"save\", \"saveSuper\");\n            save1Proxy = MethodProxy.create(Target.class, Proxy.class, \"(I)V\", \"save\", \"saveSuper\");\n            save2Proxy = MethodProxy.create(Target.class, Proxy.class, \"(J)V\", \"save\", \"saveSuper\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带原始功能的方法\n    public void saveSuper() &#123;\n        super.save();\n    &#125;\n    public void saveSuper(int i) &#123;\n        super.save(i);\n    &#125;\n    public void saveSuper(long j) &#123;\n        super.save(j);\n    &#125;\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带增强功能的方法\n    @Override\n    public void save() &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save0, new Object[0], save0Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(int i) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save1, new Object[]&#123;i&#125;, save1Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(long j) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save2, new Object[]&#123;j&#125;, save2Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n&#125;\n\n//目标对象\npublic class Target &#123;\n    public void save() &#123;\n        System.out.println(\"save()\");\n    &#125;\n\n    public void save(int i) &#123;\n        System.out.println(\"save(int)\");\n    &#125;\n\n    public void save(long j) &#123;\n        System.out.println(\"save(long)\");\n    &#125;\n&#125;\n\npublic class A13 &#123;\n\n    public static void main(String[] args) &#123;\n        Proxy proxy = new Proxy();\n        Target target = new Target();\n        proxy.setMethodInterceptor(new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args,\n                                    MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//                return method.invoke(target, args); // 反射调用\n                // FastClass\n//                return methodProxy.invoke(target, args); // 内部无反射, 结合目标用\n                return methodProxy.invokeSuper(p, args); // 内部无反射, 结合代理用\n            &#125;\n        &#125;);\n\n        proxy.save();\n        proxy.save(1);\n        proxy.save(2L);\n    &#125;\n&#125;\n\nMethodProxy 的 invoke 或 invokeSuper 方法时如何避免反射的调用\nimport org.springframework.cglib.core.Signature;\n\npublic class ProxyFastClass &#123;\n    static Signature s0 = new Signature(\"saveSuper\", \"()V\");\n    static Signature s1 = new Signature(\"saveSuper\", \"(I)V\");\n    static Signature s2 = new Signature(\"saveSuper\", \"(J)V\");\n\n    // 获取代理方法的编号\n    /*\n        Proxy\n            saveSuper()              0\n            saveSuper(int)           1\n            saveSuper(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object proxy, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Proxy) proxy).saveSuper();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Proxy) proxy).saveSuper((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Proxy) proxy).saveSuper((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        ProxyFastClass fastClass = new ProxyFastClass();\n        int index = fastClass.getIndex(new Signature(\"saveSuper\", \"()V\"));\n        System.out.println(index);\n\n        fastClass.invoke(index, new Proxy(), new Object[0]);\n    &#125;\n&#125;\n\n\nimport org.springframework.cglib.core.Signature;\n\npublic class TargetFastClass &#123;\n    static Signature s0 = new Signature(\"save\", \"()V\");\n    static Signature s1 = new Signature(\"save\", \"(I)V\");\n    static Signature s2 = new Signature(\"save\", \"(J)V\");\n\n    // 获取目标方法的编号\n    /*\n        Target\n            save()              0\n            save(int)           1\n            save(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object target, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Target) target).save();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Target) target).save((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Target) target).save((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TargetFastClass fastClass = new TargetFastClass();\n        int index = fastClass.getIndex(new Signature(\"save\", \"(I)V\"));\n        System.out.println(index);\n        fastClass.invoke(index, new Target(), new Object[]&#123;100&#125;);\n    &#125;\n&#125;\n\n\n当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类\nProxyFastClass 配合代理对象一起使用, 避免反射\nTargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)\n\n\nTargetFastClass 记录了 Target 中方法与编号的对应关系\nsave(long) 编号 2\nsave(int) 编号 1\nsave() 编号 0\n首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号\n然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射\n\n\nProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法\nsaveSuper(long) 编号 2，不增强，仅是调用 super.save(long)\nsaveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)\nsaveSuper() 编号 0，不增强, 仅是调用 super.save()\n查找方式与 TargetFastClass 类似\n\n\n为什么有这么麻烦的一套东西呢？\n避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法\n用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死\n\n\n\njdk 和 cglib 在 Spring 中的统一&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"},{"id":"d7e2802c58918040c31b14740192f666","title":"AOP实现之agent类加载","content":"AOP实现之agent类加载","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","categories_index":"","tags_index":"Java,Spring,AOP","author_index":"大宝贝的程序员"},{"id":"594a23198fd2599edc1d35598ede3148","title":"模板方法的设计模式","content":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。\n模板方法设计模式的优点\n\n将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。\n通过把通用方法提取到抽象类中，避免了重复代码的出现，提高了代码的可重用性。\n提高了代码的可扩展性，可以在不修改算法骨架结构的情况下替换部分内容。\n使得算法的实现更加灵活，允许不同子类实现算法骨架的不同部分。\n\n模板方法设计模式的缺点\n\n由于将算法细节分离开，代码的难度可能会增加，这会导致代码的维护成本增加。\n子类对父类的依赖性较高，使得继承的滥用可能会导致代码的复杂性和不可读性增加。\n如果算法骨架的修改较多，可能会导致大量的类都需要进行调整，这会带来一定的开销。\n\n示例首先，创建一个抽象模板类，它定义了一个算法的骨架，并包含一些抽象方法，这些方法将在子类中实现。\npublic abstract class AlgorithmTemplate &#123;\n    public void executeAlgorithm() &#123;\n        initialize();\n        process();\n        finalize();\n    &#125;\n\n    protected abstract void initialize();\n\n    protected abstract void process();\n\n    protected abstract void finalize();\n&#125;\n\n然后，创建几个继承自抽象模板类的具体子类，并实现抽象方法。\npublic class ConcreteAlgorithmA extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Finalizing...&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteAlgorithmB extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Finalizing...&quot;);\n    &#125;\n&#125;\n\n最后，在主程序中使用这些子类来演示模板方法设计模式。\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        AlgorithmTemplate algorithmA = new ConcreteAlgorithmA();\n        AlgorithmTemplate algorithmB = new ConcreteAlgorithmB();\n\n        algorithmA.executeAlgorithm();\n        algorithmB.executeAlgorithm();\n    &#125;\n&#125;\n\n当执行该程序时，输出如下：\nConcreteAlgorithmA: Initializing...\nConcreteAlgorithmA: Processing...\nConcreteAlgorithmA: Finalizing...\nConcreteAlgorithmB: Initializing...\nConcreteAlgorithmB: Processing...\nConcreteAlgorithmB: Finalizing...\n\n可以看出，多个具体子类都通过继承抽象模板类来实现相同的算法骨架。这使得更改算法骨架变得更加容易，并且可以避免重复编写相似的算法代码。\n","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"8ced7c3b7dad33d06ee59bde7028cd4a","title":"策略模式","content":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。\n在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。\n优点\n\n封装了一系列算法：将一系列算法封装在不同的策略类中，使得这些算法可以互相替换而不影响客户端使用。\n可以动态切换算法：客户端可以在运行时动态选择使用哪个算法，实现了算法的动态切换。\n减少了复杂的条件语句：在不使用策略模式时，常常需要使用大量的条件语句来实现不同的算法，这样会使代码变得复杂而难以维护，策略模式可以避免这种情况的发生。\n提高了代码的可复用性：不同的策略类可以被多个客户端使用，提高了代码的重用性和可扩展性。\n\n缺点\n\n增加了类的数量：每个算法都需要一个对应的策略类，这样就会增加类的数量，使代码更加复杂，因此需要适当考虑其使用情况。\n客户端必须了解不同的策略类：客户端必须知道所有可用的策略类，并且自己决定哪一个策略类最适合解决当前的问题，这将增加客户端的困难。\n策略模式无法完全解决复杂的问题：虽然策略模式可以很好地解决简单的问题，但在某些情况下，可能需要多个算法之间的协调和处理，这时使用策略模式就很难实现。\n\n示例//创建一个接口，实现所有算法类都要实现的方法\ninterface Operation &#123;\n    double calculate(double a, double b);\n&#125;\n\n//创建算法类和实现Operation接口\nclass Addition implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\nclass Subtraction implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a - b;\n    &#125;\n&#125;\n\nclass Multiplication implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a * b;\n    &#125;\n&#125;\n\n//创建一个Context类，用来设置实际的策略\nclass Calculator &#123;\n    private Operation operation;\n\n    public void setOperation(Operation operation) &#123;\n        this.operation = operation;\n    &#125;\n\n    public double calculate(double a, double b) &#123;\n        return operation.calculate(a, b);\n    &#125;\n&#125;\n\n//使用示例\npublic class StrategyExample &#123;\n    public static void main(String[] args) &#123;\n        double a = 1.5;\n        double b = 2.0;\n\n        Calculator calculator = new Calculator();\n\n        //设置加法运算策略\n        calculator.setOperation(new Addition());\n        System.out.println(calculator.calculate(a, b)); //3.5\n\n        //设置减法运算策略\n        calculator.setOperation(new Subtraction());\n        System.out.println(calculator.calculate(a, b)); //-0.5\n\n        //设置乘法运算策略\n        calculator.setOperation(new Multiplication());\n        System.out.println(calculator.calculate(a, b)); //3.0\n    &#125;\n&#125;\n\n","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"观察者模式它允许一个对象（称为被观察者或主题）维护一组依赖于它的对象（称为观察者），当被观察者发生变化时，它会通知所有观察者以便更新它们自己的状态。\n优点：\n\n在观察者模式中，被观察者和观察者之间是松耦合的关系，使得它们之间的交互变得简单而灵活。\n观察者模式支持广播通信，当一个对象发生改变时，多个观察者会同时得到通知，可以在不同的处理逻辑对其进行响应，提高了系统的可扩展性。\n观察者模式符合面向对象设计原则，将业务分离，使得代码更易于维护和扩展。\n\n缺点：\n\n观察者模式可能会导致系统中的观察者对象过多，造成性能上的问题。\n观察者模式需要考虑到开发效率与运行效率的平衡，在一些特定的场景下，使用观察者模式并不是最佳实践。\n\n应用场景：\n\n一个对象的改变需要同时改变其他对象的时候，可以考虑使用观察者模式。\n当系统中多个对象之间存在着一对多关系：一个对象的改变会影响到其他对象的时候，可以使用观察者模式。\n在分层架构中，可以使用观察者模式来解耦各层之间的关系。\n当需要将一个对象的状态同步到其他对象中，而又不希望耦合太多代码的时候，可以使用观察者模式。\n\n下面是一个Java代码示例首先，我们定义一个主题接口（Subject），定义主题必须实现的方法：\npublic interface Subject &#123;\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers(String msg);\n&#125;\n\n其中，attach(Observer)方法和detach(Observer)方法用于注册和注销观察者，notifyObservers(String)方法用于通知所有注册的观察者主题发生了变化。\n然后，我们定义一个观察者接口（Observer），观察者必须实现的方法：\npublic interface Observer &#123;\n    void update(String msg);\n&#125;\n\n其中，update(String)方法用于接收主题发生变化的通知并进行相应的处理。\n接下来，我们实现Subject接口：\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer> observers = new ArrayList&lt;>();\n    private String state;\n\n    public void attach(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    public void detach(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    public void notifyObservers(String msg) &#123;\n        for (Observer observer : observers) &#123;\n            observer.update(msg);\n        &#125;\n    &#125;\n\n    public void setState(String state) &#123;\n        this.state = state;\n        notifyObservers(\"State changed to \" + state);\n    &#125;\n&#125;\n\n其中，observers是用于存储所有观察者对象的列表，state是主题的状态。\nattach(Observer)方法和detach(Observer)方法用于添加和删除观察者对象，notifyObservers(String)方法用于通知所有观察者主题发生了变化。在setState(String)方法中，每次设置主题状态时都会调用notifyObservers(String)方法通知所有观察者。\n最后，我们实现Observer接口：\npublic class ConcreteObserver implements Observer &#123;\n    private String name;\n\n    public ConcreteObserver(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void update(String msg) &#123;\n        System.out.println(name + \" received message: \" + msg);\n    &#125;\n&#125;\n\n其中，update()方法用于接收主题发生变化的通知并进行相应的处理。\n下面是一个使用观察者模式的示例：\npublic static void main(String[] args) &#123;\n    ConcreteSubject subject = new ConcreteSubject();\n\n    ConcreteObserver observer1 = new ConcreteObserver(\"Observer 1\");\n    ConcreteObserver observer2 = new ConcreteObserver(\"Observer 2\");\n\n    subject.attach(observer1);\n    subject.attach(observer2);\n\n    subject.setState(\"New state\");\n\n    subject.detach(observer1);\n\n    subject.setState(\"Another new state\");\n&#125;\n\n在这个示例中，我们首先创建了一个ConcreteSubject对象，并创建了两个ConcreteObserver对象。然后，我们将两个观察者对象注册到主题对象中，并设置主题状态为“New state”，所有观察者都会收到通知并进行相应的处理。接着，我们将其中一个观察者对象从主题对象中注销，设置主题状态为“Another new state”，只有一个观察者对象会收到通知并进行相应的处理。\n","slug":"观察者模式","date":"2023-05-09T12:47:06.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"2b09bf65e737f820cf301fb7434c8c8e","title":"责任链模式","content":"责任链模式责任链模式是一种行为设计模式，用于将请求从一个处理程序传递到另一个处理程序，直到找到能够处理请求的处理程序。每个处理程序都将请求传递给下一个处理程序，直到请求被处理为止。\n责任链模式的特点\n\n请求发送者不必知道请求在何时、何处以及如何被处理。\n可以动态增加或修改请求的处理流程，增强了系统的灵活性、可维护性、可扩展性。\n处理程序之间解耦，互相独立，易于单元测试和调试。\n可以避免请求的发送者和接收者的耦合关系，提高系统的灵活性。\n\n责任链模式的优点\n\n单一职责原则：每个处理程序只负责处理自己专业领域内的请求。\n开闭原则：可以很方便地增加或删除处理程序，同时不会影响到其他处理程序。\n易于扩展：可以根据需要动态地增加或修改请求的处理流程。具有很好的灵活性和可扩展性。\n代码复用性高：能够避免大量重复代码的产生，减少了系统的维护成本。\n\n责任链模式的缺点\n\n无法保证请求一定被处理：如果链中没有任何一个处理程序能够处理请求，那么请求可能会被忽略或者丢失。\n可能导致系统性能下降：由于处理程序是动态添加的，可能会导致系统的处理过程比较缓慢、效率较低。\n可能会产生很多细粒度的对象：如果责任链比较长，那么可能会产生很多细粒度的对象，导致系统资源的浪费。\n\n示例public abstract class Handler &#123;\n \n    protected Handler successor;\n \n    public void setSuccessor(Handler successor) &#123;\n        this.successor = successor;\n    &#125;\n \n    public abstract void handleRequest(Request request);\n&#125;\n\npublic class ConcreteHandler1 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE1) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler1\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class ConcreteHandler2 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE2) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler2\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class Request &#123;\n     \n    private RequestType type;\n    private String name;\n \n    public Request(RequestType type, String name) &#123;\n        this.type = type;\n        this.name = name;\n    &#125;\n \n    public RequestType getType() &#123;\n        return type;\n    &#125;\n \n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;\n\npublic enum RequestType &#123;\n    TYPE1, TYPE2\n&#125;\n\npublic class Main &#123;\n \n    public static void main(String[] args) &#123;\n        Handler handler1 = new ConcreteHandler1();\n        Handler handler2 = new ConcreteHandler2();\n         \n        handler1.setSuccessor(handler2);\n \n        Request request1 = new Request(RequestType.TYPE1, \"Request 1\");\n        Request request2 = new Request(RequestType.TYPE2, \"Request 2\");\n \n        handler1.handleRequest(request1);\n        handler1.handleRequest(request2);\n    &#125;\n&#125;\n\n在上面的示例中，我们定义了一个抽象处理程序类Handler，它包含一个指向下一个处理程序的引用。然后我们创建了两个具体的处理程序类ConcreteHandler1和ConcreteHandler2，它们都继承了Handler类并实现了handleRequest()方法。\n我们还创建了一个Request类和一个枚举类型RequestType用于模拟请求对象。最后，我们在Main类中创建了两个请求对象并将它们传递给链中的第一个处理程序ConcreteHandler1。\n在上面的示例中，如果请求类型是TYPE1，则它由ConcreteHandler1处理，否则它将传递给下一个处理程序。如果请求类型是TYPE2，则它由ConcreteHandler2处理，否则它将传递给下一个处理程序，直到找到能够处理请求的处理程序。\n","slug":"责任链模式","date":"2023-05-09T12:16:17.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"424f199f6c88af138e76cfdf85fb4fa5","title":"代理模式","content":"代理模式它为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，可以进行一些附加的工作，例如访问控制、远程访问、缓存等。\n以下是一个简单的代理模式的Java例子：interface Image &#123;\n    void display();\n&#125;\n\nclass RealImage implements Image &#123;\n    private String filename;\n\n    public RealImage(String filename) &#123;\n        this.filename = filename;\n        loadFromDisk();\n    &#125;\n\n    private void loadFromDisk() &#123;\n        System.out.println(\"Loading \" + filename);\n    &#125;\n\n    public void display() &#123;\n        System.out.println(\"Displaying \" + filename);\n    &#125;\n&#125;\n\nclass ImageProxy implements Image &#123;\n    private String filename;\n    private RealImage image;\n\n    public ImageProxy(String filename) &#123;\n        this.filename = filename;\n    &#125;\n\n    public void display() &#123;\n        if (image == null)\n            image = new RealImage(filename);\n        image.display();\n    &#125;\n&#125;\n\npublic class ProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        Image image = new ImageProxy(\"test.jpg\");\n        image.display();\n    &#125;\n&#125;\n\n在上面的例子中，我们定义了一个Image接口，其中RealImage是实现此接口的具体对象，它代表了一个真实的图片文件。ImageProxy类也实现了Image接口，但是它并不是真正的图片，而是一个代理。它可以延迟加载RealImage对象，并且在需要时，通过代理实现对RealImage对象的访问。这样，我们就可以控制对RealImage对象的访问并且可以做一些附加的工作。当客户端调用Image的display()方法时，ImageProxy会判断是否已经加载了RealImage对象，如果没有，则创建RealImage对象并调用它的display()方法。\n","slug":"代理模式","date":"2023-05-09T11:52:50.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"af957b16e3777023cafc3b1e9179b2cd","title":"装饰器模式","content":"装饰器模式装饰者模式（Decorator Pattern）\n​\t它允许你向现有对象添加新的功能，同时又不改变其结构。装饰者模式的核心思想是将功能进行分离，让各个类只专注于自己的职责。通过这种方式，我们可以以非常灵活的方式扩展系统的功能，而不必修改原有代码。\n​\t装饰器模式的主要目的是为对象动态地添加额外的功能，不需要修改原始对象的结构。装饰器接收一个原始对象，并在其上添加一些额外的装饰操作，从而增强了原始对象的功能。装饰器模式避免了使用子类继承的方式进行功能扩展，因为这种方式可能导致类层次结构过于复杂，而且无法动态修改对象的行为。\n下面是一个简单的示例：\n首先，我们需要定义一个具有基本功能的接口Component和该接口的一个实现类ConcreteComponent：\npublic interface Component &#123;\n    void operation();\n&#125;\n\npublic class ConcreteComponent implements Component &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"This is a Concrete Component\");\n    &#125;\n&#125;\n\n然后，我们需要创建装饰器Decorator，它持有一个Component实例，并重新实现operation方法：\npublic class Decorator implements Component &#123;\n    private Component component;\n\n    public Decorator(Component component) &#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        component.operation();\n    &#125;\n&#125;\n\n最后，我们创建一个具体的装饰器ConcreteDecorator，它添加了额外的功能：\npublic class ConcreteDecorator extends Decorator &#123;\n    public ConcreteDecorator(Component component) &#123;\n        super(component);\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        super.operation();\n        addedFunction();\n    &#125;\n\n    private void addedFunction() &#123;\n        System.out.println(\"This is an added function\");\n    &#125;\n&#125;\n\n我们可以通过以下方式使用装饰器模式：\nComponent c1 = new ConcreteComponent();\nc1.operation();\n\nComponent c2 = new ConcreteDecorator(new ConcreteComponent());\nc2.operation();\n\nComponent c3 = new ConcreteDecorator(new ConcreteDecorator(new ConcreteComponent()));\nc3.operation();\n\n输出结果：\nThis is a Concrete Component\nThis is a Concrete Component\nThis is an added function\nThis is a Concrete Component\nThis is an added function\nThis is an added function\n\n从输出结果可以看出，通过装饰器模式，我们可以动态地添加额外的功能，而不需要修改原有代码。\n总结一下，装饰器模式是一种非常有用的设计模式，它可以让我们以一种灵活的方式扩展系统的功能。同时，装饰器模式让各个类的职责更加清晰，可以更加方便地进行维护。但是，在使用装饰器模式时，我们需要注意不要过度使用，避免造成代码过于复杂和混乱。\n","slug":"装饰器模式","date":"2023-05-09T11:12:05.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"890198f3e29403fa2d961081f54ed8cd","title":"组合模式","content":"组合模式组合模式 \n主要通过将对象组合成树形结构来表示“整体-部分”的关系，让客户端能够以一致的方式对待单个对象和对象合。\n下面是一个简单的例子import java.util.ArrayList;\nimport java.util.List;\n\npublic interface Employee &#123;\n    void showDetails();\n&#125;\n\nclass Leaf implements Employee &#123;\n    private String name;\n    private String position;\n\n    Leaf(String name, String position) &#123;\n        this.name = name;\n        this.position = position;\n    &#125;\n\n    @Override\n    public void showDetails() &#123;\n        System.out.println(name + \" is a \" + position);\n    &#125;\n&#125;\n\nclass Composite implements Employee &#123;\n    private List&lt;Employee> employees = new ArrayList&lt;Employee>();\n\n    @Override\n    public void showDetails() &#123;\n        for (Employee employee : employees) &#123;\n            employee.showDetails();\n        &#125;\n    &#125;\n\n    public void addEmployee(Employee employee) &#123;\n        employees.add(employee);\n    &#125;\n\n    public void removeEmployee(Employee employee) &#123;\n        employees.remove(employee);\n    &#125;\n&#125;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Composite organization = new Composite();\n        organization.addEmployee(new Leaf(\"John Doe\", \"Manager\"));\n        Composite department = new Composite();\n        department.addEmployee(new Leaf(\"Jane Smith\", \"Team Lead\"));\n        department.addEmployee(new Leaf(\"Bob Johnson\", \"Engineer\"));\n        Composite subDepartment = new Composite();\n        subDepartment.addEmployee(new Leaf(\"Tina Turner\", \"Engineer\"));\n        subDepartment.addEmployee(new Leaf(\"Steve Rogers\", \"Engineer\"));\n        department.addEmployee(subDepartment);\n        organization.addEmployee(department);\n        organization.showDetails();\n    &#125;\n&#125;\n\n在上面的示例中，Employee是一个接口，有两个实现类：Leaf和Composite。Leaf代表的是单个员工，而Composite代表的是员工组合。composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成\n使用组合模式，我们可以创建一个包含多个员工和部门的组织结构，并可以方便地对整个组织结构进行操作。在示例中，我们创建了一个根节点organization，它包含一个员工John Doe和一个部门department。部门department包含一个团队领导Jane Smith和一个工程师Bob Johnson，以及一个子部门subDepartment，子部门subDepartment包含两个工程师Tina Turner和Steve Rogers。最后，我们通过调用organization.showDetails()方法来打印组织结构中每个员工的详细信息。\n","slug":"组合模式","date":"2023-05-09T10:42:25.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"a8b2eb4f810dce05fcecb16e8edfd126","title":"适配器模式","content":"适配器模式适配器模式（Adapter Pattern）是一种结构型设计模式，它用于将一个类的接口转换成客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作。在适配器模式中，适配器充当了两个不兼容接口之间的桥梁，它负责允许这些接口间能够相互协作。\n在Java中，适配器模式常用于将不兼容的接口进行转换，通常包含以下三个角色：\n\nTarget（目标抽象类）：客户端所期望的接口，定义客户端所需的操作。\nAdapter（适配器类）：适配器，将Adaptee转换成Target所期望的接口。它维护了一个指向Adaptee对象的引用，并实现Target接口，使得客户端能够通过Adapter来访问Adaptee对象。\nAdaptee（原本的类）：需要被适配的类，包含原本的方法或接口。\n\n示例我们模拟了一个旧版的Android手机（OldAndroidPhone）和一个新版的iOS手机（NewiPhone），它们分别有不同的音乐播放器接口，而我们需要使用一个适配器（MusicPlayerAdapter）来兼容它们的操作：\n//原有音乐播放接口 \ninterface MusicPlayer &#123;\n    void playMP3(String fileName);\n&#125;\n\n//旧版Android手机\nclass OldAndroidPhone implements MusicPlayer &#123;\n    public void playMP3(String fileName) &#123;\n        System.out.println(\"Old Android phone is playing MP3 file: \" + fileName);\n    &#125;\n&#125;\n\n//新版iPhone手机 \ninterface NewiPhonePlayer &#123;\n    void playAAC(String fileName);\n&#125;\n\nclass NewiPhone implements NewiPhonePlayer &#123;\n    public void playAAC(String fileName) &#123;\n        System.out.println(\"New iPhone is playing AAC file: \" + fileName);\n    &#125;\n&#125;\n\n//适配器，将旧版手机的操作适配成新版手机可以使用的形式\nclass MusicPlayerAdapter implements NewiPhonePlayer &#123;\n    private MusicPlayer player;\n    \n    public MusicPlayerAdapter(MusicPlayer player)&#123;\n        this.player = player;\n    &#125;\n    \n    //适配器将AAC文件转化为MP3文件，并调用原有的播放方法\n    public void playAAC(String fileName) &#123;\n        String mp3File = convertAACtoMP3(fileName);\n        player.playMP3(mp3File);\n    &#125;\n    \n    private String convertAACtoMP3(String fileName)&#123;\n        System.out.println(\"Converting AAC to MP3: \" + fileName);\n        return fileName.replace(\".aac\", \".mp3\");\n    &#125;\n&#125;\n\n//客户端使用例子\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        //旧版Android手机播放MP3\n        MusicPlayer oldPhone = new OldAndroidPhone();\n        oldPhone.playMP3(\"old_phone_music.mp3\");\n        \n        //新版iPhone手机播放AAC，使用适配器兼容播放MP3文件\n        NewiPhonePlayer newPhone = new NewiPhone();\n        MusicPlayerAdapter adapter = new MusicPlayerAdapter(oldPhone);\n        newPhone.playAAC(\"new_phone_music.aac\");\n        adapter.playAAC(\"new_phone_music.aac\");\n    &#125;\n&#125;\n\n在上面的代码中，我们首先定义了两个已有的音乐播放器接口 MusicPlayer 和 NewiPhonePlayer，它们分别被 OldAndroidPhone 和 NewiPhone 实现。然后，我们使用 MusicPlayerAdapter 类将 OldAndroidPhone 类的 playMP3 方法适配成 NewiPhonePlayer 接口的 playAAC 方法，通过这个适配器，新版 iPhone 手机可以兼容旧版 Android 手机的音乐播放功能。在客户端使用时，我们分别调用了 OldAndroidPhone 的 playMP3 方法（旧版 Android 手机）和 NewiPhonePlayer 的 playAAC 方法（新版 iPhone 手机，使用 MusicPlayerAdapter 适配器）。\n我们可以看出适配器模式的优点：\n\n可以让原有的接口和新接口之间不发生冲突地协同工作，从而让代码更好地拓展和维护。\n\n","slug":"适配器模式","date":"2023-05-09T08:09:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"3dbdc722104d94fc07273118e255f7fd","title":"工厂模式","content":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数\n简单工厂UML类图\n\n适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需\n要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较\n复杂。\n简单工厂的例子:\nCalendar类的getInstance方法使用了一种简单工厂的方式来创建不同地区的日历对象。\n具体来说，Calendar类本身是一个抽象类，它定义了一些方法来处理日期和时间。由于不同地区有不同的日历，因此Calendar类并没有直接实现具体的日历，而是通过getInstance方法来获取指定地区的Calendar实例。getInstance方法接受一个Locale类型的参数，它根据不同的Locale参数调用createCalendar方法创建具体的日历实例。createCalendar方法是一个protected方法，由Calendar类的子类来实现。在具体的子类中，根据传入的Locale参数创建相应的日历对象，然后返回。这里，createCalendar方法就扮演了一个简单工厂模式中的工厂的角色，而Calendar类则相当于一个创建工厂，负责整个日历对象的生成过程的调度。\n工厂方法模式在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是提供一个工厂接口，由不同的子类来实现工厂接口中的方法来创建不同的对象。这样做的好处是增加了系统的扩展性和灵活性，可以根据实际需求来增加相应的子类和工厂实现。\n工厂方法模式通常由四部分组成：抽象产品、具体产品、抽象工厂、具体工厂。其中，抽象产品是需要创建的对象的通用接口，具体产品是实现抽象产品接口的具体类，抽象工厂是创建产品的接口，具体工厂是实现抽象工厂接口的具体类。\n工厂方法UML类图：\n\n使用工厂方法模式的好处是：\n\n可扩展性更好。使用工厂方法模式可以更加容易地扩展和添加新的产品类，而不会影响原有的代码结构。\n\n易于维护。工厂方法模式将创建对象的代码集中在一个地方，易于维护。当需要修改时，只需要修改对应的工厂类即可，而不需要修改客户端代码。\n\n降低耦合度。使用工厂方法模式可以将客户端代码和具体产品的实现解耦，使得客户端代码不需要了解每个具体产品类的细节。\n\n\n抽象工厂方法模式抽象工厂模式是工厂方法模式的扩展，旨在提供一个工厂接口来创建一系列相关的产品，而不是单一的产品类。\n抽象工厂模式中会存在多个产品族，每个产品族包含多个产品等级结构。产品等级结构是指具有相同功能的产品组成的集合，例如大众汽车、奥迪汽车和奔驰汽车组成了一个产品族，而每种汽车都具有车轮、车身和发动机等等组成的产品等级结构。\n在抽象工厂模式中，定义一个抽象工厂接口，它包含了一组用于创建产品族中每个产品等级结构的方法。每个具体的工厂类实现这个接口，负责实现自己的产品族生产过程。而具体产品则由具体工厂类中的具体方法实现来创建。\n通过抽象工厂模式，我们可以创造一个家族的对象，这个家族可以看做是一个产品族，而每个家族成员可以看做是这个产品族中的某个产品等级结构。抽象工厂模式保证了各种产品之间的兼容性，即一个工厂创建的产品都是该工厂创建的其他产品的兼容组合。\n抽象工厂UML类图：\n\n示例代码:首先是汽车工厂的抽象类（Abstract Factory）：\n// 定义汽车工厂的抽象类\nabstract class CarFactory &#123;\n    abstract Wheel createWheel();\n    abstract Body createBody();\n    abstract Engine createEngine();\n&#125;\n\n然后是具体的大众汽车工厂类（Volkswagen Car Factory）和奥迪汽车工厂类（Audi Car Factory）：\n// 定义大众汽车工厂\nclass VolkswagenFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new VolkswagenWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new VolkswagenBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new VolkswagenEngine();\n    &#125;\n&#125;\n\n// 定义奥迪汽车工厂\nclass AudiFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new AudiWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new AudiBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new AudiEngine();\n    &#125;\n&#125;\n\n然后是汽车组件的抽象类（Abstract Product）：\n// 定义汽车的组件抽象类\nabstract class Wheel &#123;\n    public abstract void create();\n&#125;\nabstract class Body &#123;\n    public abstract void create();\n&#125;\nabstract class Engine &#123;\n    public abstract void create();\n&#125;\n\n具体的大众和奥迪汽车组件的类：\n// 定义大众汽车组件\nclass VolkswagenWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车轮\");\n    &#125;\n&#125;\nclass VolkswagenBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车身\");\n    &#125;\n&#125;\nclass VolkswagenEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众发动机\");\n    &#125;\n&#125;\n\n// 定义奥迪汽车组件\nclass AudiWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车轮\");\n    &#125;\n&#125;\nclass AudiBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车身\");\n    &#125;\n&#125;\nclass AudiEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪发动机\");\n    &#125;\n&#125;\n\n最后，我们可以使用这些类来创建不同品牌的汽车：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        // 创建大众汽车\n        CarFactory vwFactory = new VolkswagenFactory();\n        vwFactory.createWheel().create();\n        vwFactory.createBody().create();\n        vwFactory.createEngine().create();\n        \n        // 创建奥迪汽车\n        CarFactory audiFactory = new AudiFactory();\n        audiFactory.createWheel().create();\n        audiFactory.createBody().create();\n        audiFactory.createEngine().create();\n    &#125;\n&#125;\n\n","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"b00cac0eae3b04411014ea36945005af","title":"建造者模式","content":"Java建造者模式Java中的建造者模式(Builder Pattern)\n主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。\n该模式包含以下几个角色：\n\nBuilder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。\n\nConcreteBuilder(具体建造者)：实现Builder接口，实现具体产品的创建过程，以及返回具体产品的方法。\n\nDirector(导演者)：负责调用建造者生成产品。\n\nProduct(产品)：表示被生成的复杂对象，包含多个部件。\n\n\n以下是Java中的建造者模式示例代码：\n// Product\nclass Car &#123;\n    private String engine;\n    private String chassis;\n    private String body;\n\n    public void setEngine(String engine) &#123;\n        this.engine = engine;\n    &#125;\n\n    public void setChassis(String chassis) &#123;\n        this.chassis = chassis;\n    &#125;\n\n    public void setBody(String body) &#123;\n        this.body = body;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Car &#123;engine='\" + engine + \"', chassis='\" + chassis + \"', body='\" + body + \"'&#125;\";\n    &#125;\n&#125;\n\n// Builder\ninterface CarBuilder &#123;\n    void buildEngine();\n    void buildChassis();\n    void buildBody();\n    Car getCar();\n&#125;\n\n// ConcreteBuilders\nclass SportsCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SportsCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"3.0L V6\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Aluminum\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Carbon Fiber\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\nclass SedanCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SedanCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"2.4L 4-cylinder\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Steel\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Metal\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\n\n// Director\nclass AutomotiveEngineer &#123;\n    public void build (CarBuilder builder) &#123;\n        builder.buildEngine();\n        builder.buildChassis();\n        builder.buildBody();\n    &#125;\n&#125;\n\npublic class BuilderPatternExample &#123;\n    public static void main(String[] args) &#123;\n        AutomotiveEngineer engineer = new AutomotiveEngineer();\n\n        CarBuilder sportsCarBuilder = new SportsCarBuilder();\n        engineer.build (sportsCarBuilder);\n        System.out.println(sportsCarBuilder.getCar()); \n        // Output: Car &#123;engine='3.0L V6', chassis='Aluminum', body='Carbon Fiber'&#125;\n\n        CarBuilder sedanCarBuilder = new SedanCarBuilder();\n        engineer.build (sedanCarBuilder);\n        System.out.println(sedanCarBuilder.getCar()); \n        // Output: Car &#123;engine='2.4L 4-cylinder', chassis='Steel', body='Metal'&#125;\n    &#125;\n&#125;\n\n在这个示例中，CarBuilder表示抽象建造者，SportsCarBuilder和SedanCarBuilder分别表示具体建造者，AutomotiveEngineer表示导演者，Car表示产品。通过导演者调用具体建造者的构建方法，即可建造出不同的Car实例。\n它的主要亮点有三处：\n\n较为灵活的构建产品对象\n\n在不执行最后 build 方法前，产品对象都不可用\n\n构建过程采用链式调用，看起来比较爽\n\n\n","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"0c6e8405652937a86cc3782f838cf782","title":"spring中常见的设计模式","content":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别\n\n根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it\n\n就是确保只有一个实例提供给全局使用\n\n显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例\n Spring中也有用到单例模式\n\norg.springframework.transaction.TransactionDefinition#withDefaults\n\norg.springframework.aop.TruePointcut#INSTANCE\n\norg.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR\n\norg.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE\n\norg.springframework.core.OrderComparator#INSTANCE\n\n\n2.Spring中的Builder（建造者模式）定义 Separate the construction of a complex object from its representation so that the same construction process can create different representations 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。\n优点：\n\n较为灵活的构建产品对象\n在不执行最后 build 方法前，产品对象都不可用\n构建过程采用链式调用，看起来比较爽\n\nSpring 中体现 Builder 模式的地方：\n\norg.springframework.beans.factory.support.BeanDefinitionBuilder\norg.springframework.web.util.UriComponentsBuilder\norg.springframework.http.ResponseEntity.HeadersBuilder\norg.springframework.http.ResponseEntity.BodyBuilder\n\n3.Spring中的Factory Method(工厂方法模式)定义Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。\nSpring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现\nSpring 中其它工厂：\n\norg.springframework.beans.factory.FactoryBean\n\n@Bean 标注的静态方法及实例方法\n\nObjectFactory 及 ObjectProvider\n\n\n前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题\n4.Spring中的Adapter(适配器模式)定义 Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。\n典型的实现有两处:\n\norg.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有\n@RequestMapping 标注的控制器实现\n传统的基于 Controller 接口（不是 @Controller注解啊）的实现\n较新的基于 RouterFunction 接口的实现\n它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口\n\n\norg.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法\n\n5.Spring中的Composite(组合模式)定义 Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly  即将对象组合成树形结构来表示部分-整体层次结构。组合模式可以让客户端统一地对待单个对象和对象组合。\n典型实现有：\n\norg.springframework.web.method.support.HandlerMethodArgumentResolverComposite\norg.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite\norg.springframework.web.servlet.handler.HandlerExceptionResolverComposite\norg.springframework.web.servlet.view.ViewResolverComposite\n\ncomposite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是：与具体干活的类实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的类实现来完成                                                                     \n6.Spring中的Decorator(装饰器模式)定义 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality 即 向对象动态地附加职责。 装饰器提供了一种灵活的替代继承的方式，以扩展功能。\n典型实现：\n\norg.springframework.web.util.ContentCachingRequestWrapper\n\nContentCachingRequestWrapper 通过包装 HttpServletRequest 对象，提供了对输入流进行重复读取和缓存的功能。其构造函数需要传入一个原始的 HttpServletRequest 对象，然后使用自己的 ByteArrayOutputStream 缓存请求体，同时提供了多个方法来获取请求信息。例如：\n\ngetContentAsByteArray() : 获取请求的内容（byte 数组），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetContentAsStream() : 返回请求的内容流（ServletInputStream），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetReader() : 返回一个读取请求内容的 BufferedReader 实例，如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\n\n总的来说，ContentCachingRequestWrapper 的实现非常好地体现了装饰器模式的思想，通过包装原始请求对象，提供了额外的功能，并且不改变原始对象的行为，从而实现了请求体的缓存和多次读取。\n7.Spring中的Proxy(代理模式)定义 Provide a surrogate or placeholder for another object to control access to it 即，为另一个对象提供一个代理或占位符来控制对它的访问。\n代理模式的主要目的是控制对目标对象的访问，在不改变原有代码的情况下，为对象提供一种间接访问的方式。代理模式在客户端和目标对象之间创建了一个代理对象，客户端通过代理对象来访问目标对象，从而可以对访问进行控制。代理模式可以用于保护目标对象的访问性、缓存对象等。\n与装饰器模式的区别\n装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问\n典型实现：\n\norg.springframework.aop.framework.JdkDynamicAopProxy\norg.springframework.aop.framework.ObjenesisCglibAopProxy\n\n8.Spring中的Chain of Responsibility(责任链模式)定义 Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it 即 避免使用一个对象直接调用另一个对象，而是通过将请求传递给多个对象中的一个来处理请求。将接收对象链接在一起，并将请求沿着链传递，直到一个对象能够处理它。\n典型实现：\n\norg.springframework.web.servlet.HandlerInterceptor\n\nHandlerInterceptor支持责任链模式，通过链式调用多个HandlerInterceptor，可以处理同一个请求的多个这样的拦截器。\n当一个请求到达后端控制器前，可以通过多个HandlerInterceptor按照特定的顺序进行处理。每个HandlerInterceptor可以处理请求，然后将处理结果传递给下一个HandlerInterceptor。这样，就形成了一个责任链。\n在责任链模式中，我们可以动态添加或删除HandlerInterceptor，并且可以定义多个拦截器链。这样，我们可以实现一些复杂的处理逻辑，将请求按照不同的方式进行处理，以达到更好的效果。\n9.Spring 中的 Observer(观察者模式)定义 Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically 即 定义一种一对多的对象依赖关系，这样当一个对象改变状态时，所有其依赖者将自动得到通知并更新。\n典型实现：\n\norg.springframework.context.ApplicationListener\norg.springframework.context.event.ApplicationEventMulticaster\norg.springframework.context.ApplicationEvent\n\n一个事件（ApplicationEvent）可以被ApplicationContext中的一个或多个ApplicationListener所监听。ApplicationContext会在事件发生时通知已注册的ApplicationListener，并由ApplicationListener来负责对该事件做出响应。\n为了实现这种模式，Spring提供了以下几个核心组件：\n\nApplicationEvent：代表了一个应用程序中发生的事件，包含了事件的信息。\nApplicationListener：负责处理事件，并进行响应的组件。\nApplicationEventMulticaster：用于管理事件监听器，负责将事件分发给对应的监听器进行处理。\n\n当一个事件被触发时，ApplicationEventMulticaster会调用所有已注册的ApplicationListener实例的onApplicationEvent()方法来进行处理。当事件被多个ApplicationListener监听时，ApplicationEventMulticaster会按顺序调用它们的onApplicationEvent()方法。\n因此，Spring的事件驱动模型就体现了观察者模式的特征，其中ApplicationListener充当了观察者的角色，ApplicationEventMulticaster充当了被观察者的角色。\n10. Spring 中的 Strategy(策略模式)定义 Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it 即，定义一个算法族，将每个算法封装起来，使它们可以互换。策略模式能够让算法的变化独立于使用它们的客户端。\n典型实现：\n\norg.springframework.beans.factory.support.InstantiationStrategy\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy\norg.springframework.boot.autoconfigure.condition.SearchStrategy\n\norg.springframework.beans.factory.support.InstantiationStrategy：存在多个实现InstantiationStrategy接口的类，这些类都实现了不同的实例化策略，比如：CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy和SmartInstantiationStrategy等。这些实现类可以根据实际情况取舍，通过策略模式实现了实例化策略的动态切换。\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的注解查找策略，比如：TypeMappedAnnotationChecker、RepeatableContainers、DirectlyDeclaredAnnotations和SynthesizedAnnotationDetection等。这些实现类可以根据实际情况取舍，通过策略模式实现了注解查找策略的动态切换。\norg.springframework.boot.autoconfigure.condition.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的条件判断策略，比如：OnClassCondition、ConditionalOnWebApplication和ConditionalOnProperty等。这些实现类可以根据实际情况取舍，通过策略模式实现了条件判断策略的动态切换。\n11. Spring 中的 Template Method(模板方法)定义 Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure  在一个操作中定义算法的框架，将某些步骤延迟到子类中。模板方法让子类重新定义算法的某些步骤，而不改变算法的结构。\n典型实现：\n\n大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate\n很多以 Abstract 命名的类，如 AbstractApplicationContext\n\n在JdbcTemplate中，模板方法是execute()方法，它封装了执行SQL语句的流程，具体的SQL语句可以通过传入不同的参数来实现。execute()方法中包含了一些固定的步骤，如获取连接、创建Statement、执行SQL语句、关闭资源等，这些步骤是不变的，但是具体的SQL语句和参数是可以变化的。通过这种方式，JdbcTemplate将重复的、泛化的操作封装到模板方法中，使得使用者只需要关注具体的SQL语句和参数。\nTransactionTemplate也是类似的，在Spring事务管理中，它封装了执行事务的流程，具体的事务操作可以通过传入不同的参数来实现。TransactionTemplate中的模板方法是execute()方法，它包含了获取事务、执行方法、提交&#x2F;回滚事务等固定步骤，这些步骤是每个事务操作都必须要执行的，但是具体的事务操作可以改变。通过这种方式，TransactionTemplate将事务管理的复杂性封装到模板方法中，使用者只需要关注自己的业务逻辑，而不需要关心事务的管理。\n在AbstractApplicationContext中，模板方法是refresh()方法，该方法包含了Spring容器的初始化流程，具体的初始化过程可以通过继承AbstractApplicationContext的子类来实现。refresh()方法中包含了一些固定的步骤，比如读取配置文件、创建&#x2F;初始化BeanFactory、加载Bean定义、注册BeanPostProcessor等，这些步骤是不变的，但是具体的实现可以改变。子类根据自己的需要，可以通过重写refresh()方法中的一些步骤来实现自己的初始化过程，比如读取不同的配置文件、使用不同的BeanFactory等。\n通过这种方式，AbstractApplicationContext将Spring容器的初始化过程封装到模板方法中，使得使用者只需要关注具体的Bean的配置和使用，而不需要关心Spring容器的初始化过程。这样可以大大简化代码的编写和维护，提高开发效率。\n","slug":"spring中的设计模式","date":"2023-05-09T04:00:50.000Z","categories_index":"","tags_index":"Java,设计模式,Spring","author_index":"大宝贝的程序员"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，\n构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀\n个静态公有⽅法获取实例。\n优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的\n情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，\n与单⼀职责原则冲突。\n单例模式的常⻅写法有哪些？饿汉式顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间。\n\n优点：线程安全，没有加锁，执⾏效率较⾼\n\n缺点：不是懒加载，类加载时就初始化，浪费内存空间\n\n\n\n线程安全：饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程\n的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。\n\n\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123;&#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private final static Singleton instance = new\nSingleton();\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n return instance;\n &#125;\n&#125;\n\n使⽤反射破坏单例public class Test &#123;\n public static void main(String[] args) throws\nException&#123;\n // 使⽤反射破坏单例\n // 获取空参构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(null);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例\n Singleton singleton =\ndeclaredConstructor.newInstance();\n System.out.println(\"反射创建的实例\" + singleton);\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n &#125;\n&#125;\n\n输出结果如下反射创建的实例\ncom.example.spring.demo.single.Singleton@6267c3bb\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n\n线程不安全的懒汉式这种⽅式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的，这⾥列出来是为了和后⾯使⽤锁保证线程安全的单例做对⽐\n\n优点：懒加载\n缺点：线程不安全\n\n//线程不安全的懒汉式单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 判断为 null 的时候再创建对象\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n &#125;\n&#125;\n\n线程安全的懒汉式懒汉式单例如何保证线程安全呢？通过 synchronized 关键字加锁保证线程\n安全， synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这\n⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时\n都需要加锁和释放锁，这样是⾮常影响性能的。\n\n优点：懒加载，线程安全\n\n缺点：效率较低\n\n\n//懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public synchronized static Singleton getInstance() &#123;\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n    &#125;\n&#125;\n\n双重检查锁(DCL)这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么\n要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就\n不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进\n⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调\n⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同\n步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创\n建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单\n例。\n关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁\n竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对\n象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返\n回已创建的单例对象。\n其中最关键的⼀个点就是 volatile 关键字的使⽤，关于 volatile 的详细介\n绍可以直接搜索 volatile 关键字即可，有很多写的⾮常好的⽂章，这⾥不做\n详细介绍，简单说明⼀下，双重检查锁中使⽤ volatile 的两个重要特性：\n可⻅性、禁⽌指令重排序\n当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令\n的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对\nvolatile 修饰的变量的修改对其他任何线程都是可⻅的\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private volatile static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 第⼀重检查是否为 null\n if (instance == null) &#123;\n // 使⽤ synchronized 加锁\n synchronized (Singleton.class) &#123;\n // 第⼆重检查是否为 null\n     if (instance == null) &#123;\n // new 关键字创建对象不是原⼦操作\n instance = new Singleton();\n\t \t\t&#125;\n \t\t&#125;\n \t&#125;\n return instance;\n \t&#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼\n\n缺点：实现较复杂\n\n\n静态内部类//静态内部类实现单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、对外提供获取实例的公共⽅法\n public static Singleton getInstance() &#123;\n return InnerClass.INSTANCE;\n     \n // 定义静态内部类\n private static class InnerClass&#123;\n private final static Singleton INSTANCE = new\nSingleton();\n &#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼，实现简单\n\n静态内部类单例是如何实现懒加载的呢？⾸先，我们先了解下类的加载时机。虚拟机规范要求有且只有 5 种情况必须⽴即对类进⾏初始化（加载、验证、准备需要在此之前开始）：\n\n遇到 new 、 getstatic 、 putstatic 、 invokestatic 这 4 条字节码指令时。⽣成这 4 条指令最常⻅的 Java 代码场景是：使⽤ new 关键字实例化对象的时候、读取或设置⼀个类的静态字段（final 修饰除外，被final 修饰的静态字段是常量，已在编译期把结果放⼊常量池）的时候，以及调⽤⼀个类的静态⽅法的时候。\n使⽤ java.lang.reflect 包⽅法对类进⾏反射调⽤的时候。\n当初始化⼀个类的时候，如果发现其⽗类还没有进⾏过初始化，则需要先触发其⽗类的初始化。\n当虚拟机启动时，⽤户需要指定⼀个要执⾏的主类（包含 main()的那个类），虚拟机会先初始化这个主类。\n当使⽤ JDK 1.7 的动态语⾔⽀持时，如果⼀个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_getStatic 、 REF_putStatic 、 REF_invokeStatic 的⽅法句柄，则需要先触发这个⽅法句柄所对应的类的初始化。\n\n这 5 种情况被称为是类的主动引⽤，注意，这⾥《虚拟机规范》中使⽤的限定词是 “有且仅有”，那么，除此之外的所有引⽤类都不会对类进⾏初始化，称为被动引⽤。静态内部类就属于被动引⽤的情况。\n当 getInstance()⽅法被调⽤时，InnerClass 才在 Singleton 的运⾏时常量池⾥，把符号引⽤替换为直接引⽤，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()⽅法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中⼜是如何保证线程安全的呢？\n虚拟机会保证⼀个类的 () ⽅法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个类的 () ⽅法，其他线程都需要阻塞等待，直到活动线程执⾏() ⽅法完毕。如果在⼀个类的 () ⽅法中有耗时很⻓的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执⾏ () ⽅法后，其他线程唤醒之后不会再次进⼊ () ⽅法。同⼀个加载器下，⼀个类型只会初始化⼀次。)，在实际应⽤中，这种阻塞往往是很隐蔽的。\n所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯⼀性，同时也延迟了单例的实例化。\n枚举单例//枚举实现单例\npublic enum Singleton &#123;\n INSTANCE;\n public void doSomething(String str) &#123;\n System.out.println(str);\n &#125;\n&#125;\n\n\n优点：简单，⾼效，线程安全，可以避免通过反射破坏枚举单例\n\n枚举在 java 中与普通类⼀样，都能拥有字段与⽅法，⽽且枚举实例创建是线程安全的，在任何情况下，它都是⼀个单例，可以直接通过如下⽅式调⽤获取实例：\nSingleton singleton = Singleton.INSTANCE;\n使⽤下⾯的命令反编译枚举类\njavap Singleton.class\n得到如下内容\nCompiled from \"Singleton.java\"\npublic final class com.spring.demo.singleton.Singleton\nextends\njava.lang.Enum&lt;com.spring.demo.singleton.Singleton> &#123;\n public static final\ncom.spring.demo.singleton.Singleton INSTANCE;\n public static com.spring.demo.singleton.Singleton[]\nvalues();\n public static com.spring.demo.singleton.Singleton\nvalueOf(java.lang.String);\n public void doSomething(java.lang.String);\n static &#123;&#125;;\n&#125;\n\n从枚举的反编译结果可以看到，INSTANCE 被 static final 修饰，所以可以通过类名直接调⽤，因为static 类型的属性会在类被加载之后被初始化，当⼀个 Java 类第⼀次被真正使⽤到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的，所以创建⼀个 enum 类型是线程安全的。\n通过反射破坏枚举，实现代码如下：public class Test &#123;\n public static void main(String[] args) throws\nException &#123;\n Singleton singleton = Singleton.INSTANCE;\n singleton.doSomething(\"hello enum\");\n // 尝试使⽤反射破坏单例\n // 枚举类没有空参构造⽅法，反编译后可以看到枚举有⼀个两个\n参数的构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(String.class,\nint.class);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例，这⾥会报错，因为⽆法通过反射创建枚举的实例\n Singleton enumSingleton =\ndeclaredConstructor.newInstance();\n System.out.println(enumSingleton);\n &#125;\n&#125;\n\n运⾏结果报如下错误：\nException in thread \"main\"\njava.lang.IllegalArgumentException: Cannot reflectively\ncreate enum objects at\njava.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492) \nat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\nat com.spring.demo.singleton.Test.main(Test.java:24)\n\n所以⽆法通过反射创建枚举的实例。\n","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"064fd1f961f785b45ddfca5b3ce563ee","title":"spring事务失效的情况以及注意事项","content":"什么是spring事务？​\tSpring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。\n​\tSpring事务的核心思想是将事务管理从具体的数据访问代码中抽象出来。Spring提供了一种集中式的方式来管理事务，这使得我们可以在不修改具体数据访问代码的情况下轻松地添加或删除事务。\nspring事务的优点Spring事务具有以下优点：\n简单性 - Spring事务使得事务管理变得非常简单，只需要添加少量的注释就可以实现。\n可扩展性 - Spring事务提供了各种事务管理器，以适应各种不同的事务需求。它还允许我们自行扩展和定制事务管理器。\n独立性 - Spring事务提供了一种与底层数据访问技术无关的事务管理方式，因此我们可以轻松地更改数据库，而不需要更改事务管理方式。\nspring事务的类型Spring事务有以下常见的类型：\n\n声明式事务 - 该类型的事务是在配置文件或注释中声明的。这使得我们可以轻松地添加和删除事务。\n编程式事务 - 该类型的事务是通过编写代码来实现的。它提供了更细粒度的控制和更高的自定义程度。但是，编写代码会使得代码复杂化。\n\nspring事务失效的情况事务失效的八种场景1.抛出检查异常导致事务不能正确回滚补充什么是检查异常：\nJava中的异常分为两种类型：检查异常和非检查异常。\n检查异常需要使用try-catch语句或者throws声明来处理或抛出，否则编译器会报错。这种异常通常表示程序运行时必须解决的某些错误或不合法操作。例如：IOException、SQLException、ClassNotFoundException等。\n非检查异常是指RuntimeException及其子类异常，不需要在代码中进行特殊处理，程序在运行期间出现这种异常时，会自动触发JVM的异常处理机制。这种异常通常表示程序出现了逻辑或编程错误。例如：NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。\n@Service\npublic class Service1 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n无法事务回滚：Spring默认只会回滚非检查异常\n\n解法：\n配置rollbackFor属性 (什么错误需要回滚)：\n @Transactional(rollbackFor = Exception.class)\n\n\n2.方法内自己try-catch异常导致事务不能正确回滚@Service\npublic class Service2 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount)  &#123;\n        try &#123;\n            int fromBalance = accountMapper.findBalanceBy(from);\n            if (fromBalance - amount >= 0) &#123;\n                accountMapper.update(from, -1 * amount);\n                new FileInputStream(\"hj\");\n                accountMapper.update(to, amount);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n原因：事务通知只有捕捉到了目标方法抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉\n\n方法1：将catch到的异常，包装成运行时异常抛出\n\n在catch块里throw new RuntimeException(e);\n\n\n方法2：手动设置回滚\n\n在catch块添加\nTransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n\n\n\n\n3.aop切面顺序异常导致事务不能正确回滚@Service\npublic class Service3 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n@Aspect\npublic class MyAspect &#123;\n    @Around(\"execution(* transfer(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        LoggerUtils.get().debug(\"log:&#123;&#125;\", pjp.getTarget());\n        try &#123;\n            return pjp.proceed();\n        &#125; catch (Throwable e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.非public方法导致事务失效@Service\npublic class Service4 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n原因：Spring为方法创建代理，添加事务通知，前提条件都是方法为public\n\n方法1：方法改为public\n\n方法2：添加bean配置，不推荐使用\n\n@Bean\npublic TransactionAttributeSource transactionAttributeSource() &#123;\n    return new AnnotationTransactionAttributeSource(false);\n&#125;\n\n\n\n\n\n​\t拓展：AnnotationTransactionAttributeSource\n​\t\tAnnotationTransactionAttributeSource是Spring事务框架中的一个类，用于解析@Transactional注解并以此为基础生成TransactionAttribute对象。TransactionAttribute对象描述了一段方法执行时应该使用的事务属性，包括事务的名字、传播行为、隔离级别、超时时间、只读属性等。\n​\t\t在Spring的事务管理中，事务切面对象会调用AnnotationTransactionAttributeSource对象的getTransactionAttribute()方法，从而获取方法或类级别的事务属性。这种方式可以将事务属性与具体的业务代码解耦，使得业务代码更加简洁可读。\n​\t\tAnnotationTransactionAttributeSource对象有一个布尔类型的构造函数参数，它用于控制@Transactional注解的解析方式。如果这个参数为false，则AnnotationTransactionAttributeSource只会解析@Transactional注解，而不会考虑继承和重载关系，即只解析被注解类或方法上的@Transactional注解，而不考虑其基类和子类以及重载方法中的@Transactional注解。\n​\t\t默认情况下AnnotationTransactionAttributeSource对象的构造函数参数是true，即支持继承和重载的注解解析。但是，在某些特殊情况下，这种解析方式可能会导致一些问题，如事务传播、超时等不被正确解析。此时，可以通过设置构造函数参数为false来禁用这种解析机制，以确保正确地解析@Transactional注解。\n5.父子容器导致的事务失效6.调用本类方法导致传播行为失效7.@Transactional没有保证原子行为8.@Transactional方法导致的synchronized失效","slug":"spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","categories_index":"","tags_index":"Java,tx,Spring","author_index":"大宝贝的程序员"},{"id":"94364c933b9df4578d2492ddcb35178f","title":"How to use Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nmyHexoCreate a new post$ hexo new \"title\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"}]