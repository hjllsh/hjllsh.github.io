[{"id":"c1f6d722cc4602038235f2e7924e8ff2","title":"MySQL事务","content":"","slug":"MySQL事务","date":"2023-05-17T13:51:38.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"f293b2fcfae54b8509d50db2914ed7a0","title":"MySQL_约束_多表查询","content":"约束概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n目的：保证数据库中数据的正确、有效性和完整性。\n\n\n\n约束\n描述\n关键词\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一、不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束(8.0.16版本之后)\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来让两张表的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。\ncreate table tb_user(\nid int primary key auto_increment comment 'ID唯一标识',\nname varchar(10) not null unique comment '姓名',\nage int check (age between 0 and 120) comment '年龄',\nstatus char(1) default 1 comment '状态',\ngender char(1) comment '性别'\n)comment '学生表';\n\n外键约束\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。\ncreate table dept(\n\tid int auto_increment primary key comment 'ID',\n    name varchar(50) not null comment '部门名称',    \n)comment '部门表';\n\nCREATE TABLE `emp` (\n  `id` int DEFAULT NULL COMMENT '编号',\n  `workno` varchar(10) DEFAULT NULL,\n  `name` varchar(10) DEFAULT NULL COMMENT '姓名',\n  `gender` char(1) DEFAULT NULL COMMENT '性别',\n  `age` tinyint unsigned DEFAULT NULL COMMENT '年龄',\n  `idcard` char(18) DEFAULT NULL COMMENT '身份证号',\n  `workaddress` varchar(50) DEFAULT NULL COMMENT '工作地址',\n  `entrydate` date DEFAULT NULL COMMENT '入职时间',\n  `dept_id` int DEFAULT '1' COMMENT '部门id'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表'\n\n为emp表的dept_id字段添加外键约束,关联dept表的主键id。\nalter table emp add constraint fk_emp_dept foreign key(dept_id) references dept(id);\n\n命令中的 “alter table emp” 表示将要修改的表是 emp，“add constraint” 表示添加一个约束，“fk_emp_dept_id” 是这个约束的名称，“foreign key (dept_id)” 表示这是一个外键约束，关联的列是 emp 表中的 dept_id 列，“references dept(id)” 表示外键引用了 dept 表的 id 列。这个约束的作用是确保 emp 表中的 dept_id 值必须在 dept 表的 id 列中存在，从而保证了参照完整性。\n添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。\n1451 - Cannot delete or update a parent row: a foreign key constraint fails (hj.emp, CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) REFERENCES dept (id))\n 删除外键\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\nalter table emp drop foreign key fk_emp_dept;\n\n删除&#x2F;更新行为\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除&#x2F;更新行为。\n具体的删除&#x2F;更新行为有以下几种:\n\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 RESTRICT 一致) 默认行为\n\n\nRESTRICT\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 NO ACTION 一致) 默认行为\n\n\nCASCADE\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录。\n\n\nSET NULL\n当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。\n\n\nSET DEFAULT\n父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)\n\n\n具体语法为:\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\n主表名 (主表字段名) ON UPDATE 行为 ON DELETE 行为;\n\n小案例：CASCADE行为下  修改父表id为1的记录，将id修改为6\nalter table emp add constraint kf_emp_dept_id foreign key (dept_id) references dept(id)\non update cascade on delete cascade;\n\nupdate dept set id = 6 where id = 1;\n\ndelete form dept where id = 6;\n\n我们发现:\n原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。\n父表的数据删除成功了，但是子表中关联的记录也被级联删除了。\n SET NULL\nalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id)\non update set null on delete set null;\n\ndelete from dept where id = 3;\n\nupdate dept set id = 7 where id = 5;\n\n父表的记录是可以正常的删除的，父表的数据删除&#x2F;跟新之后，再打开子表 emp，我们发现子表emp的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。\n多表查询多表关系一对多(多对一) \n如：部门 与 员工的关系，一个部门对应多个员工，一个员工对应一个部门\n实现: 在多的一方建立外键，指向一的一方的主键\ncreate table emp(\nid int auto_increment comment 'ID' primary key,\nname varchar(50) not null comment '姓名',\nage int comment '年龄',\njob varchar(20) comment '职位',\nsalary int comment '薪资',\nentrydate date comment '入职时间',\nmanagerid int comment '直属领导ID',\ndept_id int comment '部门ID',\nconstraint fk_emp_dept_id foreign key (dept_id) references dept(id)\non update cascade on delete cascade\n)comment '员工表';\n\ncreate table dept(\nid int auto_increment comment 'ID' primary key,\nname varchar(50) not null comment '部门名称'\n)comment '部门表';\n\n\n多对多\n如： 学生 与 课程的关系， 一个学生可以选修多门课程，一门课程也可以供多个学生选择\n实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\nreate table course(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '课程名称'\n) comment '课程表';\n\n\ncreate table tb_user(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '姓名',\nage int comment '年龄',\ngender char(1) comment '1: 男 , 2: 女',\nphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\n\ncreate table tb_user_edu(\nid int auto_increment primary key comment '主键ID',\ndegree varchar(20) comment '学历',\nmajor varchar(50) comment '专业',\nprimaryschool varchar(50) comment '小学',\nmiddleschool varchar(50) comment '中学',\nuniversity varchar(50) comment '大学',\nuserid int unique comment '用户ID',\nconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\n\n一对一\n如：用户 与 用户详情的关系， 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\ncreate table tb_user(\nid int auto_increment primary key comment '主键ID',\nname varchar(10) comment '姓名',\nage int comment '年龄',\ngender char(1) comment '1: 男 , 2: 女',\nphone char(11) comment '手机号'\n) comment '用户基本信息表';\n\ncreate table tb_user_edu(\nid int auto_increment primary key comment '主键ID',\ndegree varchar(20) comment '学历',\nmajor varchar(50) comment '专业',\nprimaryschool varchar(50) comment '小学',\nmiddleschool varchar(50) comment '中学',\nuniversity varchar(50) comment '大学',\nuserid int unique comment '用户ID',\nconstraint fk_userid foreign key (userid) references tb_user(id)\n) comment '用户教育信息表';\n\n多表查询概述要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept;\n 具体的执行结果如下:\n我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录(17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单介绍下笛卡尔积。\n笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\nselect * from emp , dept where emp.dept_id = dept.id;\n\n连接查询分类\n​\t内连接：相当于查询A、B交集部分数据 \n​\t外连接：\n​\t\t左外连接：查询左表所有数据，以及两张表交集部分数据\n​\t\t右外连接：查询右表所有数据，以及两张表交集部分数据\n​\t自连接：当前表与自身的连接查询，自连接必须使用表别名\n内连接\n内连接的语法分为两种: 隐式内连接、显式内连接。\n隐式内连接\nSELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;\n\n显式内连接\nSELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;\n\n小案例：查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)\n -- 隐式内连接实现\nselect emp.name, dept.name from emp,dept where emp.dept_id = dept.id;\n\nselect emp.name, dept.name from emp join dept on emp.dept_id = dept.id;\n\n外连接\n外连接分为两种，分别是：左外连接 和 右外连接\n具体的语法结构为：\n左外连接 \n相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\nSELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;\n\n 小案例：查询emp表的所有数据, 和对应的部门信息\n分析：要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。\nselect e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;\n\nselect e.*, d.name from emp e left join dept d on e.dept_id = d.id;\n\n小案例： 查询dept表的所有数据, 和对应的员工信息(右外连接)\nselect dept.*, emp.* from emp right outer join dept on emp.dept_id = dept.id;\n\n左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n自连接\n顾名思义，就是自己连接自己，也就是把一张表连接查询多次。\n查询语法\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;\n\n小案例：查询员工 及其 所属领导的名字，如果员工没有领导, 也需要查询出来\nselect a.name, b.name from emp a left join emp b on a.managerid = b.id;\n\n在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。\n联合查询\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n语法：\nSELECT 字段列表 FROM 表A ...\nUNION [ ALL ]\nSELECT 字段列表 FROM 表B ....;\n\n对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。如果多条查询语句查询出来的结果，字段数量不一致，在进行union&#x2F;union all联合查询时，将会报错\nunion all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\n子查询\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询\n语法\nSELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );\n\n子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。\n根据子查询位置，分为：WHERE之后\t\t FROM之后\t\tSELECT之后\n标量子查询 ：子查询返回的结果是单个值\t\t常用的操作符：&#x3D;   &lt;&gt;   &gt;   &gt;&#x3D;   &lt;  &lt;&#x3D; \n案例：查询 “销售部” 的所有员工信息\nselect * from emp where dept_id = (select id from dept where name = '销售部');\n\n列子查询\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n\n\n操作符\n描述\n\n\n\nIN\n在指定的集合范围之内，多选一\n\n\nNOT IN\n不在指定的集合范围之内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n小案例：查询 “销售部” 和 “市场部” 的所有员工信息\nselect * from emp where id in\n(select id from dept where name = '销售部' or name = '市场部');\n\n 小案例：查询比 财务部 所有人工资都高的员工信息\nselect * from emp where salary > all ( select salary from emp where dept_id =\n(select id from dept where name = '财务部') );\n\n 小案例：查询比研发部其中任意一人工资高的员工信息\nselect * from emp where salary > any(select salary from emp where dept_id = \n(select id from dept where name = '研发部'));\n\n行子查询\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。\n常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN\n小案例：查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;\nselect * from emp where (salary,managerid) = (select salary, managerid from emp where name ='张无忌');\n\n表子查询\n子查询返回的结果是多行多列，这种子查询称为表子查询。常用的操作符：IN\n小案例：查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息\nselect * from emp where (job,salary) in ( select job, salary from emp where name =\n'鹿杖客' or name = '宋远桥' );\n\n小案例：查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息\n````\n\n 小案例：查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n\n小案例： 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）\n\n\n小案例：查询拥有员工的部门ID、部门名称\n\n\n小案例：查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)\n\n\n小案例：查询所有员工的工资等级\n\n\n小案例：查询 &quot;研发部&quot; 所有员工的信息及 工资等级\n\n\n小案例： 查询 &quot;研发部&quot; 员工的平均工资\n\n\n小案例： 查询工资比 &quot;灭绝&quot; 高的员工信息。\n\n\n小案例： 查询比平均薪资高的员工信息\n\n\n小案例：查询低于本部门平均工资的员工信息\n\n\n小案例：查询所有的部门信息, 并统计部门的员工人数\n\n\n小案例：查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n\n\n","slug":"MySQL-约束-多表联查","date":"2023-05-16T13:40:42.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"8f9e88b96addebc57d8b075bdae2d985","title":"MySQL_DCL_函数","content":"DCLData Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。\n管理用户查询用户\nselect * from mysql.user;\n\n\n其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。\n创建用户\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n修改用户密码\nALTER USER '用户名'@'主机号' IDENTIFIED WITH mysql_native_password BY '新密码';\n\n删除用户\nDROP USER '用户名'@'主机名';\n\n在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n主机名可以使用 % 通配。\n这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。\n权限控制\nMySQL中定义了很多种权限，但是常用的就以下几种\n\n\n\n权限\n说明\n\n\n\nALL,  ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\n\n授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n\n撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n\n 多个权限之间，使用逗号分隔\n授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\nSHOW GRANTS FOR 'hj'@'%';\n-- 运行结果：\n-- GRANT ALL PRIVILEGES ON `hj`.* TO `hj`@`%`\n-- 该命令为 MySQL 的授权语法，意思是授权用户 hj 在任何主机地址上（%）对数据库 hj 中所有表拥有所有权限（ALL PRIVILEGES）。可以执行如下 SQL 命令进行授权\n-- GRANT USAGE ON *.* TO `hj`@`%`\n-- 该命令为 MySQL 的授权语法，意思是授权用户 `hj` 在任何主机地址上（`%`）对所有的数据库、表、函数、存储过程等对象都拥有使用权限（`USAGE`）。\n\n函数MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。\n字符串函数\n\n\n\n函数\n功能\n\n\n\nCONCAT(S1,S2,…Sn)\n字符串拼接，将S1，S2，… Sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串str全部转为小写\n\n\nUPPER(str)\n将字符串str全部转为大写\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str,start,len)\n返回从字符串str从start位置起的len个长度的字符串\n\n\n concat : 字符串拼接\nselect concat('Hello' , ' MySQL');\n\nlpad : 左填充\nselect lpad('01', 5, '-');\n\n rpad : 右填充\nselect rpad('01',5,'23456789');\n-- 01234\nselect rpad('01',5,'23');\n-- 01232\n\n trim : 去除空格\nselect trim(' Hello MySQL ');\n-- 'Hello MySQL'\n\n substring : 截取子字符串\nselect substring('Hello MySQL',1,5);\n-- Hello\n\n案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001。\nupdate workno = lpad(workno, 5, '0');\n\n数值函数\n\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x,y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0~1内的随机数\n\n\nROUND(x,y)\n求参数x的四舍五入的值，保留y位小数\n\n\n ceil：向上取整\nselect ceil(1.1);\n\n floor：向下取整\nselect floor(1.9);\n\nmod：取模\nselect mod(7,4);\n\n rand：获取随机数\nselect rand();\n\nround：四舍五入\nselect round(2.344,2);\n\n小案例：通过数据库的函数，生成一个六位数的随机验证码。\nselect lpad('',6,substring(concat(rand(),''),3,9)) code;\n\n日期函数\n\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n获取指定date的年份\n\n\nMONTH(date)\n获取指定date的月份\n\n\nDAY(date)\n获取指定date的日期\n\n\nDATE_ADD(date,INTERVAL expr type)\n返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1,date2)\n返回起始时间date1 和 结束时间date2之间的天数\n\n\n curdate：当前日期\nselect curdate();\n\n curtime：当前时间\nselect curtime();\n\n now：当前日期和时间\nselect now();\n\nYEAR , MONTH , DAY：当前年、月、日\nselect year(now());\nselect month(now());\nselect day(now());\n\ndate_add：增加指定的时间间隔\nselect date_add(now(),INTERVAL 70 YEAR);\nselect date_add('2023-05-16', INTERVAL 29 DAY);\n\n datediff：获取两个日期相差的天数\nselect datediff('2023-05-16','2023-06-14');\n\n小案例：查询所有员工的入职天数，并根据入职天数倒序排序。\nselect name , datediff(curdate(), entrydate) workday from emp order by workday desc;\n\n流程函数\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(value1, value2)\n如果value1不为空，返回value1，否则返回value2\n\n\nCASE WHEN [vall] THEN [res1] … ELSE [default] END\n如果val1为true，返回res1，… 否则返回default默认值\n\n\nCASE [expr] WHEN [val1] THEN [res1] …  ELSE [default] END\n如果expr的值等于val1，返回res1，… 否则返回default默认值\n\n\n if\nselect if(false, 'Ok', 'Error');\n-- 默认的false值还有 0, '', null\n\n ifnull\nselect ifnull('Ok','Default');\nselect ifnull('','Default');\nselect ifnull(null,'Default')\n-- 只有null会被识别为空\n\n case when then else end\n查询emp表的员工姓名和工作地址 (北京&#x2F;上海   替换成   一线城市 , 其他   替换成   二线城市)\nselect name, (case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end) '工作地点' from emp;\n\n案例：将学生的各个学科的成绩分等级展示，大于等于85 为优秀，(85，60]为及格，否则不及格\ncreate table score(\nid int comment 'ID',\nname varchar(20) comment '姓名',\nmath  tinyint unsigned comment '数学',\nenglish tinyint unsigned comment '英语',\nchinese tinyint unsigned comment '语文'\n) comment '学生成绩表';\ninsert into score(id, name, math, english, chinese) VALUES \n(1, 'Tom', 67, 88, 95),\n (2, 'Rose' , 23, 66, 90),\n (3, 'Jack', 56, 98, 76);\n \n select name , \n(case when math >= 85 then '优秀' when math >=60 then '及格' else '不及格' end ) math_score,\n(case when english >= 85 then '优秀' when english >=60 then '及格' else '不及格' end ) english_score,\n(case when chinese >= 85 then '优秀' when chinese >=60 then '及格' else '不及格' end ) chinese_score \n from score;\n\n","slug":"MySQL-DCL-函数","date":"2023-05-16T08:56:15.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"b886b366f3cb34006709f66f49ec6b62","title":"状态模式","content":"状态模式它将对象的行为与其内部状态分离开来，使得对象可以根据其内部状态的变化而改变其行为。状态模式通过将状态的切换封装在状态类中，使得状态转换具有可扩展性和灵活性，并避免了由于状态转换所带来的“if-else”嵌套过多的问题。\n状态模式的基本机制是将状态抽象为一个接口或者抽象类，每个具体状态类都实现该接口或者抽象类，并且在具体状态类中实现其对应的行为。在状态模式中，对象的状态切换是通过改变对象持有的状态实例来实现的。当对象需要状态转换时，它会委托当前状态实例处理状态转换，从而使得对象的行为和状态相互解耦，具有更好的可扩展性和灵活性。\n状态模式符合“单一职责原则”和“开闭原则”两个软件设计原则。其中，“单一职责原则”指一个类只负责一个职责，状态模式将状态抽象为一个独立的类，使得每个状态类只负责处理一个状态，从而使得每个类都具有单一的职责；“开闭原则”指对扩展开放，对修改关闭，状态模式通过增加新的状态类来扩展状态转换过程，而不需要修改原有的代码，从而符合“开闭原则”。\n状态模式存在三个角色：\n\n环境（Context）角色：它定义了客户端所感兴趣的接口，通常包含一个状态实例并维护一个指向具体状态对象的引用。这个上下文类可以处理请求并将其委托给当前状态对象。\n抽象状态（State）角色：它把所有具体状态类的共同点抽象出来，定义了这些共同点对应的接口或抽象类，并在其中定义了该状态下对象的行为。\n具体状态（Concrete State）角色：它实现了抽象状态的接口或抽象类，并且定义了在该状态下对象的行为。\n\n假设我们要设计一个电灯类，电灯可以处于3个不同的状态：\n关闭状态、开启状态和闪烁状态。电灯类的代码如下：\npublic class Light &#123;\n    private State state;\n\n    public Light() &#123;\n        this.state = new OffState();\n    &#125;\n\n    public void setState(State state) &#123;\n        this.state = state;\n    &#125;\n\n    public void turnOn() &#123;\n        state.turnOn(this);\n    &#125;\n\n    public void turnOff() &#123;\n        state.turnOff(this);\n    &#125;\n\n    public void blink() &#123;\n        state.blink(this);\n    &#125;\n&#125;\n\n在这里，我们将电灯的状态抽象成了接口State，然后定义了3个具体的状态类：OffState、OnState和BlinkState，这3个类实现了State接口。\npublic interface State &#123;\n    void turnOn(Light light);\n    void turnOff(Light light);\n    void blink(Light light);\n&#125;\n\npublic class OffState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯开启\");\n        light.setState(new OnState());\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯已经关闭，不能再关闭\");\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯未开启，不能闪烁\");\n    &#125;\n&#125;\n\npublic class OnState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯已经开启，不需要再开启\");\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯关闭\");\n        light.setState(new OffState());\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯开始闪烁\");\n        light.setState(new BlinkState());\n    &#125;\n&#125;\n\npublic class BlinkState implements State &#123;\n    @Override\n    public void turnOn(Light light) &#123;\n        System.out.println(\"电灯已经开启，不需要再开启\");\n    &#125;\n\n    @Override\n    public void turnOff(Light light) &#123;\n        System.out.println(\"电灯关闭\");\n        light.setState(new OffState());\n    &#125;\n\n    @Override\n    public void blink(Light light) &#123;\n        System.out.println(\"电灯停止闪烁\");\n        light.setState(new OnState());\n    &#125;\n&#125;\n\n在电灯类中，引入了一个State类型的变量state，表示当前电灯处于哪种状态。当电灯需要改变状态时，它会调用state的对应方法，然后将state设为新的状态。例如，当电灯需要开启时，它将调用OnState的turnOn方法，并将state设为OnState实例。\n下面是一个应用电灯类的例子：\npublic static void main(String[] args) &#123;\n    Light light = new Light();\n    light.turnOn();  // 电灯开启\n    light.turnOn();  // 电灯已经开启，不需要再开启\n    light.blink();   // 电灯开始闪烁\n    light.turnOff(); // 电灯关闭\n    light.blink();   // 电灯未开启，不能闪烁\n    light.turnOff(); // 电灯已经关闭，不能再关闭\n&#125;\n\n在这个例子中，我们首先创建了一个电灯实例light，然后通过调用它的turnOn、blink和turnOff方法，改变了它的状态，并输出了相应的信息。\n这个例子可以帮助我们理解状态模式的基本用法和原理，同时也能让我们感受到状态模式所提供的可扩展性和灵活性。当需要新增或修改状态时，我们只需要添加或修改相应的状态类，而不需要修改电灯类的代码，从而大大降低了代码的耦合度和维护成本。\n","slug":"状态模式","date":"2023-05-15T10:11:38.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"ab4a664e2e3638cd67bb057e6ee644aa","title":"迭代器模式","content":"迭代器模式它提供一种方便的方式来访问并遍历集合对象的元素，而无需暴露集合的内部表示。该模式将遍历集合的过程与集合的实现分离开来，使得可以在不影响客户端代码的情况下更改集合的内部实现。\n迭代器模式包括以下几个元素：\n1.迭代器接口（Iterator）：定义了用于访问和遍历集合元素的标准方法。\n2.具体迭代器（Concrete Iterator）：实现了Iterator接口，用于遍历集合中的元素。\n3.集合接口（Aggregate）：定义了一组用于集合管理和访问元素的方法。\n4.具体集合（Concrete Aggregate）：实现了Aggregate接口，用于管理和访问元素集合。\n通过使用迭代器模式，我们可以将遍历和集合的实现分离开来，从而使得可以方便地对集合进行修改而不会影响遍历的过程。另外，通过提供不同的迭代器实现，我们可以很容易地实现一些高级的遍历需求，比如倒序遍历、过滤遍历等。\n迭代器模式符合以下软件设计原则：\n1.单一职责原则：该模式将集合的遍历与集合本身的实现分离开来，保证每个对象只负责自己的单一职责。\n2.开闭原则：新增一种集合类型或修改现有集合类型的实现方式都不会影响到已有的迭代器实现，因此该模式对修改关闭，对扩展开放。\n3.依赖倒置原则：在迭代器模式中，客户端只依赖于迭代器接口，而不依赖于集合的内部表示，从而将高层次模块从底层模块中解耦出来。\n4.迪米特原则：该模式通过将遍历集合的访问方法委托给迭代器对象来遵循迪米特原则，即一个对象应该对其他对象有最少的了解。\n以下是一个简单的Java案例，演示了迭代器的使用方式：\n//迭代器接口\ninterface Iterator&lt;T> &#123;\n    boolean hasNext();\n    T next();\n&#125;\n\n//集合接口\ninterface Aggregate&lt;T> &#123;\n    void add(T element);\n    void remove(T element);\n    Iterator&lt;T> iterator();\n&#125;\n\n//具体集合\nclass MyList&lt;T> implements Aggregate&lt;T> &#123;\n    private T[] elements;\n    private int size;\n    private int capacity;\n\n    public MyList(int capacity) &#123;\n        this.elements = (T[]) new Object[capacity];\n        this.size = 0;\n        this.capacity = capacity;\n    &#125;\n\n    public void add(T element) &#123;\n        if(size &lt; capacity) &#123;\n            elements[size] = element;\n            size++;\n        &#125;\n    &#125;\n\n    public void remove(T element) &#123;\n        for(int i = 0; i &lt; size; i++) &#123;\n            if(elements[i].equals(element)) &#123;\n                for(int j = i; j &lt; size - 1; j++) &#123;\n                    elements[j] = elements[j+1];\n                &#125;\n                size--;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    public Iterator&lt;T> iterator() &#123;\n        return new MyListIterator();\n    &#125;\n\n    //具体迭代器\n    private class MyListIterator implements Iterator&lt;T> &#123;\n        private int index = 0;\n\n        public boolean hasNext() &#123;\n            return index &lt; size;\n        &#125;\n\n        public T next() &#123;\n            T element = elements[index];\n            index++;\n            return element;\n        &#125;\n    &#125;\n&#125;\n\n//客户端代码\npublic class IteratorDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建一个列表\n        MyList&lt;String> list = new MyList&lt;>(5);\n        list.add(\"One\");\n        list.add(\"Two\");\n        list.add(\"Three\");\n        list.add(\"Four\");\n        list.add(\"Five\");\n\n        // 遍历列表中的元素\n            Iterator&lt;String> iterator = list.iterator();\n    while (iterator.hasNext()) &#123;\n        String element = iterator.next();\n        System.out.println(\"Element: \" + element);\n    &#125;\n&#125;\n\n 在上述示例中，我们定义了一个具体集合类MyList，该类实现了Aggregate接口，并包含了一个具体迭代器类MyListIterator。我们还定义了客户端代码用于测试集合的遍历，创建了一个列表并添加了元素，然后使用迭代器遍历列表中的每一个元素。执行该程序，会输出以下结果： \nElement: One\nElement: Two\nElement: Three\nElement: Four\nElement: Five\n\n在迭代器模式中，集合和迭代器是紧密相关联的。集合提供了快速访问迭代器的方法，而迭代器则提供了遍历整个集合的方法。这样，我们可以通过创建不同的迭代器对象来实现不同的遍历方式，而不会影响到集合的底层实现。因此，迭代器模式非常适合于需要访问和遍历集合元素的场景，可以提供一种清晰且灵活的解决方案。\n","slug":"迭代器模式","date":"2023-05-15T09:44:26.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"35b7e7d45f0bf660fac88351c60754e3","title":"命令模式","content":"命令模式它允许将请求封装为对象，从而使得请求的发送者和接收者解耦，同时可实现请求的队列化、撤销和恢复。\n该模式的关键点是将请求与实现解耦并引入命令对象，以便将请求发送给不同的对象，并可随时进行撤销和恢复。通常情况下，命令对象包含执行请求的接收者、请求数据以及实现该请求的方法。\n命令模式包括以下几个元素：\n1.命令接口（Command）：此接口定义了一个execute()方法，当Command对象被调用时，该方法会调用具体命令的execute()方法。\n2.具体命令类（Concrete Command）：此类实现了Command接口的execute()方法，它包含了一个Receiver对象，并包含了执行所需的所有参数。\n3.接收者（Receiver）：该组件包含了实现命令所需的代码和逻辑。\n4.调用者（Invoker）：该组件负责发送命令，通常会包含一个Command对象的引用。它还可维护一个命令历史记录，以便支持撤销和恢复操作。\n5.客户端（Client）：该组件创建具体命令对象，并将其传递给调用者对象以执行所需的操作。\n通过使用命令模式，我们可以将请求者与实现者彻底解耦，使得请求者无需知道具体执行者的存在和实现细节，并且可以轻松地对请求进行控制、评估、测试和管理。同时，命令模式还能实现请求的撤销和恢复，大大提升系统的可靠性和可维护性。\n以下是一个简单的Java案例，演示了命令模式的使用方式：\n//命令接口\npublic interface Command &#123;\n    void execute();\n&#125;\n\n//具体命令类: 打开文件命令\npublic class OpenCommand implements Command &#123;\n    private Receiver receiver;\n\n    public OpenCommand(Receiver receiver) &#123;\n        this.receiver = receiver;\n    &#125;\n\n    public void execute() &#123;\n        receiver.open();\n    &#125;\n&#125;\n\n//具体命令类: 关闭文件命令\npublic class CloseCommand implements Command &#123;\n    private Receiver receiver;\n\n    public CloseCommand(Receiver receiver) &#123;\n        this.receiver = receiver;\n    &#125;\n\n    public void execute() &#123;\n        receiver.close();\n    &#125;\n&#125;\n\n//接收者：文件编辑器\npublic class Receiver &#123;\n    public void open() &#123;\n        System.out.println(\"打开文件\");\n    &#125;\n\n    public void close() &#123;\n        System.out.println(\"关闭文件\");\n    &#125;\n&#125;\n\n//调用者：文本编辑器\npublic class Invoker &#123;\n    private Command openCommand;\n    private Command closeCommand;\n\n    public Invoker(Command openCommand, Command closeCommand) &#123;\n        this.openCommand = openCommand;\n        this.closeCommand = closeCommand;\n    &#125;\n\n    public void clickOpen() &#123;\n        openCommand.execute();\n    &#125;\n\n    public void clickClose() &#123;\n        closeCommand.execute();\n    &#125;\n&#125;\n\n//客户端代码\npublic class CommandDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建接收者\n        Receiver receiver = new Receiver();\n\n        // 创建具体命令对象\n        Command openCommand = new OpenCommand(receiver);\n        Command closeCommand = new CloseCommand(receiver);\n\n        // 创建调用者并将具体命令对象传给它\n        Invoker invoker = new Invoker(openCommand, closeCommand);\n\n        // 点击打开文件按钮\n        invoker.clickOpen();\n\n        // 点击关闭文件按钮\n        invoker.clickClose();\n    &#125;\n&#125;\n\n在上述示例中，我们定义了命令接口Command及两个具体命令类OpenCommand和CloseCommand，对应于文件的打开和关闭操作。我们还定义了一个接收者Receiver，表示文件编辑器，拥有打开和关闭文件的操作。Invoker负责调用具体命令对象执行对应的操作，即点击打开或关闭文件按钮。客户端代码创建具体命令对象和调用者，并传入。\n","slug":"命令模式","date":"2023-05-15T09:17:29.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"d75c20296e97428894e8c62bab0f606e","title":"访问者模式","content":"访问者模式它将算法封装到独立的对象中，使其可以在不修改现有对象结构的情况下增加新的操作。访问者模式的核心思想是在被访问的对象上定义一个接受访问者对象的接口，然后访问者对象通过该接口访问被访问对象。这样可以使得被访问对象保持稳定，而访问者对象可以根据需要进行扩展。\n访问者模式包含以下几个元素：\n1.访问者（Visitor）：该组件定义了处理对象结构中各个元素所要执行的方法，这些方法接受的参数可以是元素本身，也可以是元素的特定属性。\n2.具体访问者（Concrete Visitor）：该组件实现了访问者定义的方法，以便可以对对象结构中的不同元素执行特定的操作。\n3.元素（Element）：该组件定义了访问者能够访问的接口，一般它包含一个 accept() 方法，该方法接受一个访问者作为参数。\n4.具体元素（Concrete Element）：该组件实现了元素的接口，它可以被一个具体访问者实例访问并执行特定的操作。\n5.对象结构（Object Structure）：该组件是元素的集合，它定义了元素的集合以及提供可以接受访问者访问的接口。\n以下是一个简单的Java案例，演示了访问者模式的使用方式：\n假设我们有一个图形类层次结构，包括Rectangle、Circle和Triangle三个具体类型。我们可以定义一个Visitor接口，将不同的操作定义为Visitor的方法。然后，我们可以实现具体的Visitor类 RectangleVisitor、CircleVisitor和TriangleVisitor，并为每个具体类提供accept()方法，该方法接受一个Visitor对象并调用visit()方法。\n// Element接口\ninterface Shape &#123;\n    void accept(Visitor v);\n&#125;\n\n// 具体元素类：矩形\nclass Rectangle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// 具体元素类：圆形\nclass Circle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// 具体元素类：三角形\nclass Triangle implements Shape &#123;\n    public void accept(Visitor v) &#123;\n        v.visit(this);\n    &#125;\n&#125;\n\n// Visitor接口\ninterface Visitor &#123;\n    void visit(Rectangle r);\n    void visit(Circle c);\n    void visit(Triangle t);\n&#125;\n\n// 具体访问者类：用于计算图形面积\nclass AreaVisitor implements Visitor &#123;\n    public void visit(Rectangle r) &#123;\n        System.out.println(\"计算矩形的面积\");\n    &#125;\n    public void visit(Circle c) &#123;\n        System.out.println(\"计算圆形的面积\");\n    &#125;\n    public void visit(Triangle t) &#123;\n        System.out.println(\"计算三角形的面积\");\n    &#125;\n&#125;\n\n// 具体访问者类：用于计算图形周长\nclass PerimeterVisitor implements Visitor &#123;\n    public void visit(Rectangle r) &#123;\n        System.out.println(\"计算矩形的周长\");\n    &#125;\n    public void visit(Circle c) &#123;\n        System.out.println(\"计算圆形的周长\");\n    &#125;\n    public void visit(Triangle t) &#123;\n        System.out.println(\"计算三角形的周长\");\n    &#125;\n&#125;\n\n// 测试代码\npublic class VisitorDemo &#123;\n    public static void main(String[] args) &#123;\n        // 创建图形列表\n        Shape[] shapes = &#123; new Rectangle(), new Circle(), new Triangle() &#125;;\n\n        // 计算面积\n        Visitor areaVisitor = new AreaVisitor();\n        for (Shape shape : shapes) &#123;\n            shape.accept(areaVisitor);\n        &#125;\n\n        // 计算周长\n        Visitor perimeterVisitor = new PerimeterVisitor();\n        for (Shape shape : shapes) &#123;\n            shape.accept(perimeterVisitor);\n        &#125;\n    &#125;\n&#125;\n\n在上述示例中，我们定义了三个具体元素类：矩形、圆形和三角形，并定义了两个具体访问者类：用于计算面积和周长。在测试代码中，我们创建了一个图形列表，遍历该列表并分别使用AreaVisitor和PerimeterVisitor访问器计算每一个图形的面积和周长。执行该程序会输出如下结果：\n计算矩形的面积\n计算圆形的面积\n计算三角形的面积\n计算矩形的周长\n计算圆形的周长\n计算三角形的周长\n\n案例二\n下面是一个Java实现访问者模式的小案例。假设有一个电商平台，需要对用户购买记录进行分析，包括计算用户购买总金额、计算用户购买物品种类数等统计工作。首先定义被访问对象：购物车条目CartItem和用户购物车Cart：\npublic interface CartItem &#123;\n    void accept(Visitor visitor);\n&#125;\n\npublic class ProductCartItem implements CartItem &#123;\n    private String name;\n    private double price;\n\n    public ProductCartItem(String name, double price) &#123;\n        this.name = name;\n        this.price = price;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\npublic class ServiceCartItem implements CartItem &#123;\n    private String name;\n    private double fee;\n\n    public ServiceCartItem(String name, double fee) &#123;\n        this.name = name;\n        this.fee = fee;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public double getFee() &#123;\n        return fee;\n    &#125;\n\n    @Override\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n&#125;\n\npublic class Cart &#123;\n    private List&lt;CartItem> cartItems = new ArrayList&lt;>();\n\n    public void addItem(CartItem item) &#123;\n        cartItems.add(item);\n    &#125;\n\n    public void removeItem(CartItem item) &#123;\n        cartItems.remove(item);\n    &#125;\n\n    public void accept(Visitor visitor) &#123;\n        for (CartItem item : cartItems) &#123;\n            item.accept(visitor);\n        &#125;\n        visitor.visit(this);\n    &#125;\n&#125;\n\n其中，Cart类为购物车类，可以添加和删除购物项，accept方法接受Visitor访问。\n然后定义访问者Visitor，用来计算购物车中的统计数据：\npublic interface Visitor &#123;\n    void visit(ProductCartItem item);\n    void visit(ServiceCartItem item);\n    void visit(Cart cart);\n&#125;\n\npublic class CartStatisticsVisitor implements Visitor &#123;\n    private double totalAmount;\n    private int distinctProductCount;\n\n    public double getTotalAmount() &#123;\n        return totalAmount;\n    &#125;\n\n    public int getDistinctProductCount() &#123;\n        return distinctProductCount;\n    &#125;\n\n    @Override\n    public void visit(ProductCartItem item) &#123;\n        totalAmount += item.getPrice();\n        distinctProductCount++;\n    &#125;\n\n    @Override\n    public void visit(ServiceCartItem item) &#123;\n        totalAmount += item.getFee();\n    &#125;\n\n    @Override\n    public void visit(Cart cart) &#123;\n        System.out.printf(\"Total amount: $%.2f, distinct product count: %d%n\", \n            totalAmount, distinctProductCount);\n    &#125;\n&#125;\n\nCartStatisticsVisitor类实现了Visitor接口，计算购物车中的数量和总金额。visit方法根据被访问对象进行相应的计算，并将结果记录在中间变量中。最后，visit(Cart cart)方法输出结果。\n使用访问者模式统计购物车上的总金额和不同商品数量：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Cart cart = new Cart();\n        cart.addItem(new ProductCartItem(\"Apple\", 3.99));\n        cart.addItem(new ProductCartItem(\"Banana\", 2.99));\n        cart.addItem(new ServiceCartItem(\"Delivery fee\", 5.99));\n\n        CartStatisticsVisitor visitor = new CartStatisticsVisitor();\n        cart.accept(visitor);\n    &#125;\n&#125;\n\n输出结果为：\nTotal amount: $12.97, distinct product count: 2\n\n这样，通过访问者模式可以方便地对购物车数据进行统计分析，而不会修改现有代码。\n","slug":"访问者模式","date":"2023-05-15T08:21:18.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"ba45023a93415880bd8ff889992600c8","title":"中介者模式","content":"中介者模式它的作用是减少对象之间的直接耦合关系，通过引入一个中介者对象来协调多个对象之间的交互行为，从而将系统中复杂的网状关系变为简单的星型结构。\n中介者模式的机制基于以下两个关键点：\n\n抽象中介者（Mediator）：为了把各同事类的耦合度降到最低，将对象间通信的控制交给一个中介者来协调调度，具体同事类都依赖中介者，由中介者负责消息的转发和协调。\n具体中介者（Concrete Mediator）：它从具体的同事类接收消息，并向具体同事类发送命令。它将各个同事对象之间的交互过程所需的信息进行了封装，使得各个同事类不再需要显式地引用其他同事类。\n\n中介者模式的优点有：\n\n中介者模式简化了对象之间的交互关系，将对象之间复杂的网状结构转变为简单的星型结构。\n中介者模式使得各对象之间的耦合度大大降低，可以独立地变化和复用。\n中介者模式易于扩展，增加新的同事类时不需要修改原有的代码，只需要按照同样的方式实现新的同事类即可。\n\n中介者模式的缺点有：\n\n中介者模式会增加系统中对象的个数，使得系统变得复杂。\n中介者模式中，中介者对象可能会变得过于复杂，难以维护与更新。\n\n下面是一个简单的中介者模式的示例，假设有三个对象之间需要进行通信：买方、卖方和中介者。买方想要购买物品，卖方想要出售物品，而中介者作为协调者来帮助买卖双方进行交易。\n// 定义买方类\npublic class Buyer &#123;\n    private Mediator mediator;\n\n    public void setMediator(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void buyItem() &#123;\n        mediator.buyItem();\n    &#125;\n\n    public void receiveItem() &#123;\n        System.out.println(\"Received item from seller.\");\n    &#125;\n&#125;\n\n// 定义卖方类\npublic class Seller &#123;\n    private Mediator mediator;\n\n    public void setMediator(Mediator mediator) &#123;\n        this.mediator = mediator;\n    &#125;\n\n    public void sellItem() &#123;\n        mediator.sellItem();\n    &#125;\n\n    public void receivePayment() &#123;\n        System.out.println(\"Received payment from buyer.\");\n    &#125;\n&#125;\n\n// 定义中介者接口\npublic interface Mediator &#123;\n    void buyItem();\n    void sellItem();\n&#125;\n\n// 定义具体中介者类\npublic class TradeMediator implements Mediator &#123;\n    private Buyer buyer;\n    private Seller seller;\n\n    public void setBuyer(Buyer buyer) &#123;\n        this.buyer = buyer;\n        buyer.setMediator(this);\n    &#125;\n\n    public void setSeller(Seller seller) &#123;\n        this.seller = seller;\n        seller.setMediator(this);\n    &#125;\n\n    public void buyItem() &#123;\n        seller.receivePayment();\n        buyer.receiveItem();\n    &#125;\n\n    public void sellItem() &#123;\n        buyer.receivePayment();\n        seller.receiveItem();\n    &#125;\n&#125;\n\n// 测试类\npublic class MediatorTest &#123;\n    public static void main(String[] args) &#123;\n        TradeMediator mediator = new TradeMediator();\n        Buyer buyer = new Buyer();\n        Seller seller = new Seller();\n\n        mediator.setBuyer(buyer);\n        mediator.setSeller(seller);\n\n        buyer.buyItem();\n        seller.sellItem();\n    &#125;\n&#125;\n\n在这个示例中，各个类分别代表了买方、卖方和中介者。买方需要购买物品并接收物品，卖方需要出售物品并接收付款，而中介者则负责调节买卖双方之间的交易。通过中介者模式，买方和卖方可以通过中介者来进行通信，它们不需要直接相互了解，从而降低了耦合度。\n","slug":"中介者模式","date":"2023-05-15T07:45:06.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"4fe76f7b940933ddf5de5f39814faa1c","title":"MySQL_DQL","content":"DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录\n基本语法DQL 查询语句，语法结构如下：\nSELET\n\t字段列表\nFROM\n\t表名列表\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n\n\n基本查询（不带任何条件）\n\n条件查询（WHERE）\n\n聚合函数（count、max、min、avg、sum）\n\n分组查询（group by）\n\n排序查询（order by）\n\n分页查询（limit）\n\n\n基础查询 * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）\n 查询多个字段\nSELECT 字段1, 字段2, 字段3 ... FROM 表名 ;\n\nSELECT * FROM 表名 ;\n\n字段设置别名\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名; \n\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\n\n去除重复记录(DISTINCT)\nSELECT DISTINCT 字段列表 FROM 表名;\n\n查询所有员工的工作地址,起别名,不重复\nSELECT DISTINCT workaddress '工作地址' from  emp;\n\n条件查询语法\nSELECT 字段名 from 表名 WHERE 条件列表; \n\n\n\n\n运算符\n功能\n\n\n\n&gt; 、&gt;&#x3D;\n大于、大于等于\n\n\n&lt; 、&lt;&#x3D;\n小于、小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt; 、!&#x3D;\n不等于\n\n\nBETWEEN … AND …\n在某个范围之内(包含最小、最大值)\n\n\nIN(…)\n在in之后的列表中的值\n\n\nLIKE  占位符\n模糊匹配(_匹配单个字符, %匹配任意个字符)\n\n\nIS  NOT NULL\n不是NULL\n\n\nIS  NULL\n是NULL\n\n\nAND 、&amp;&amp;\n并且 (多个条件同时成立)\n\n\nOR 、||\n或者 (多个条件任意一个成立)\n\n\nNOT 、!\n非 , 不是\n\n\n 小案例：查询没有身份证号的员工信息\n不可以使用 &#x3D; null\nSELECT * FROM emp WHERE idcard IS NULL;\n\n聚合函数\n将一列数据作为一个整体，进行纵向计算\n常见的聚合函数\n\n\n\n函数\n描述\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n语法\nSELECT 聚合函数(字段列表) FROM 表名 [条件查询] ...;\n\n注意 :NULL值是不参与所有聚合函数运算的\n对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字&#x2F;字符串)的形式进行统计查询\n小案例：统计该企业员工数量\nSELECT count(idcard) from emp;\t-- 字段值为NULL，是不参与所有聚合函数运算的\nSELECT count(*) from emp;\nSELECT count(1) from emp;\n\n分组查询\nSELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组\n后过滤条件 ];\n\n where与having区别\n\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤\n\n判断条件不同：where不能对聚合函数进行判断，而having可以\n\n\n注意事项:\n\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n\n执行顺序: where &gt; 聚合函数 &gt; having 。\n\n支持多字段分组, 具体语法为 : group by columnA,columnB\n\n\n小案例：查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址\nselect workaddress,count(*) number from emp \nwhere age &lt; 45 \ngroup by workaddress\nhaving number >= 3;\n\n小案例： 统计各个工作地址上班的男性及女性员工的数量\nselect workaddress,gender,count(*) number from emp GROUP BY workaddress, gender;\n\n排序查询 语法\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;\n\n 排序方式      ASC : 升序(默认值)      DESC: 降序\n如果是升序, 可以不指定排序方式ASC ;\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n小案例：根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序\nselect * from emp order by age desc, entrydate desc;\n\n分页查询语法\n起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。\n分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。\nSELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;\n\n小案例：查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数\nselect * from emp limit 10, 10;\n\n执行顺序\n验证  : 查询年龄大于15的员工姓名、年龄，并根据年龄进行升序排序\nselect name, age from emp where age > 15 order by age asc;\n\n在查询时，我们给emp表起一个别名 e，然后在select 及 where中使用该别名。\nselect e.name, e.age from emp e where e.age > 15 order by age asc;\n\n执行上述SQL语句后，我们看到依然可以正常的查询到结果，此时就说明： from 先执行, 然后where 和 select 执行。\n那 where 和 select 到底哪个先执行呢?\n此时，此时我们可以给select后面的字段起别名，然后在 where 中使用这个别名，然后看看是否可以执行成功。\nselect e.name, e.age eage from emp e where eage > 15 order by e.age asc;\n\n执行上述SQL报错了:1054 - Unknown column ‘eage’ in ‘where clause’\n说明是执行完from之后，到执行where。\n接下来，我们再执行如下SQL语句，查看执行效果：\nselect e.name ename , e.age eage from emp e where e.age > 15 order by eage asc;\n\n结果执行成功。 那么也就验证了: order by 是在select 语句之后执行的。\n综上所述，DQL语句的执行顺序为：\nfrom ... where ... group by ...having ... select ... order by ... limit ...\n\n","slug":"MySQL-DQL","date":"2023-05-14T06:22:31.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"676b4ad0d6495672245716dc73cc8c9e","title":"MySQL_DML","content":"DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进\n行增、删、改操作。\n添加数据 给指定字段添加数据\nINSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...);\n\n案例: 给employee表所有的字段添加数据\nINSERT INTO employee(id,workno,name,gender,age,idcard,entrydate)\nVALUES(1,'1','HJ','女',20,'450802200206141527','2023-05-14');\n\n给全部字段添加数据\nINSERT INTO employee \nvalues(2,'2','H','男',23,'45080220001121057X','2023-07-10');\n\n批量添加数据\nINSERT INTO 表名(字段1，字段2, ...) values\n(v1, v2, ...),(a1, a2, ...),(b1, b2, ...);\n/*\n或者\n*/\nINSERT INTO 表名\nVALUES (v1, v2, ...),(a1, a2, ...),(b1, b2, ...);\n\n执行DML语句，会检查插入的字段是否符合字段的类型，不符合会报错。\n 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n 字符串和日期型数据应该包含在引号中。\n插入的数据大小，应该在字段的规定范围内。\n日期类型要连续，否则会报错\n修改数据\nUPDATE 表名 SET 字段1 &#x3D; V1, 字段2 &#x3D; V2, ... [WHERE 条件];\n\n删除数据\nDELEDE FROM 表名 [WHERE 条件];\n\n• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n• DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n\n\n\n类型\n大小\n有符号范围\n无符号范围\n描述\n\n\n\nTINYINT\n1byte\n(-2^7，2^7-1)\n(0，2^8-1)\n小整数值\n\n\nSMALLINT\n2bytes\n(-2^15，2^15-1)\n(0，2^16-1)\n大整数值\n\n\nMEDIUMINT\n3bytes\n(-2^23，2^23-1)\n(0，2^24-1)\n大整数值\n\n\nINT&#x2F;INTEGER\n4bytes\n(-2^31，2^31-1)\n(0，2^32-1)\n大整数值\n\n\nBIGINT\n8bytes\n(-2^63，2^63-1)\n(0，2^64-1)\n大整数值\n\n\nFLOAT\n4bytes\n(-3.402823466 E+38，3.402823466351 E+38)\n\n双精度浮点数值\n\n\nDOUBLE\n8bytes\n(-1.7976931348623157E+308，1.7976931348623157E+308)\n\n单精度浮点数值\n\n\nDECIMAL\n\n依赖于M(精度)和D(标度)\n依赖于M(精度)和D(标度)\n小数值(精确定点数)\n\n\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0-255 bytes\n定长字符串(需要指定长度)\n\n\nVARCHAR\n0-65535 bytes\n变长字符串(需要指定长度)\n\n\nTINYBLOB\n0-255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0-255 bytes\n短文本字符串\n\n\nBLOB\n0-65 535 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0-65 535 bytes\n长文本数据\n\n\nMEDIUMBLOB\n0-16 777 215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0-16 777 215 bytes\n中等长度文本数据\n\n\nLONGBLOB\n0-4 294 967 295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0-4 294 967 295 bytes\n极大文本数据\n\n\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至 9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至 838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值，时间戳\n\n\n","slug":"MySQL-DML","date":"2023-05-14T01:30:25.000Z","categories_index":"","tags_index":"MySQL","author_index":"大宝贝的程序员"},{"id":"56fbe19991b11dc0bb9030f36adcdf92","title":"MySQL_DDL_Linux","content":"启动MySQL服务启动mysql服务\nsystemctl start mysqld\n\n重启mysql服务\nsystemctl restart mysqld\n\n停止mysql服务\nsystemctl stop mysqld\n\n查询首次安装数据库自动生成的root密码grep 'temporary password' /var/log/mysqld.log\n\n命令行执行指令\nmysql [-h 127.0.0.1] -u root -p密码\n\n修改root用户密码登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码\nALTER USER 'root'@'localhost' IDENTIDFIED BY 'hj0614';\n\n执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。\n设置密码的复杂度为简单类型\nset global validate_password.policy = 0;\n\n设置密码长度为6\nset global validate_password.length = 6;\n\n再次执行上述修改密码的指令!\n创建用户默认的root用户只能当前节点localhost访问，是无法远程访问的\n我们还需要创建一个root账户，用户远程访问\ncreate user 'root'@'%' IDENTIFIDE WITH mysql_native_password BY 'hj0614';\n\n给用户分配权限grant all on root.* to 'root'@'%';\n\n重新连接mysql\n查看权限show grants for  'root'@'%';\n\n撤销权限revoke all on root.* from 'root'@'%'\n\nSQL通用语法\nSQL语句可以单行或多行书写，以分号 ; 结尾。\nSQL语句可以使用空格 &#x2F; 缩进来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释：\n单行注释：– 注释内容 或 # 注释内容\n多行注释：&#x2F;* 注释内容 *&#x2F;\n\nSQL分类SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL\n\n\n\nDDL：Data Definition Language\n数据定义语言，用来定义数据库对象(数据库，表，字段）\n\n\n\nDML：Data Manipulation  Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL：Data Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL：Data Control Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\nDDL语句查询所有数据库\nshow databases;\n\n查询当前数据库\nselect database();\n\n创建数据库 [表示可选项]\ncreate database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];\n\n示例：创一个数据库使用默认的字符集，默认排列\ncreate database if not exists test; \n\n删除数据库     如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists\ndrop database [if exists] 数据库名;\n\n切换数据库\nuse 数据库名;\n\n查询当前数据库所有表\nshow tables;\n\n查看指定表结构\n通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息\ndesc 表名;\n\n查询指定表的建表语句\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询\n到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\nshow create table 表名;\n\n小案例：查看employee表的建表语句\nemployee\tCREATE TABLE `employee` (\n  `id` int DEFAULT NULL COMMENT '编号',\n  `workno` varchar(10) DEFAULT NULL,\n  `name` varchar(10) DEFAULT NULL COMMENT '姓名',\n  `gender` char(1) DEFAULT NULL COMMENT '性别',\n  `age` tinyint unsigned DEFAULT NULL COMMENT '年龄',\n  `idcard` char(18) DEFAULT NULL COMMENT '身份证号',\n  `workaddress` varchar(50) DEFAULT NULL COMMENT '工作地址',\n  `entrydate` date DEFAULT NULL COMMENT '入职时间'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表'\n\n创建表结构\t\n最后一个字段后面没有逗号\nCREATE TABLE 表名(\n字段1 字段1类型 [COMMENT 字段1注释],\n字段2 字段2类型 [COMMENT 字段2注释],\n...\n字段n 字段n类型 [COMMENT 字段n注释]\n) [COMMENT 表注释];\n\n小案例：设计一张员工信息表，要求如下：\n\n编号（纯数字）\n\n员工工号 (字符串类型，长度不超过10位)\n\n员工姓名（字符串类型，长度不超过10位）\n\n性别（男&#x2F;女，存储一个汉字）\n\n年龄（正常人年龄，不可能存储负数）\n\n身份证号（二代身份证号均为18位，身份证中有X这样的字符）\n\n入职时间（取值年月日即可）\n\n\ncreate table emp(\n id int comment '编号',\n workno varchar(10) comment '员工工号',\n name varchar(10) comment '员工姓名',\n sex char(1) comment '性别',\n age tinyint comment '年龄',\n idcard char(18) comment '身份证',\n entrydate date  comment '入职时间'\n) comment '员工信息表'\n\n添加表字段(ADD)\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\n\n小案例：为emp添加一个新的字段”昵称”为nickname，类型为varchar(20);\nALTER TABLE emp ADD nickname varchar(20) comment '昵称';\n\n修改数据类型(MODIFY)\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n\n 修改字段名和字段类型(CHANGE)\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [comment 注释] [约束]\n\n小案例：将emp表的nickname字段修改为username，类型为varchar(30)\nALTER TABLE emp CHANGE nikename username varchar(30) comment '昵称';\n\n删除字段(DROP)\nALTER TABLE 表名 DROP 字段名;\n\n小案例：将emp表的字段username删除\nALTER TABLE emp DROP username;\n\n修改表名(RENAME TO)\nALTER TABLE 表名 RENAME TO 新表名;\n\n小案例：将emp表的表名修改为 employee\nALTER TABLE emp RANAME TO employee;\n\n 删除表\nDROP TABLE [IF EXISTS] 表名;\n\n小案例：如果tb_user表存在，则删除tb_user表\nDROP TABLE IF EXISTS tb_user;\n\n 删除指定表, 并重新创建表\nTRUNCATE TABLE 表名;\n\n","slug":"MySQL-DDL","date":"2023-05-13T10:36:19.000Z","categories_index":"","tags_index":"Linux,MySQL","author_index":"大宝贝的程序员"},{"id":"b847fc9b240aefdbf95225a3e7dc9026","title":"Spring Bean的生命周期","content":"Spring Bean的生命周期getBean方法都会调用doGetBean的逻辑\n    public &lt;T> T getBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object... args) throws BeansException &#123;\n        return this.doGetBean(name, requiredType, args, false);\n    &#125;\n\nprotected &lt;T> T doGetBean(String name, @Nullable Class&lt;T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123;\n    ....\n    &#125;\n\nbean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：\n\n处理名称，检查缓存\n处理父子容器\n处理 dependsOn\n选择 scope 策略\n创建singleton\n创建prototype\n创建其他scope\n\n\n创建 bean\n创建bean实例\n依赖注入\n初始化\n登记可销毁的bean\n\n\n类型转换处理\n销毁 bean\n\n\n\n\n\n\n\n\n\n\n注意\n\n划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情\n\n1. 处理名称，检查缓存\n\n这一步会处理别名，将别名解析为实际名称\n对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品\n这里针对单例对象会检查一级、二级、三级缓存\nsingletonFactories 三级缓存，存放单例工厂对象\nearlySingletonObjects 二级缓存，存放单例工厂的产品对象\n如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象\n\n\nsingletonObjects 一级缓存，存放单例成品对象\n\n\n\n2. 处理父子容器\n\n如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程\n父子容器的 bean 名称可以重复\n\n3. 处理 dependsOn\n\n如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean \n所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序\n\n4. 选择 scope 策略\n\n对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程\n对于 prototype scope，每次都会进入创建流程\n对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程\n\npublic class TestScope &#123;\n    public static void main(String[] args) &#123;\n        testRequestScope();\n    &#125;\n\n    // 单例 bean 从 refresh 被创建, 到 close 被销毁, BeanFactory 会记录哪些 bean 要调用销毁方法\n    private static void testSingletonScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"bean1\", Bean1.class);\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh(); // getBean\n        context.close();\n    &#125;\n\n    // 多例 bean 从首次 getBean 被创建, 到调用 BeanFactory 的 destroyBean 被销毁\n    private static void testPrototypeScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setScope(\"prototype\"));\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh();\n\n        Bean1 bean = context.getBean(Bean1.class);\n        // 没谁记录该 bean 要调用销毁方法, 需要我们自行调用\n        context.getDefaultListableBeanFactory().destroyBean(bean);\n\n        context.close();\n    &#125;\n\n    // request bean 从首次 getBean 被创建, 到 request 结束前被销毁\n    private static void testRequestScope() &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.getDefaultListableBeanFactory().registerScope(\"request\", new RequestScope());\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setScope(\"request\"));\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.refresh();\n\n        for (int i = 0; i &lt; 2; i++) &#123;\n            new Thread(() -> &#123;\n                MockHttpServletRequest request = new MockHttpServletRequest();\n                // 每个 webRequest 对象会记录哪些 bean 要调用销毁方法\n                ServletWebRequest webRequest = new ServletWebRequest(request);\n                RequestContextHolder.setRequestAttributes(webRequest);\n\n                Bean1 bean = context.getBean(Bean1.class);\n                LoggerUtils.get().debug(\"&#123;&#125;\", bean);\n                LoggerUtils.get().debug(\"&#123;&#125;\", request.getAttribute(\"bean1\"));\n\n                // request 请求结束前调用这些销毁方法\n                webRequest.requestCompleted();\n            &#125;).start();\n        &#125;\n\n    &#125;\n\n    static class Bean1 &#123;\n        @PostConstruct\n        public void init() &#123;\n            LoggerUtils.get().debug(\"&#123;&#125; - init\", this);\n        &#125;\n\n        @PreDestroy\n        public void destroy() &#123;\n            LoggerUtils.get().debug(\"&#123;&#125; - destroy\", this);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n5.1 创建 bean - 创建 bean 实例   \t创建出空的实例\n\n\n\n要点\n总结\n\n\n\n有自定义 TargetSource 的情况\n由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回\n\n\nSupplier 方式创建 bean 实例\n为 Spring 5.0 新增功能，方便编程方式创建  bean  实例\n\n\nFactoryMethod 方式  创建 bean  实例\n① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选\n\n\nAutowiredAnnotationBeanPostProcessor\n① 优先选择带  @Autowired  注解的构造；② 若有唯一的带参构造，也会入选\n\n\nmbd.getPreferredConstructors\n选择所有公共构造，这些构造之间按权重筛选\n\n\n采用默认构造\n如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的\n\n\n5.2 创建 bean - 依赖注入\n\n\n\n要点\n总结\n\n\n\nAutowiredAnnotationBeanPostProcessor\n识别   @Autowired  及 @Value  标注的成员，封装为  InjectionMetadata 进行依赖注入\n\n\nCommonAnnotationBeanPostProcessor\n识别   @Resource  标注的成员，封装为  InjectionMetadata 进行依赖注入\n\n\nresolveDependency\n用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy  注解；④ @Value  注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）\n\n\nAUTOWIRE_BY_NAME\n根据成员名字（set方法的名字）找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员\n\n\nAUTOWIRE_BY_TYPE\n根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues\n\n\napplyPropertyValues\n根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref\n\n\n依赖注入的优先级// 测试如果对同一属性进行的 @Autowired 注入、AUTOWIRE_BY_NAME、精确指定注入名称, 优先级是怎样的\npublic class TestInjection &#123;\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.registerBean(\"bean1\", Bean1.class, bd -> &#123;\n            // 优先级最高的：精确指定注入 bean 的名称 &lt;property name=\"bean3\" ref=\"bean2\"/> \t\t\t\t//property标签也是根据set方法进行注入的\n            bd.getPropertyValues().add(\"bean3\", new RuntimeBeanReference(\"bean2\"));\n            // 优先级次之的：通过 AUTOWIRE_BY_NAME 匹配\n            ((RootBeanDefinition) bd).setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_NAME);\n        &#125;);\n        context.registerBean(\"bean2\", Bean2.class);\n        context.registerBean(\"bean3\", Bean3.class);\n        context.registerBean(\"bean4\", Bean4.class);\n\n        context.refresh();\n    &#125;\n\n    static class Bean1 &#123;\n        MyInterface bean;\n\n        // 优先级最低的：@Autowired 匹配\n        @Autowired @Qualifier(\"bean4\")\n        public void setBean3(MyInterface bean) &#123;\n            System.out.println(bean);\n            this.bean = bean;\n        &#125;\n    &#125;\n\n    interface MyInterface &#123;\n    &#125;\n\n    static class Bean2 implements MyInterface &#123;\n    &#125;\n\n    static class Bean3 implements MyInterface &#123;\n    &#125;\n\n    static class Bean4 implements MyInterface &#123;\n    &#125;\n&#125;\n\n精确匹配的优先级最高，其次到按名字匹配AUTOWIRE_BY_NAME，最后是注解方式\n5.3 创建 bean - 初始化\n\n\n\n要点\n总结\n\n\n\n内置 Aware 接口的装配\n包括 BeanNameAware，BeanFactoryAware 等\n\n\n扩展 Aware 接口的装配\n由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization\n\n\n@PostConstruct\n由 CommonAnnotationBeanPostProcessor 解析，执行时机在  postProcessBeforeInitialization\n\n\nInitializingBean\n通过接口回调执行初始化\n\n\ninitMethod\n根据 BeanDefinition 得到的初始化方法执行初始化，即 &lt;bean init-method&gt; 或 @Bean(initMethod)\n\n\n创建 aop 代理\n由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在  postProcessAfterInitialization\n\n\n初始化方法的执行顺序public class TestInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        // &lt;bean init-method=\"initMethod\">\n        context.registerBean(\"bean1\", Bean1.class, bd -> bd.setInitMethodName(\"initMethod\"));\n        context.refresh();\n    &#125;\n\n    static class Bean1 implements InitializingBean, BeanFactoryAware &#123;\n\n        @Override\n        public void afterPropertiesSet() throws Exception &#123;\n            System.out.println(1);\n        &#125;\n\n        @PostConstruct\n        public void init() &#123;\n            System.out.println(2);\n        &#125;\n\n        public void initMethod() &#123;\n            System.out.println(3);\n        &#125;\n\n        @Override\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;\n            System.out.println(4);\n        &#125;\n    &#125;\n&#125;\n\n先执行内置 Aware 接口 -&gt;@PostConstruct -&gt;InitializingBean -&gt; initMethod\n4\n2\n1\n3\n\n5.4 创建 bean - 注册可销毁 bean\n在这一步判断并登记可销毁 bean\n\n判断依据\n如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean\n如果自定义了 destroyMethod，则为可销毁 bean\n如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）\n如果有 @PreDestroy 标注的方法\n\n\n存储位置\nsingleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中\n自定义 scope 的可销毁 bean 会存储于对应的域对象当中\nprototype scope 不会存储，需要自己找到此对象销毁\n\n\n存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配，体现了适配器模式\n\n6. 类型转换处理\n\n如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换\n\n7. 销毁 bean\n\n销毁时机\nsingleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁\n自定义 scope bean 的销毁在作用域对象生命周期结束时\nprototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁\n\n\n同一 bean 中不同形式销毁方法的调用次序\n优先后处理器销毁，即 @PreDestroy\n其次 DisposableBean 接口销毁\n最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）\n\n\n\n","slug":"Spring Bean的生命周期","date":"2023-05-13T04:32:54.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"ec47f8662f4dbcb9ad26f0a7bcc5e407","title":"Spring refresh流程","content":"refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：\n\nprepareRefresh –做好准备工作\n\nobtainFreshBeanFactory –创建或获取BeanFactory\n\nprepareBeanFactory –准备BeanFactory\n\npostProcessBeanFactory – 子类拓展BeanFactory\n\ninvokeBeanFactoryPostProcessors –后处理器拓展BeanFactory\n\nregisterBeanPostProcessors –准备Bean后处理器\n\ninitMessageSource –为ApplicationContext提供国际化功能\n\ninitApplicationEventMulticaster –为ApplicationContext提供事件发布器\n\nonRefresh – 留给子类拓展\n\nregisterListeners –为ApplicationContext准备监听器\n\nfinishBeanFactoryInitialization – 初始化单例Bean，执行Bean后处理器拓展\n\nfinishRefresh – 准备生命周期管理器，发布ContextRefreshed事件\n\n\n\n\n\n\n\n\n\n\n\n功能分类\n\n1 为准备环境\n\n2 3 4 5 6 为准备 BeanFactory\n\n7 8 9 10 12 为准备 ApplicationContext\n\n11 为初始化 BeanFactory 中非延迟单例 bean\n\n\n1. prepareRefresh\n\n这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量\n\nEnvironment 对象的作用之一是为后续 @Value，值注入时提供键值\n\nEnvironment 分成三个主要部分\n\nsystemProperties - 保存 java 环境键值\nsystemEnvironment - 保存系统环境键值\n自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值\n\n\n\n\n示例// 如何获得和解析 @Value 内容\npublic class TestEnvironment &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IOException &#123;\n        // 1) 获得 @Value 的值\n        System.out.println(\"=======================> 仅获取 @Value 值\");\n        QualifierAnnotationAutowireCandidateResolver resolver = new QualifierAnnotationAutowireCandidateResolver();\n        Object name = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"name\"), false));\n        System.out.println(name);\n\n        // 2) 解析 @Value 的值\n        System.out.println(\"=======================> 获取 @Value 值, 并解析$&#123;&#125;\");\n        Object javaHome = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"javaHome\"), false));\n        System.out.println(javaHome);\n        System.out.println(getEnvironment().resolvePlaceholders(javaHome.toString()));\n\n        // 3) 解析 SpEL 表达式\n        System.out.println(\"=======================> 获取 @Value 值, 并解析#&#123;&#125;\");\n        Object expression = resolver.getSuggestedValue(new DependencyDescriptor(Bean1.class.getDeclaredField(\"expression\"), false));\n        System.out.println(expression);\n        String v1 = getEnvironment().resolvePlaceholders(expression.toString());\n        System.out.println(v1);\n        //解析 #&#123;&#125;\n        System.out.println(new StandardBeanExpressionResolver().evaluate(v1, new BeanExpressionContext(new DefaultListableBeanFactory(),null)));\n    &#125;\n\n    private static Environment getEnvironment() throws IOException &#123;\n        //是Environment的重要实现，默认只能识别系统的键值，无法解析自定义的键值\n        //需要知道自定义键值的位置才能解析\n        StandardEnvironment env = new StandardEnvironment();\n        //添加自定文件的键值\n        env.getPropertySources().addLast(new ResourcePropertySource(\"jdbc\", new ClassPathResource(\"jdbc.properties\")));\n        return env;\n    &#125;\n\n    static class Bean1 &#123;\n        @Value(\"hello\")\n        private String name;\n\n        @Value(\"$&#123;jdbc.username&#125;\")\n        private String javaHome;\n\t\t\t\t//SpEL表达式\n        @Value(\"#&#123;'class version:' + '$&#123;java.class.version&#125;'&#125;\")\n        private String expression;\n    &#125;\n&#125;\n\n结果=======================> 仅获取 @Value 值\nhello\n=======================> 获取 @Value 值, 并解析$&#123;&#125;\n$&#123;jdbc.username&#125;\nroot\n=======================> 获取 @Value 值, 并解析#&#123;&#125;\n#&#123;'class version:' + '$&#123;java.class.version&#125;'&#125;\n#&#123;'class version:' + '61.0'&#125;\nclass version:61.0\n\n首先，创建了一个 QualifierAnnotationAutowireCandidateResolver 的实例，用来解析@Value的候处理器。然后创建了一个 new DependencyDescriptor(Bean1.class.getDeclaredField(“name”), false) 的实例用来描述 Bean1 类的 name 属性，这个实例中包含了该属性所在类的信息、属性的名称等详细信息。调用 QualifierAnnotationAutowireCandidateResolver 的 getSuggestedValue 方法，并传入 DependencyDescriptor 的实例来获取一个推荐的属性值。\n2. obtainFreshBeanFactory\n\n这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量\nBeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义\nBeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等\nBeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加\n\n\n所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合\n\n\n// 演示各种 BeanDefinition 的来源\npublic class TestBeanDefinition &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"========================> 一开始\");\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 1) 从 xml 获取 \");\n        XmlBeanDefinitionReader reader1 = new XmlBeanDefinitionReader(beanFactory);\n        reader1.loadBeanDefinitions(new ClassPathResource(\"bd.xml\"));\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 2) 从配置类获取 \");\n        beanFactory.registerBeanDefinition(\"config1\", BeanDefinitionBuilder.genericBeanDefinition(Config1.class).getBeanDefinition());\n\n        ConfigurationClassPostProcessor postProcessor = new ConfigurationClassPostProcessor();\n        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n\n        System.out.println(\"========================> 3) 扫描获取 \");\n        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanFactory);\n        scanner.scan(\"day04.refresh.sub\");\n        System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));\n    &#125;\n\n    static class Bean1 &#123;\n\n    &#125;\n\n    static class Bean2 &#123;\n\n    &#125;\n\n    static class Config1 &#123;\n        @Bean\n        public Bean2 bean2() &#123;\n            return new Bean2();\n        &#125;\n    &#125;\n&#125;\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"bean1\" class=\"day04.refresh.TestBeanDefinition$Bean1\"/>\n\n&lt;/beans>\n\npackage day04.refresh.sub;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Bean3 &#123;\n&#125;\n\n结果&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 一开始\n[]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1) 从 xml 获取 \n[bean1]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 2) 从配置类获取 \n[bean1, config1, bean2]\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 3) 扫描获取 \n[bean1, config1, bean2, bean3, org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory]\n\n\n3. prepareBeanFactory\n\n这一步会进一步完善 BeanFactory，为它的各项成员变量赋值\nbeanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver\npropertyEditorRegistrars 会注册类型转换器\n它在这里使用了 ResourceEditorRegistrar 实现类\n并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析\n\n\nregisterResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入\nbeanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：\nApplicationContextAwareProcessor 用来解析 Aware 接口\nApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean\n\n\n\n\n4. postProcessBeanFactory\n\n这一步是空实现，留给子类扩展。\n一般 Web 环境的 App0licationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory\n\n\n这里体现的是模板方法设计模式\n\n5. invokeBeanFactoryPostProcessors\n\n这一步会调用 beanFactory 后处理器\nbeanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition\n常见的 beanFactory 后处理器有\nConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等\nPropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }\nMapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition\n\n\n\n\n6. registerBeanPostProcessors\n\n这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中\nbean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：\nAutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解\nCommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy\nAnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理\n\n\n\n\n示例public class TestBeanPostProcessor &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n        beanFactory.registerBeanDefinition(\"bean1\", BeanDefinitionBuilder.genericBeanDefinition(Bean1.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"bean2\", BeanDefinitionBuilder.genericBeanDefinition(Bean2.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"bean3\", BeanDefinitionBuilder.genericBeanDefinition(Bean3.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"aspect1\", BeanDefinitionBuilder.genericBeanDefinition(Aspect1.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor1\",\n                BeanDefinitionBuilder.genericBeanDefinition(AutowiredAnnotationBeanPostProcessor.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor2\",\n                BeanDefinitionBuilder.genericBeanDefinition(CommonAnnotationBeanPostProcessor.class).getBeanDefinition());\n        beanFactory.registerBeanDefinition(\"processor3\",\n                BeanDefinitionBuilder.genericBeanDefinition(AnnotationAwareAspectJAutoProxyCreator.class).getBeanDefinition());\n\n        context.refresh();\n        beanFactory.getBean(Bean1.class).foo();\n    &#125;\n\n    static class Bean1 &#123;\n        Bean2 bean2;\n        Bean3 bean3;\n\n        @Autowired\n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"发生了依赖注入...\" + bean2);\n            this.bean2 = bean2;\n        &#125;\n\n        @Resource\n        public void setBean3(Bean3 bean3) &#123;\n            System.out.println(\"发生了依赖注入...\" + bean3);\n            this.bean3 = bean3;\n        &#125;\n\n        public void foo() &#123;\n            System.out.println(\"foo\");\n        &#125;\n    &#125;\n\n    static class Bean2 &#123;\n\n    &#125;\n\n    static class Bean3 &#123;\n\n    &#125;\n\n    @Aspect\n    static class Aspect1 &#123;\n        @Before(\"execution(* foo())\")\n        public void before() &#123;\n            System.out.println(\"before...\");\n        &#125;\n    &#125;\n&#125;\n\n结果发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean3@19b843ba\n发生了依赖注入...day04.refresh.TestBeanPostProcessor$Bean2@dc9876b\nbefore...\nfoo\n\n7. initMessageSource\n\n这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能\n去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现\n\n\n8. initApplicationContextEventMulticaster\n\n这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster\n它的作用是发布事件给监听器\n去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器\n之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件\n\n\n9. onRefresh\n\n这一步是空实现，留给子类扩展\nSpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器\n\n\n体现的是模板方法设计模式\n\n10. registerListeners\n\n这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster\n事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源\n事先编程添加的\n来自容器中的 bean\n来自于 @EventListener 的解析\n\n\n要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可\n\n\n11. finishBeanFactoryInitialization\n\n这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean\nconversionService 也是一套转换机制，作为对 PropertyEditor 的补充\nembeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能\nsingletonObjects 即单例池，缓存所有单例对象\n对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能\n\n\n\n\n12. finishRefresh\n\n这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean\n如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器\n准备好生命周期管理器，就可以实现\n调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start\n调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop\n\n\n发布 ContextRefreshed 事件，整个 refresh 执行完成\n\n\n","slug":"Spring-refresh流程","date":"2023-05-13T01:19:52.000Z","categories_index":"","tags_index":"Java,Spring","author_index":"大宝贝的程序员"},{"id":"2846594611fd32071ec8e1a72cd8f17d","title":"Spring如何解决循环依赖","content":"Spring如何解决循环依赖解决Set循环依赖注入Spring一级缓存singletonObjects\nsingletonObjects是一级缓存，用于存储单例Bean的实例对象。也就是说，当Spring容器创建一个单例Bean时，会将该Bean的实例对象放入一级缓存中，在后续使用该Bean时，直接从缓存中获取实例对象，避免了重复创建实例对象的过程。\n当没有循环依赖注入时，可以正常创建Bean\n\n存在问题：无法解决循环依赖\n首先调用A的getBean()到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时B又需要用到A，又去一级缓存找A…..\n可见只有一级缓存是无法解决循环依赖注入的\n\n引入Spring的三级缓存singltonFactories\n解决循环依赖问题：\n先到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时创建的是一个半成品的A（工厂对象），把A放入三级缓存，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时创建的也是一个半成品的B，此时B又需要用到A，又去一级缓存找A发现没有，又去三级缓存找，找到了A，并完成依赖注入，把B的成品放入singletonObjects，然后清除singletonFactories内的半成品B。这是A就可以拿到B，完成初始化。把A放到一级缓存，并清除三级缓存的A。\n\n问题又来了：Spring注入的对象大多是代理对象，那么能否完成注入呢\n先到一级缓存看看A是否创建，如果返回为null表示没找到，就开始创建A，此时创建的是一个半成品的A（工厂对象），把A放入三级缓存，此时需要用到B进行依赖注入，又去一级缓存找有没有B，如果没有就开始创建B，此时创建的也是一个半成品的B，此时B又需要用到A，又去一级缓存找A发现没有，又去三级缓存找，找到了A，并完成依赖注入（这时注入的并不是代理对象），初始化B并创建B的代理，把B的代理放入singletonObjects，然后清除singletonFactories内的半成品B。这是A就可以拿到B的代理，完成初始化。把A放到一级缓存，并清除三级缓存的A。可以看到，B注入的并不是代理，所有只有两个缓存是不可以解决Spring关于的代理对象的依赖注入。\n总的来说是因为存在循环依赖时，是依赖注入先发生，创建代理后发生\n\n引入Spring二级缓存earlySingletonObjects\n解决方法：提前创建代理\nSpring并不是对所有Bean的创建都提前创建代理，只有存在循环依赖时才提前创建代理\n\n解决Construct循环依赖注入A的构造依赖B，所有A无法创建工厂对象放入三级缓存，B的构造也依赖A，B也无法创建工厂对象放入缓存\n\nSpring的三级缓存无法解决构造器依赖注入。\n如何解决构造器的循环依赖呢？\n方法一\n可以给A注入一个B的代理对象（并不是真的B代理对象，而是创建了一个匿名内部类的TargetSource实现，当真正使用到B的方法时，会通过BeanFactory获取B，再调用），只要不妨碍A的创建以及初始化就行，当A成功创建之后，B也能成功创建，这时A想要用B的方法，只需要通过代理找到真正的B调用方法\n\n方法二\n可以给A注入一个工厂对象，只要不妨碍A的创建以及初始化就行，当A成功创建之后，B也能成功创建，这时A想要用B的方法，只需要通过工厂对象获取B，再调用方法\n\n以上两种都是通过延迟对象的创建来解析构造器循环依赖\n那么它们的延迟创建在Spring中如何体现呢？使用@Lazy\n在Spring中，可以在构造器循环依赖的其中一个对象的构造的参数上添加@Lazy来延迟对象的创建\n下面是一个在构造器循环依赖情况下使用 @Lazy 注解的示例代码：\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.AnnotationConfigUtils;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.context.support.GenericApplicationContext;\n\nimport javax.annotation.PostConstruct;\n\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private B b;;\n        public A(@Lazy B b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getClass());\n        System.out.println(context.getBean(B.class).getClass());\n\n\n    &#125;\n&#125;\n\n运行结果:[DEBUG] 23:49:27.836 [main] - A内的b>>>>class day04.boot.TestConstructDelayCreate$B$$EnhancerBySpringCGLIB$$f09826e3 \n[DEBUG] 23:49:27.842 [main] - init() \n[DEBUG] 23:49:27.845 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 23:49:27.845 [main] - init() \nclass day04.boot.TestConstructDelayCreate$B$$EnhancerBySpringCGLIB$$f09826e3\nclass day04.boot.TestConstructDelayCreate$B\n\n跟踪@Lazy\nObject result = this.getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);\n检查是否有@Lazy注解，是否需要创建代理\n\nreturn this.isLazy(descriptor) ? this.buildLazyResolutionProxy(descriptor, beanName) : null;\n是否需要创建代理\n\n看看创建代理的逻辑  buildLazyResolutionProxy\n创建了一个匿名内部类的TargetSource实现\n\n看看TargetSource的实现\n当调用getTarget()时，会通过BeanFactory获取B，再调用\n\n在上述代码中，可以给A注入一个B的代理对象，并不是真的B代理对象，而是创建了一个匿名内部类的TargetSource实现，内部关联了BeanFactory，当调用getTarget()时，会通过BeanFactory获取B，再调用。\n替换成ObjectFactory工厂对象\n下面是ObjectFactory示例代码：\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private ObjectFactory&lt;B> b;;\n        public A(ObjectFactory&lt;B> b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getObject());\n        System.out.println(context.getBean(B.class));\n    &#125;\n&#125;\n\n运行结果：\n[DEBUG] 16:33:27.224 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider \n[DEBUG] 16:33:27.230 [main] - init() \n[DEBUG] 16:33:27.233 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:33:27.234 [main] - init() \nday04.boot.TestConstructDelayCreate$B@7bd4937b\nday04.boot.TestConstructDelayCreate$B@7bd4937b\n\n优点：不会产生代理，减少内存开销\n替换成ObjectProvider对象（ObjectFactory的子类）\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;A&quot;);\n        private ObjectProvider&lt;B&gt; b;;\n        public A(ObjectProvider&lt;B&gt; b) &#123;\n            log.debug(&quot;A内的b&gt;&gt;&gt;&gt;&#123;&#125;&quot;, b.getClass());\n            this.b &#x3D; b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(&quot;init()&quot;);&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;B&quot;);\n        private A a;\n        public B(A a) &#123;\n            log.debug(&quot;B内的a&gt;&gt;&gt;&gt;&#123;&#125;&quot;, a.getClass());\n            this.a &#x3D; a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(&quot;init()&quot;);&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context &#x3D; new GenericApplicationContext();\n        context.registerBean(&quot;a&quot;,A.class);\n        context.registerBean(&quot;b&quot;,B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.getObject());\n        System.out.println(context.getBean(B.class));\n    &#125;\n&#125;\n\n运行结果\n[DEBUG] 16:36:43.644 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider \n[DEBUG] 16:36:43.649 [main] - init() \n[DEBUG] 16:36:43.652 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:36:43.653 [main] - init() \nday04.boot.TestConstructDelayCreate$B@21e360a\nday04.boot.TestConstructDelayCreate$B@21e360a\n\nObjectProvider、ObjectFactory都是Spring提供的工厂接口\nProvider：Java官方提供的一套工厂接口\n&lt;dependency>\n          &lt;groupId>javax.inject&lt;/groupId>\n          &lt;artifactId>javax.inject&lt;/artifactId>\n          &lt;version>1&lt;/version>\n      &lt;/dependency>\n\npublic class TestConstructDelayCreate &#123;\n    static class A &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"A\");\n        private Provider&lt;B> b;;\n        public A(Provider&lt;B> b) &#123;\n            log.debug(\"A内的b>>>>&#123;&#125;\", b.getClass());\n            this.b = b;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n    static class B &#123;\n        private static final Logger log = LoggerFactory.getLogger(\"B\");\n        private A a;\n        public B(A a) &#123;\n            log.debug(\"B内的a>>>>&#123;&#125;\", a.getClass());\n            this.a = a;\n        &#125;\n        @PostConstruct\n        public void init() &#123;log.debug(\"init()\");&#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"a\",A.class);\n        context.registerBean(\"b\",B.class);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.refresh();\n\n        System.out.println(context.getBean(A.class).b.get());\n        System.out.println(context.getBean(B.class));\n\n    &#125;\n&#125;\n\n运行结果：\n[DEBUG] 16:45:43.783 [main] - A内的b>>>>class org.springframework.beans.factory.support.DefaultListableBeanFactory$Jsr330Factory$Jsr330Provider \n[DEBUG] 16:45:43.788 [main] - init() \n[DEBUG] 16:45:43.792 [main] - B内的a>>>>class day04.boot.TestConstructDelayCreate$A \n[DEBUG] 16:45:43.792 [main] - init() \nday04.boot.TestConstructDelayCreate$B@43dac38f\nday04.boot.TestConstructDelayCreate$B@43dac38f\n\n分析：\npublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set&lt;String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException &#123;\n       descriptor.initParameterNameDiscovery(this.getParameterNameDiscoverer());\n       if (Optional.class == descriptor.getDependencyType()) &#123;\n           return this.createOptionalDependency(descriptor, requestingBeanName);\n       &#125; else if (ObjectFactory.class != descriptor.getDependencyType() &amp;&amp; ObjectProvider.class != descriptor.getDependencyType()) &#123;\n           \n           //创建Provider\n           if (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;\n               return (new DefaultListableBeanFactory.Jsr330Factory()).createDependencyProvider(descriptor, requestingBeanName);\n               \n               \n           &#125;\n\n//跟入 createDependencyProvider方法 是Jsr330Factory工厂的方法\nprivate class Jsr330Factory implements Serializable &#123;\n        private Jsr330Factory() &#123;\n        &#125;\n\n        public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) &#123;\n            return new DefaultListableBeanFactory.Jsr330Factory.Jsr330Provider(descriptor, beanName);\n        &#125;\n\n        private class Jsr330Provider extends DefaultListableBeanFactory.DependencyObjectProvider implements Provider&lt;Object> &#123;\n            public Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) &#123;\n                super(descriptor, beanName);\n            &#125;\n\n            @Nullable\n            public Object get() throws BeansException &#123;\n                return this.getValue();\n            &#125;\n        &#125;\n    &#125;\n\n//看看get方法的getvalue()的实现   \n@Nullable\n        protected Object getValue() throws BeansException &#123;\n            return this.optional ? DefaultListableBeanFactory.this.createOptionalDependency(this.descriptor, this.beanName) : DefaultListableBeanFactory.this.doResolveDependency(this.descriptor, this.beanName, (Set)null, (TypeConverter)null);\n        &#125;\n\n当b.get()被调用时，会进入DefaultListableBeanFactory.this.doResolveDependency(this.descriptor,  this.beanName, (Set)null, (TypeConverter)null)；使用已经创建好的Bean\n使用Scope注解，也会创建代理解决构造器循环依赖 \n在类上添加@Scope(ProxyMode &#x3D; ScopedProxyMode.TARGET.CLASS)\n不推荐使用，因为会产生额外的beanDefination，也会产生额外的单例bean\n","slug":"Spring如何解决循环依赖","date":"2023-05-11T13:26:38.000Z","categories_index":"","tags_index":"Java,Spring,面试题","author_index":"大宝贝的程序员"},{"id":"a685b627e4865e5f328e43bd436e0d9e","title":"代理的创建时机","content":"代理的创建时机代理的创建时机\n创建 -&gt; ( * ) 依赖注入 -&gt; 初始化 ( * )\n\n初始化之后 (无循环依赖时)\n\n实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\n\n\npublic class A17_1 &#123;\n\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(Config.class);\n        context.refresh();\n        context.close();\n        // 创建 -> (*) 依赖注入 -> 初始化 (*)\n        /*\n            学到了什么\n                a. 代理的创建时机\n                    1. 初始化之后 (无循环依赖时)\n                    2. 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\n                b. 依赖注入与初始化不应该被增强, 仍应被施加于原始对象\n         */\n    &#125;\n\n    @Configuration\n    static class Config &#123;\n        @Bean // 解析 @Aspect、产生代理\n        public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() &#123;\n            return new AnnotationAwareAspectJAutoProxyCreator();\n        &#125;\n\n        @Bean // 解析 @Autowired\n        public AutowiredAnnotationBeanPostProcessor autowiredAnnotationBeanPostProcessor() &#123;\n            return new AutowiredAnnotationBeanPostProcessor();\n        &#125;\n\n        @Bean // 解析 @PostConstruct\n        public CommonAnnotationBeanPostProcessor commonAnnotationBeanPostProcessor() &#123;\n            return new CommonAnnotationBeanPostProcessor();\n        &#125;\n\n        @Bean\n        public Advisor advisor(MethodInterceptor advice) &#123;\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            return new DefaultPointcutAdvisor(pointcut, advice);\n        &#125;\n\n        @Bean\n        public MethodInterceptor advice() &#123;\n            return (MethodInvocation invocation) -> &#123;\n                System.out.println(\"before...\");\n                return invocation.proceed();\n            &#125;;\n        &#125;\n\n        @Bean\n        public Bean1 bean1() &#123;\n            return new Bean1();\n        &#125;\n\n        @Bean\n        public Bean2 bean2() &#123;\n            return new Bean2();\n        &#125;\n    &#125;\n\n    static class Bean1 &#123;\n        public void foo() &#123;\n\n        &#125;\n        public Bean1() &#123;\n            System.out.println(\"Bean1()\");\n        &#125;\n        /*\n        @Autowired \n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"Bean1 setBean2(bean2) class is: \" + bean2.getClass());\n        &#125;*/\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean1 init()\");\n        &#125;\n    &#125;\n\n    static class Bean2 &#123;\n        public Bean2() &#123;\n            System.out.println(\"Bean2()\");\n        &#125;\n        @Autowired \n        public void setBean1(Bean1 bean1) &#123;\n            System.out.println(\"Bean2 setBean1(bean1) class is: \" + bean1.getClass());\n        &#125;\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean2 init()\");\n        &#125;\n    &#125;\n&#125;\n\n以上例子是一个单向的依赖，Bean2的创建依赖Bean1。代理的创建时机为类的初始化之后\n输出结果&gt;&gt;&gt;&gt;创建Bean1\nBean1()\n&gt;&gt;&gt;&gt;完成初始化\nBean1 init()\n&gt;&gt;&gt;&gt;为bean1创建代理\n[TRACE] 21:09:48.069 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean &#39;bean1&#39; with 0 common interceptors and 2 specific interceptors \n&gt;&gt;&gt;&gt;创建Bean2\nBean2()\n&gt;&gt;&gt;&gt;完成Bean1属性的的依赖注入，注入的是代理\nBean2 setBean1(bean1) class is: class \norg.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$2c2cbac1\n&gt;&gt;&gt;&gt;完成初始化\nBean2 init()\n\n修改Bean1的代码，让Bean1，Bean2存在循环依赖\nstatic class Bean1 &#123;\n        public void foo() &#123;\n\n        &#125;\n        public Bean1() &#123;\n            System.out.println(\"Bean1()\");\n        &#125;\n        @Autowired \n        public void setBean2(Bean2 bean2) &#123;\n            System.out.println(\"Bean1 setBean2(bean2) class is: \" + bean2.getClass());\n        &#125;\n        @PostConstruct \n        public void init() &#123;\n            System.out.println(\"Bean1 init()\");\n        &#125;\n    &#125;\n\n运行结果如下：>>>创建Bean1，Spring的放入三级缓存，发现需要依赖Bean2，查找缓存没有Bean2，就创建Bean2\nBean1()\n>>>创建Bean2，Spring的放入三级缓存,需要Bean1，查找缓存有Bean1\nBean2()\n>>>创建Bean1的代理\n[TRACE] 21:16:39.601 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean 'bean1' with 0 common interceptors and 2 specific interceptors \n>>>>注入代理对象\nBean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$c459ff85\n>>>>完成初始化\nBean2 init()\n>>>>注入Bean2的代理\nBean1 setBean2(bean2) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean2\n>>>>完成初始化\nBean1 init()\n\n循环依赖时，代理的创建时机被提前到依赖注入之前\n依赖注入（set方法）与初始化（初始化方法）不应该被增强, 仍用原始对象的set和初始化方法\n\n\n","slug":"代理的创建时机","date":"2023-05-11T12:55:58.000Z","categories_index":"","tags_index":"Java,Spring,Proxy","author_index":"大宝贝的程序员"},{"id":"a95318a81b0b3097ed11bab255c7390f","title":"从@Aspect到Advisor","content":"@Aspect—&gt;&gt;AdvisorAnnotationAwareAspectJAutoProxyCreator\nAnnotationAwareAspectJAutoProxyCreator的作用是将高级切面转换成低级切面，使其能够被Spring框架所识别和使用。具体来说，它会读取应用中所有的@Aspect注解，并将这些注解解析成切面的定义。然后，它会对切面定义进行解析，并通过AspectJ编译器将切面转换成可执行的代码块和增强器，并将其绑定到目标对象的代理上。\nfindEligibleAdvisors \n从容器中获取所有的Advisor列表，然后通过匹配切点和目标对象，筛选出适用于该目标对象的Advisor列表。具体包括以下步骤：\n\n获取Spring容器中的所有Advisor。Spring容器中的Advisor代表着切面中定义的增强器，它们用于在目标对象的方法执行前后进行拦截并执行相应的增强逻辑。在这一步中，findEligibleAdvisors方法会从容器中获取所有Advisor对象列表。\n筛选使用AspectJ注解标注的Aspect对象。在这一步中，findEligibleAdvisors方法会遍历所有的Advisor对象，并检查是否是由使用AspectJ注解标注的Aspect对象创建的。如果是，则表示该Advisor属于切面定义的增强逻辑，需要参与目标对象的代理。\n\nwrapIfNecessary\n这个方法的作用是检查目标对象是否需要进行代理，如果需要，则创建代理对象。而目标对象是否需要进行代理，则取决于以下几个因素：\n\n是否启用代理。即是否使用&lt;aop:aspectj-autoproxy&gt;标签启用了自动代理的功能，或者在Java配置中使用@EnableAspectJAutoProxy注解启用了自动代理的功能。\n是否满足代理条件。在Spring框架中，只有当目标对象的类型是非final类或者实现了一个或多个接口时，才能够创建代理对象。否则，Spring框架无法通过动态代理实现对目标对象的增强。\n是否存在增强器。在这个步骤中，Spring框架会调用findAdvisorsThatCanApply方法，查找适合目标对象的增强器列表。如果找到了适合目标对象的增强器，则表示需要为该对象创建代理。\n\n如果目标对象需要创建代理，wrapIfNecessary方法就会根据目标对象的类型，采用不同的代理方式来创建代理对象。如果目标对象实现了一个或多个接口，则使用JDK动态代理的方式进行代理；否则，使用CGLIB代理的方式进行代理。\npackage org.springframework.aop.framework.autoproxy;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.aop.Advisor;\n\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationClassPostProcessor;\nimport org.springframework.context.support.GenericApplicationContext;\nimport org.springframework.core.annotation.Order;\n\nimport java.util.List;\n\npublic class TestAspect &#123;\n    public static void main(String[] args) &#123;\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"aspect1\", Aspect1.class);\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        context.refresh();\n//        for (String name : context.getBeanDefinitionNames()) &#123;\n//            System.out.println(name);\n//        &#125;\n\n        /*\n            第一个重要方法 findEligibleAdvisors 找到有【资格】的 Advisors\n                a. 有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如下例中的 advisor3\n                b. 有【资格】的 Advisor 另一部分是高级的, 解析 @Aspect 后获得\n         */\n        AnnotationAwareAspectJAutoProxyCreator creator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        List&lt;Advisor> advisors = creator.findEligibleAdvisors(Target1.class, \"target1\");\n        for (Advisor advisor : advisors) &#123;\n            System.out.println(advisor);\n        &#125;\n\n        /*\n            第二个重要方法 wrapIfNecessary\n                a. 它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理\n         */\n        Object o1 = creator.wrapIfNecessary(new Target1(), \"target1\", \"target1\");\n        System.out.println(o1.getClass());\n        Object o2 = creator.wrapIfNecessary(new Target2(), \"target2\", \"target2\");\n        System.out.println(o2.getClass());\n\n        ((Target1) o1).foo();\n        /*\n            学到了什么\n                a. 自动代理后处理器 AnnotationAwareAspectJAutoProxyCreator 会帮我们创建代理\n                b. 通常代理创建的活在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行\n                c. 高级的 @Aspect 切面会转换为低级的 Advisor 切面, 理解原理, 大道至简\n         */\n    &#125;\n\n    static class Target1 &#123;\n        public void foo() &#123;\n            System.out.println(\"target1 foo\");\n        &#125;\n    &#125;\n\n    static class Target2 &#123;\n        public void bar() &#123;\n            System.out.println(\"target2 bar\");\n        &#125;\n    &#125;\n\n    @Aspect // 高级切面类\n//    @Order(1)\n    static class Aspect1 &#123;\n        @Before(\"execution(* foo())\")\n        public void before1() &#123;\n            System.out.println(\"aspect1 before1...\");\n        &#125;\n\n        @Before(\"execution(* foo())\")\n        public void before2() &#123;\n            System.out.println(\"aspect1 before2...\");\n        &#125;\n    &#125;\n\n    @Configuration\n    static class Config &#123;\n        @Bean // 低级切面\n        public Advisor advisor3(MethodInterceptor advice3) &#123;\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3);\n            return advisor;\n        &#125;\n        @Bean\n        public MethodInterceptor advice3() &#123;\n            return invocation -> &#123;\n                System.out.println(\"advice3 before...\");\n                Object result = invocation.proceed();\n                System.out.println(\"advice3 after...\");\n                return result;\n            &#125;;\n        &#125;\n    &#125;\n\n&#125;\n\n\n输出结果org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR\n>>>>>>>>>>>>>>>>>>>>>>>>>>>低级切面\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda$117/0x0000000800d64950@d41f816]\n>>>>>>>>>>>>>>>>>>>>>>>>>>>被解析成低级切面的高级切面\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before1()]; perClauseKind=SINGLETON\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before2()]; perClauseKind=SINGLETON\n>>>>>>>>>>>>>>>>>>>>>>>>Target1匹配切面，会创建代理\nclass org.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$$7efd35eb\n>>>>>>>>>>>>>>>>>>>>>>>>Target2不匹配切面，不会创建代理\nclass org.springframework.aop.framework.autoproxy.A17$Target2\nadvice3 before...\naspect1 before1...\naspect1 before2...\ntarget1 foo\nadvice3 after...\n\n  \n\n","slug":"从@Aspect到Advisor","date":"2023-05-11T12:04:08.000Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"},{"id":"d3cf2f31cfa6170a433ba0c99bf2326a","title":"切点匹配规则","content":"切点匹配规则AspectJ使用切点指示器（Pointcut Designator）来描述需要匹配的切点，切点指示器定义了切点的名称、参数、返回类型、标注等信息。切点指示器可以根据需要使用通配符、逻辑运算符、正则表达式等方式来描述切点。\nAspectJ中的切点指示符主要分为以下几种：\n\nexecution：匹配方法执行的连接点，以方法的访问修饰符、返回类型、类名、方法名和参数决定。\nwithin：匹配指定类型内的方法执行。\nthis：匹配当前AOP代理对象类型的执行方法。\ntarget：匹配当前目标对象类型的执行方法。\nargs：匹配当前执行的方法传入参数为指定类型的执行方法。\nannotation：匹配当前执行方法持有指定注解的方法执行。\nbean：匹配指定名称的bean中的方法执行。\ncflow：匹配满足条件的方法的任何调用。\nif：用于组合其他切点指示器。\n\n使用切点指示器可以非常方便的定义Spring中的切点表达式，如：@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)\npublic void servicePointcut() &#123;&#125;\n\n@Pointcut(&quot;execution(* com.example.dao.*.*(..))&quot;)\npublic void daoPointcut() &#123;&#125;\n\n@Pointcut(&quot;within(com.example.*)&quot;)\npublic void withinPointcut() &#123;&#125;\n\n@Pointcut(&quot;@annotation(com.example.annotation.Loggable)&quot;)\npublic void annotationPointcut() &#123;&#125;\n\n上面的代码定义了四个切点表达式，分别对应于拦截service包、dao包、com.example包下的所有方法和所有标有@Loggable注解的方法的拦截。在实际使用时，可以将这些切点表达式和Advice组合成Advisor，通过使用AOP来实现对目标方法的拦截。\naspectj 切点的局限性\n实际的 @Transactional 切点实现，无法匹配实现了接口添加了@Transactional注解的类的方法\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.support.StaticMethodMatcherPointcut;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.lang.reflect.Method;\n\npublic class A16 &#123;\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n//        AspectJExpressionPointcut无法处理加载类上的信息\n//        检查是否匹配成功  execution\n        AspectJExpressionPointcut pt1 = new AspectJExpressionPointcut();\n        pt1.setExpression(\"execution(* bar())\");\n        System.out.println(pt1.matches(T1.class.getMethod(\"foo\"), T1.class));//false\n        System.out.println(pt1.matches(T1.class.getMethod(\"bar\"), T1.class));//true\n//        根据方法注解进行匹配  @annotation表达式\n        AspectJExpressionPointcut pt2 = new AspectJExpressionPointcut();\n        pt2.setExpression(\"@annotation(org.springframework.transaction.annotation.Transactional)\");\n        System.out.println(pt2.matches(T1.class.getMethod(\"foo\"), T1.class));//true\n        System.out.println(pt2.matches(T1.class.getMethod(\"bar\"), T3.class));//false\n       \n    &#125;\n    static class T1 &#123;\n        @Transactional\n        public void foo() &#123;\n        &#125;\n        public void bar() &#123;\n        &#125;\n    &#125;\n\n    @Transactional\n    static class T2 &#123;\n        public void foo() &#123;\n        &#125;\n    &#125;\n\n    @Transactional\n    interface I3 &#123;\n        void foo();\n    &#125;\n    static class T3 implements I3 &#123;\n        public void foo() &#123;\n        &#125;\n    &#125;\n&#125;\n\nSpring如何解决\nStaticMethodMatcherPointcut是Spring框架中用于匹配静态方法的切点对象。在AOP编程中，切点用于定义在哪些方法执行时会被拦截并执行增强逻辑。StaticMethodMatcherPointcut基于指定的规则匹配静态方法并确定在这些方法执行时是否要进行拦截。\nStaticMethodMatcherPointcut的匹配规则根据传入的Class和方法Method对象进行判断，只有当方法符合预定义的规则时，切点才会拦截方法执行，否则会被忽略。通常，可以通过实现matches方法来自定义匹配规则，只拦截符合条件的目标方法。\n//        StaticMethodMatcherPointcut抽象类可以处理类上的信息，实现match方法\n        StaticMethodMatcherPointcut pt3 = new StaticMethodMatcherPointcut() &#123;\n            @Override               //方法                    类\n            public boolean matches(Method method, Class&lt;?> targetClass) &#123;\n                // 读取方法信息，检查方法上是否加了 Transactional 注解\n                MergedAnnotations annotations = MergedAnnotations.from(method);\n                if (annotations.isPresent(Transactional.class)) &#123;\n                    return true;\n                &#125;\n    \t\t\t// 读取方法信息类信息，查看类上是否加了 Transactional 注解\n                //默认只查看本类删是否含有相应信息，修改成SearchStrategy.TYPE_HIERARCHY\n                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n                if (annotations.isPresent(Transactional.class)) &#123;\n                    return true;\n                &#125;\n                return false;\n            &#125;\n        &#125;;\n\n        System.out.println(pt3.matches(T1.class.getMethod(\"foo\"), T1.class));//true\n        System.out.println(pt3.matches(T1.class.getMethod(\"bar\"), T1.class));//false\n        System.out.println(pt3.matches(T2.class.getMethod(\"foo\"), T2.class));//true\n        System.out.println(pt3.matches(T3.class.getMethod(\"foo\"), T3.class));//true\n\n\n\n\n底层切点实现是如何匹配的: 调用了 aspectj 的匹配方法\n\n比较关键的是它实现了 MethodMatcher 接口, 用来执行方法的匹配\n\n\n","slug":"切点匹配规则","date":"2023-05-11T09:35:15.000Z","categories_index":"","tags_index":"Java,Spring","author_index":"大宝贝的程序员"},{"id":"42403d33a4a316854760bf766fee144b","title":"JDK和CGlib在Spring中的统一","content":"JDK和CGlib在Spring中的统一Spring 中对切点、通知、切面的抽象如下\n\n切点：接口 Pointcut，典型实现 AspectJExpressionPointcut\n通知：典型接口为 MethodInterceptor 代表环绕通知\n切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut\n\nclassDiagram\n\nclass Advice\nclass MethodInterceptor\nclass Advisor\nclass PointcutAdvisor\n\nPointcut &lt;|-- AspectJExpressionPointcut\nAdvice &lt;|-- MethodInterceptor\nAdvisor &lt;|-- PointcutAdvisor\nPointcutAdvisor o-- \"一\" Pointcut\nPointcutAdvisor o-- \"一\" Advice\n\n&lt;&lt;interface>> Advice\n&lt;&lt;interface>> MethodInterceptor\n&lt;&lt;interface>> Pointcut\n&lt;&lt;interface>> Advisor\n&lt;&lt;interface>> PointcutAdvisor\n\n代理相关类图\n\nAopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现\nAopProxy 通过 getProxy 创建代理对象\n图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）\n调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor\n\nclassDiagram\n\nAdvised &lt;|-- ProxyFactory\nProxyFactory o-- Target\nProxyFactory o-- \"多\" Advisor\n\nProxyFactory --> AopProxyFactory : 使用\nAopProxyFactory --> AopProxy\nAdvised &lt;|-- 基于CGLIB的Proxy\n基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建\nAopProxy &lt;|-- ObjenesisCglibAopProxy\nAopProxy &lt;|-- JdkDynamicAopProxy\n基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建\nAdvised &lt;|-- 基于JDK的Proxy\n\nclass AopProxy &#123;\n   +getProxy() Object\n&#125;\n\nclass ProxyFactory &#123;\n\tproxyTargetClass : boolean\n&#125;\n\nclass ObjenesisCglibAopProxy &#123;\n\tadvised : ProxyFactory\n&#125;\n\nclass JdkDynamicAopProxy &#123;\n\tadvised : ProxyFactory\n&#125;\n\n&lt;&lt;interface>> Advised\n&lt;&lt;interface>> AopProxyFactory\n&lt;&lt;interface>> AopProxy\n\n\n\n在 Spring 中，JDK动态代理和CGLIB动态代理会被自动地统一使用。Spring框架会自动选择合适的代理方式，以确保代理对象的正确性和高效性。\n如果我们希望代理的对象实现了接口，那么我们可以选择使用 JDK 动态代理。相比 CGLIB 动态代理，JDK 动态代理的代理对象更加轻量级，因为直接实现了目标对象的接口。\n如果我们希望代理对象没有实现接口，那么我们只能使用 CGLIB 动态代理。CGLIB 动态代理会在运行时生成代理对象的子类，并重写目标对象的方法。所以 CGLIB 动态代理的代理对象比 JDK 动态代理的代理对象更加强大和灵活，但同时也更加重量级。\n总之，在使用 Spring 框架中的 AOP 时，我们只需要关注代理对象是否实现了接口，Spring 会根据情况自动选择使用 JDK 动态代理还是 CGLIB 动态代理。如果我们希望选择特定的代理方式，可以通过在 Spring 配置文件中进行配置来实现。\n模拟Spring创建代理的使用jdk或者cglib&#x2F;&#x2F;要注意导包：MethodInterceptor是与 cglib的 MethodInterceptor 同名的\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\n\npublic class TestSpringAop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;*\n            两个切面概念\n            aspect &#x3D;\n                通知1(advice) +  切点1(pointcut)\n                通知2(advice) +  切点2(pointcut)\n                通知3(advice) +  切点3(pointcut)\n                ...\n            advisor &#x3D; 更细粒度的切面，包含一个通知和切点\n         *&#x2F;\n\n        &#x2F;&#x2F; 1. 准备好切点\n        AspectJExpressionPointcut pointcut &#x3D; new AspectJExpressionPointcut();\n        pointcut.setExpression(&quot;execution(* foo())&quot;);\n        &#x2F;&#x2F; 2. 准备好通知  MethodInterceptor与cglib的MethodInterceptor不一样\n        &#x2F;&#x2F;本质上是环绕通知\n        MethodInterceptor advice &#x3D; new MethodInterceptor() &#123;\n            @Override\n            public Object invoke(MethodInvocation invocation) throws Throwable &#123;\n                System.out.println(&quot;before...&quot;);\n                Object result &#x3D; invocation.proceed(); &#x2F;&#x2F; 调用目标\n                System.out.println(&quot;after...&quot;);\n                return result;\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 3. 备好切面\n        DefaultPointcutAdvisor advisor &#x3D; new DefaultPointcutAdvisor(pointcut, advice);\n        &#x2F;&#x2F; 4. 创建代理\n        Target2 target &#x3D; new Target2();\n        ProxyFactory factory &#x3D; new ProxyFactory();\n        factory.setTarget(target);\n        factory.addAdvisor(advisor);\n        &#x2F;&#x2F;获取接口类型 factory无法判断是否实现了接口，需要手动设置\n        factory.setInterfaces(target.getClass().getInterfaces());\n        factory.setProxyTargetClass(false);\n        Target2 proxy &#x3D; (Target2) factory.getProxy();\n        &#x2F;&#x2F;cglib代理\n        System.out.println(proxy.getClass());\n        proxy.foo();\n        proxy.bar();\n        &#x2F;*\n            学到了什么\n                a. Spring 的代理选择规则\n                b. 底层的切点实现\n                c. 底层的通知实现\n                d. ProxyFactory 是用来创建代理的核心实现, 用 AopProxyFactory 选择具体代理实现\n                    - JdkDynamicAopProxy\n                    - ObjenesisCglibAopProxy\n         *&#x2F;\n    &#125;\n\n    interface I1 &#123;\n        void foo();\n\n        void bar();\n    &#125;\n\n    static class Target1 implements I1 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target1 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target1 bar&quot;);\n        &#125;\n    &#125;\n\n    static class Target2 &#123;\n        public void foo() &#123;\n            System.out.println(&quot;target2 foo&quot;);\n        &#125;\n\n        public void bar() &#123;\n            System.out.println(&quot;target2 bar&quot;);\n        &#125;\n    &#125;\n&#125;\n\nSpring 的代理选择规：\n\nproxyTargetClass &#x3D; false, 目标实现了接口, 用 jdk 实现\nproxyTargetClass &#x3D; false,  目标没有实现接口, 用 cglib 实现\nproxyTargetClass &#x3D; true, 总是使用 cglib 实现\n\n","slug":"JDK和CGlib在Spring中的统一","date":"2023-05-11T05:01:11.000Z","categories_index":"","tags_index":"Java,Spring,Proxy","author_index":"大宝贝的程序员"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"title: AOP实现之proxydate: 2023-05-10 16:38:34tags:\n\nAOP\nSpring\nJava\n\nAOP实现之proxyjdk动态代理\n动态代理是通过反射机制实现的，可以动态地生成代理类和代理对象，在运行时将需要增强的代码织入到目标对象的方法中。\n实现动态代理，需要用到以下类和接口：\n\njava.lang.reflect.Proxy：提供了用于创建动态代理的方法newProxyInstance()。\njava.lang.reflect.InvocationHandler：定义了代理对象的调用处理器，负责实现代理对象调用的逻辑以及需要增强的代码。\n\n代理对象调用的流程如下：\n\n当代理对象的方法被调用时，会被转发到InvocationHandler的invoke()方法。\n在invoke()方法中，根据调用的方法名和参数，判断需要执行什么样的业务逻辑。\n如果需要增强方法，将增强逻辑插入到调用方法前或后执行，否则直接调用目标对象的方法。\n\n优点\n使用jdk动态代理的好处是可以避免手动编写代理类，提高代码的复用度。同时，由于jdk动态代理是运行时动态生成代理对象，因此不需要针对每个被代理的类手动创建代理类，提高了开发效率。\n缺点\n\n代理对象必须实现接口：由于jdk动态代理是基于接口进行代理的，因此只能够为接口类型的类创建代理对象。如果需要对非接口类型的类进行代理，可以使用CGLib库。\n\n补充说明\nJDK 只能针对接口代理，代理对象和目标对象之间是平级兄弟关系，也就是说代理对象并不是目标对象的子类，而是实现了相同接口的新类型。因此，在理论上，代理对象和目标对象的类型可以是相同的，甚至目标对象可以被 final 修饰。\n示例import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\ninterface Hello &#123;\n    void sayHello();\n&#125;\n\nclass HelloImpl implements Hello &#123;\n    public void sayHello() &#123;\n        System.out.println(\"Hello world!\");\n    &#125;\n&#125;\n\nclass MyInvocationHandler implements InvocationHandler &#123;\n    private Object target;// 目标对象\n\n    public MyInvocationHandler(Object target) &#123;\n        this.target = target;\n    &#125;\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(\"Before Method Invoke\");\n        // 方法.invoke(目标, 参数);\n        Object result = method.invoke(target, args);\n        System.out.println(\"After Method Invoke\");\n        return result;\n    &#125;\n&#125;\n\npublic class ProxyTest &#123;\n    public static void main(String[] args) &#123;\n        HelloImpl hello = new HelloImpl();\n        MyInvocationHandler handler = new MyInvocationHandler(hello);\n        //参数（目标类的类加载器用于运行时动态生成字节码，接口类型，InvocationHandler的具体实现）\n        Hello proxyHello = Proxy.newProxyInstance(hello.getClass().getClassLoader(),\n                hello.getClass().getInterfaces(), handler);\n        proxyHello.sayHello();\n    &#125;\n&#125;\n\n\n\nCGlib代理CGlib是一个开源的Java字节码增强库，可以在运行时动态地生成一个目标类的子类，通过这个子类来实现对目标类的代理（代理的具体实现方式视情况而定）。与JDK动态代理相比，CGlib代理无需目标对象实现接口，能够代理目标对象的方法，包括private、protected修饰的方法。\nCGlib代理的实现中，需要使用到ASM库来生成代理类的字节码。具体而言，ASM是一个轻量级Java字节码操作和生成库，能够在运行时动态生成类的字节码，以达到动态修改类的目的。\n使用CGlib代理时，我们一般需要实现一个MethodInterceptor接口，用来对目标类的方法进行拦截和增强。\nCGLib实现代理的原理可以分为以下几个步骤：\n\n定义一个类，继承被代理类；\n在代理类中定义一个变量，用于持有被代理类的引用；\n在代理类中重写被代理类中的所有需要代理的方法；\n在重写的方法中加入额外的代理逻辑（例如记录方法调用的日志、进行权限验证等）。\n\nCGLib实现代理的步骤：\n\n设置CGLib的Enhancer对象的SuperClass和Callback属性，这样Enhancer就知道要代理哪个类以及代理的具体实现方式；\n使用Enhancer对象的create()方法来生成代理对象。\n\n通过实例了解一下cglib的工作大概流程\n示例1import net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\npublic class CGLibProxyDemo &#123;\n\n    public static void main(String[] args) &#123;\n        RealSubject realSubject = new RealSubject();\n        RealSubject proxy = (RealSubject) Enhancer.create(RealSubject.class, new MyMethodInterceptor(realSubject));\n        proxy.request();\n    &#125;\n\n    static class RealSubject &#123;\n        public void request() &#123;\n            System.out.println(\"RealSubject.request()\");\n        &#125;\n    &#125;\n\t//实现一个MethodInterceptor接口\n    static class MyMethodInterceptor implements MethodInterceptor &#123;\n        private Object target;//目标\n\n        public MyMethodInterceptor(Object target) &#123;\n            this.target = target;\n        &#125;\n\n        @Override\n        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n            System.out.println(\"Before method: \" + method);\n            Object result = method.invoke(target, objects);\n            System.out.println(\"After method: \" + method);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n在这个例子中，MyMethodInterceptor类是实现了CGLib的MethodInterceptor接口，它的作用是在代理类的方法执行时进行拦截和增强。\n通过调用Enhancer.create()方法，我们得到了一个代理对象，它拥有RealSubject类的全部方法，但是在执行request方法时会经过CGLib生成的MyMethodInterceptor拦截器，我们可以在这个拦截器中进行自己的逻辑处理。\n示例2import org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\npublic class CglibProxyDemo &#123;\n\n    static class Target &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n    &#125;\n\n    // 代理是子类型, 目标是父类型\n    public static void main(String[] param) &#123;\n//        Target target = new Target();\n\n        Target proxy = (Target) Enhancer.create(Target.class, new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//  Object result = method.invoke(target, args); // 用方法反射调用目标\n// methodProxy 它可以避免反射调用\n//  Object result = methodProxy.invoke(target, args); // 内部没有用反射, 需要目标 （spring）\n    Object result = methodProxy.invokeSuper(p, args); // 内部没有用反射, 需要代理\n                System.out.println(\"after...\");\n                return result;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n\n    &#125;\n&#125;\n\n有三种调用方式：method.invoke(target, args)  用反射调用目标，性能较低，需要目标对象\n​\t\t\t\t\t\t\t\tmethodProxy.invoke(target, args) 内部没有使用反射，需要目标对象  spring使用的方式\n​\t\t\t\t\t\t\t\tmethodProxy.invokeSuper(p, args) 内部没有使用反射，不需要目标对象\n代理是子类型, 目标是父类型：\n\n当目标使用final修饰，无法代理会报错\n\n当代理方法使用final修饰，不会把错，方法无法得到增强\n\n\n模拟jdk动态代理源码示例public class Test &#123;\n    public static void main(String[] param) &#123;\n        // ⬇️1. 创建代理，这时传入 InvocationHandler\n        Foo proxy = new $Proxy0(new InvocationHandler() &#123;    \n            // ⬇️5. 进入 InvocationHandler\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;\n                // ⬇️6. 功能增强\n                System.out.println(\"before...\");\n                // ⬇️7. 反射调用目标方法\n                return method.invoke(new Target(), args);\n            &#125;\n        &#125;);\n        // ⬇️2. 调用代理方法\n        proxy.foo();\n        proxy.bar();\n    &#125;\n&#125;\n\npublic interface Foo &#123;\n        void foo();\n        int bar();\n    &#125;\n\n\nstatic class Target implements Foo &#123;\n        public void foo() &#123;\n            System.out.println(\"target foo\");\n        &#125;\n\n        public int bar() &#123;\n            System.out.println(\"target bar\");\n            return 100;\n        &#125;\n    &#125;\n\n\n// ⬇️这就是 jdk 代理类的源码, 秘密都在里面\npublic class $Proxy0 extends Proxy implements Foo &#123;\n\n    public $Proxy0(InvocationHandler h) &#123;\n        super(h);\n    &#125;\n    // ⬇️3. 进入代理方法\n    public void foo() &#123;\n        try &#123;\n            // ⬇️4. 回调 InvocationHandler\n            h.invoke(this, foo, new Object[0]);\n        &#125; catch (RuntimeException | Error e) &#123;\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public int bar() &#123;\n        //用try-catch处理，把catch到的异常抛出，让外界知道代理有没有执行错误\n        try &#123;\n            Object result = h.invoke(this, bar, new Object[0]);\n            return (int) result;\n        &#125; catch (RuntimeException | Error e) &#123;//运行异常直接抛出\n            throw e;\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);//检查异常要转换成运行异常再抛出\n        &#125;\n    &#125;\n\n    static Method foo;\n    static Method bar;\n    static &#123;\n        try &#123;\n            foo = A12.Foo.class.getMethod(\"foo\");\n            bar = A12.Foo.class.getMethod(\"bar\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n以上是模拟jdk动态代理对象的源码，通过接口回调将【增强逻辑】置于代理类之外\n但是在真实的场景中，代理对象是看不到的，是程序在运行期间通过asm技术动态生成代理对象的ASMfiled\n\n把ASMfiled导出成一个类（可以通过流读取字节数组，生成代理对象，查看里面的内容）\n\n在Java代理中，ASM框架通常是作为动态代理机制的底层实现，用来生成字节码并创建代理类。具体来说，使用ASM框架创建代理类的过程大致如下：\n\n定义一个ClassWriter对象作为ASM框架生成字节码的输出流；\n通过ClassWriter定义类名和父类名称等相关信息，创建类的定义；\n定义类的字段、构造函数和代理方法等元素，这些元素将会被编码成字节码；\n利用ASM的MethodVisitor类访问器生成方法的字节码实现。MethodVisitor是定义在ASM框架中的一个访问类，用于可以随时提供关于方法的信息；\n生成字节码并将其写入输出流；\n\n示例转载自黑马package com.itheima;\n\nimport org.springframework.asm.*;\n\npublic class $Proxy0Dump implements Opcodes &#123;\n\n    public static byte[] dump() throws Exception &#123;\n\n        ClassWriter cw = new ClassWriter(0);\n        FieldVisitor fv;\n        MethodVisitor mv;\n        AnnotationVisitor av0;\n\n        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"com/itheima/$Proxy0\", null, \"java/lang/reflect/Proxy\", new String[]&#123;\"com/itheima/Foo\"&#125;);\n\n        cw.visitSource(\"$Proxy0.java\", null);\n\n        &#123;\n            fv = cw.visitField(ACC_STATIC, \"foo\", \"Ljava/lang/reflect/Method;\", null, null);\n            fv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            mv.visitLabel(l0);\n            mv.visitLineNumber(11, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/Proxy\", \"&lt;init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", false);\n            Label l1 = new Label();\n            mv.visitLabel(l1);\n            mv.visitLineNumber(12, l1);\n            mv.visitInsn(RETURN);\n            Label l2 = new Label();\n            mv.visitLabel(l2);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l2, 0);\n            mv.visitLocalVariable(\"h\", \"Ljava/lang/reflect/InvocationHandler;\", null, l0, l2, 1);\n            mv.visitMaxs(2, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_PUBLIC, \"foo\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/Throwable\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(17, l0);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETFIELD, \"com/itheima/$Proxy0\", \"h\", \"Ljava/lang/reflect/InvocationHandler;\");\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitFieldInsn(GETSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitInsn(ACONST_NULL);\n            mv.visitMethodInsn(INVOKEINTERFACE, \"java/lang/reflect/InvocationHandler\", \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\", true);\n            mv.visitInsn(POP);\n            mv.visitLabel(l1);\n            mv.visitLineNumber(20, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(18, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/Throwable\"&#125;);\n            mv.visitVarInsn(ASTORE, 1);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(19, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/reflect/UndeclaredThrowableException\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 1);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/UndeclaredThrowableException\", \"&lt;init>\", \"(Ljava/lang/Throwable;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(21, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            Label l5 = new Label();\n            mv.visitLabel(l5);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/Throwable;\", null, l4, l3, 1);\n            mv.visitLocalVariable(\"this\", \"Lcom/itheima/$Proxy0;\", null, l0, l5, 0);\n            mv.visitMaxs(4, 2);\n            mv.visitEnd();\n        &#125;\n        &#123;\n            mv = cw.visitMethod(ACC_STATIC, \"&lt;clinit>\", \"()V\", null, null);\n            mv.visitCode();\n            Label l0 = new Label();\n            Label l1 = new Label();\n            Label l2 = new Label();\n            mv.visitTryCatchBlock(l0, l1, l2, \"java/lang/NoSuchMethodException\");\n            mv.visitLabel(l0);\n            mv.visitLineNumber(26, l0);\n            mv.visitLdcInsn(Type.getType(\"Lcom/itheima/Foo;\"));\n            mv.visitLdcInsn(\"foo\");\n            mv.visitInsn(ICONST_0);\n            mv.visitTypeInsn(ANEWARRAY, \"java/lang/Class\");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Class\", \"getMethod\", \"(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;\", false);\n            mv.visitFieldInsn(PUTSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            mv.visitLabel(l1);\n            mv.visitLineNumber(29, l1);\n            Label l3 = new Label();\n            mv.visitJumpInsn(GOTO, l3);\n            mv.visitLabel(l2);\n            mv.visitLineNumber(27, l2);\n            mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]&#123;\"java/lang/NoSuchMethodException\"&#125;);\n            mv.visitVarInsn(ASTORE, 0);\n            Label l4 = new Label();\n            mv.visitLabel(l4);\n            mv.visitLineNumber(28, l4);\n            mv.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n            mv.visitInsn(DUP);\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/NoSuchMethodException\", \"getMessage\", \"()Ljava/lang/String;\", false);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"&lt;init>\", \"(Ljava/lang/String;)V\", false);\n            mv.visitInsn(ATHROW);\n            mv.visitLabel(l3);\n            mv.visitLineNumber(30, l3);\n            mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n            mv.visitInsn(RETURN);\n            mv.visitLocalVariable(\"e\", \"Ljava/lang/NoSuchMethodException;\", null, l4, l3, 0);\n            mv.visitMaxs(3, 1);\n            mv.visitEnd();\n        &#125;\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    &#125;\n&#125;\n\n通过调用 代理类的$Proxy0Dump.dump()获取字节数组，用来的加载器加载字节数组\npublic class TestProxy &#123;\n    public static void main(String[] args) throws Exception &#123;\n        byte[] dump = $Proxy0Dump.dump();\n\n        /*FileOutputStream os = new FileOutputStream(\"$Proxy0.class\");\n        os.write(dump, 0, dump.length);\n        os.close();*/\n\n        ClassLoader loader = new ClassLoader() &#123;\n            @Override\n            protected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n                return super.defineClass(name, dump, 0, dump.length);\n            &#125;\n        &#125;;\n        Class&lt;?> proxyClass = loader.loadClass(\"com.itheima.$Proxy0\");\n\n        Constructor&lt;?> constructor = proxyClass.getConstructor(InvocationHandler.class);\n        Foo proxy = (Foo) constructor.newInstance(new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                System.out.println(\"before...\");\n                System.out.println(\"调用目标\");\n                return null;\n            &#125;\n        &#125;);\n\n        proxy.foo();\n    &#125;\n&#125;\n\n\njdk反射方法的优化import java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\npublic class TestMethodInvoke &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Method foo = TestMethodInvoke.class.getMethod(\"foo\", int.class);\n        for (int i = 1; i &lt;= 17; i++) &#123;\n            show(i, foo);\n            foo.invoke(null, i);\n        &#125;\n        System.in.read();\n    &#125;\n\n    // 方法反射调用时, 底层 MethodAccessor 的实现类\n    private static void show(int i, Method foo) throws Exception &#123;\n        Method getMethodAccessor = Method.class.getDeclaredMethod(\"getMethodAccessor\");\n        getMethodAccessor.setAccessible(true);\n        Object invoke = getMethodAccessor.invoke(foo);\n        if (invoke == null) &#123;\n            System.out.println(i + \":\" + null);\n            return;\n        &#125;\n        Field delegate = Class.forName(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\").getDeclaredField(\"delegate\");\n        delegate.setAccessible(true);\n        System.out.println(i + \":\" + delegate.get(invoke));\n    &#125;\n\n    public static void foo(int i) &#123;\n        System.out.println(i + \":\" + \"foo\");\n    &#125;\n&#125;\n\n\n\n前 16 次反射性能较低，是基于Java的MethodAccessor调用的\n\n第 17 次调用会生成代理类，优化为非反射调用\n\n\n模拟 CGlib代理和 jdk 动态代理原理查不多\n\n回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor\n\n调用目标时有所改进，见下面代码片段\n\nmethod.invoke 是反射调用，必须调用到足够次数才会进行优化\n\nmethodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）\n\nmethodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象\n\n\n\n\n//代理对象\npublic class Proxy extends Target &#123;\n    private MethodInterceptor methodInterceptor;\n\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) &#123;\n        this.methodInterceptor = methodInterceptor;\n    &#125;\n\n    static Method save0;\n    static Method save1;\n    static Method save2;\n    static MethodProxy save0Proxy;\n    static MethodProxy save1Proxy;\n    static MethodProxy save2Proxy;\n    static &#123;\n        try &#123;\n            save0 = Target.class.getMethod(\"save\");\n            save1 = Target.class.getMethod(\"save\", int.class);\n            save2 = Target.class.getMethod(\"save\", long.class);\n            save0Proxy = MethodProxy.create(Target.class, Proxy.class, \"()V\", \"save\", \"saveSuper\");\n            save1Proxy = MethodProxy.create(Target.class, Proxy.class, \"(I)V\", \"save\", \"saveSuper\");\n            save2Proxy = MethodProxy.create(Target.class, Proxy.class, \"(J)V\", \"save\", \"saveSuper\");\n        &#125; catch (NoSuchMethodException e) &#123;\n            throw new NoSuchMethodError(e.getMessage());\n        &#125;\n    &#125;\n\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带原始功能的方法\n    public void saveSuper() &#123;\n        super.save();\n    &#125;\n    public void saveSuper(int i) &#123;\n        super.save(i);\n    &#125;\n    public void saveSuper(long j) &#123;\n        super.save(j);\n    &#125;\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带增强功能的方法\n    @Override\n    public void save() &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save0, new Object[0], save0Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(int i) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save1, new Object[]&#123;i&#125;, save1Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n\n    @Override\n    public void save(long j) &#123;\n        try &#123;\n            methodInterceptor.intercept(this, save2, new Object[]&#123;j&#125;, save2Proxy);\n        &#125; catch (Throwable e) &#123;\n            throw new UndeclaredThrowableException(e);\n        &#125;\n    &#125;\n&#125;\n\n//目标对象\npublic class Target &#123;\n    public void save() &#123;\n        System.out.println(\"save()\");\n    &#125;\n\n    public void save(int i) &#123;\n        System.out.println(\"save(int)\");\n    &#125;\n\n    public void save(long j) &#123;\n        System.out.println(\"save(long)\");\n    &#125;\n&#125;\n\npublic class A13 &#123;\n\n    public static void main(String[] args) &#123;\n        Proxy proxy = new Proxy();\n        Target target = new Target();\n        proxy.setMethodInterceptor(new MethodInterceptor() &#123;\n            @Override\n            public Object intercept(Object p, Method method, Object[] args,\n                                    MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"before...\");\n//                return method.invoke(target, args); // 反射调用\n                // FastClass\n//                return methodProxy.invoke(target, args); // 内部无反射, 结合目标用\n                return methodProxy.invokeSuper(p, args); // 内部无反射, 结合代理用\n            &#125;\n        &#125;);\n\n        proxy.save();\n        proxy.save(1);\n        proxy.save(2L);\n    &#125;\n&#125;\n\nMethodProxy 的 invoke 或 invokeSuper 方法时如何避免反射的调用\nimport org.springframework.cglib.core.Signature;\n\npublic class ProxyFastClass &#123;\n    static Signature s0 = new Signature(\"saveSuper\", \"()V\");\n    static Signature s1 = new Signature(\"saveSuper\", \"(I)V\");\n    static Signature s2 = new Signature(\"saveSuper\", \"(J)V\");\n\n    // 获取代理方法的编号\n    /*\n        Proxy\n            saveSuper()              0\n            saveSuper(int)           1\n            saveSuper(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object proxy, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Proxy) proxy).saveSuper();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Proxy) proxy).saveSuper((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Proxy) proxy).saveSuper((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        ProxyFastClass fastClass = new ProxyFastClass();\n        int index = fastClass.getIndex(new Signature(\"saveSuper\", \"()V\"));\n        System.out.println(index);\n\n        fastClass.invoke(index, new Proxy(), new Object[0]);\n    &#125;\n&#125;\n\n\nimport org.springframework.cglib.core.Signature;\n\npublic class TargetFastClass &#123;\n    static Signature s0 = new Signature(\"save\", \"()V\");\n    static Signature s1 = new Signature(\"save\", \"(I)V\");\n    static Signature s2 = new Signature(\"save\", \"(J)V\");\n\n    // 获取目标方法的编号\n    /*\n        Target\n            save()              0\n            save(int)           1\n            save(long)          2\n        signature 包括方法名字、参数返回值\n     */\n    public int getIndex(Signature signature) &#123;\n        if (s0.equals(signature)) &#123;\n            return 0;\n        &#125; else if (s1.equals(signature)) &#123;\n            return 1;\n        &#125; else if (s2.equals(signature)) &#123;\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n\n    // 根据方法编号, 正常调用目标对象方法\n    public Object invoke(int index, Object target, Object[] args) &#123;\n        if (index == 0) &#123;\n            ((Target) target).save();\n            return null;\n        &#125; else if (index == 1) &#123;\n            ((Target) target).save((int) args[0]);\n            return null;\n        &#125; else if (index == 2) &#123;\n            ((Target) target).save((long) args[0]);\n            return null;\n        &#125; else &#123;\n            throw new RuntimeException(\"无此方法\");\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TargetFastClass fastClass = new TargetFastClass();\n        int index = fastClass.getIndex(new Signature(\"save\", \"(I)V\"));\n        System.out.println(index);\n        fastClass.invoke(index, new Target(), new Object[]&#123;100&#125;);\n    &#125;\n&#125;\n\n\n当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类\nProxyFastClass 配合代理对象一起使用, 避免反射\nTargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)\n\n\nTargetFastClass 记录了 Target 中方法与编号的对应关系\nsave(long) 编号 2\nsave(int) 编号 1\nsave() 编号 0\n首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号\n然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射\n\n\nProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法\nsaveSuper(long) 编号 2，不增强，仅是调用 super.save(long)\nsaveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)\nsaveSuper() 编号 0，不增强, 仅是调用 super.save()\n查找方式与 TargetFastClass 类似\n\n\n为什么有这么麻烦的一套东西呢？\n避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法\n用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死\n\n\n\njdk动态代理和cglib的对比\n\njdk不是一上来就优化，先要调用16次，第17次才会针对一个方法产生一个代理类 ，后面的调用都无需反射\n\ncglib是一开始就产生代理，一个代理类对应两个fastclass,一个配合代理对象使用，另一个配合目标本身，每个fastclass匹配到多个方法，所有产生的代理类的数目相对jdk代理要少\n\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;jdk 和 cglib 在 Spring 中的统一&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n","slug":"AOP实现之proxy","date":"2023-05-10T08:38:34.603Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"},{"id":"d7e2802c58918040c31b14740192f666","title":"AOP实现之agent类加载","content":"AOP实现之agent类加载","slug":"AOP实现之agent类加载","date":"2023-05-10T08:32:18.000Z","categories_index":"","tags_index":"Java,Spring,AOP","author_index":"大宝贝的程序员"},{"id":"594a23198fd2599edc1d35598ede3148","title":"模板方法的设计模式","content":"模板方法的设计模式它定义了一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。\n模板方法设计模式的优点\n\n将算法的实现细节和算法本身分离开，使得算法的变化不会影响到算法的客户端，只需要修改算法的具体实现即可。\n通过把通用方法提取到抽象类中，避免了重复代码的出现，提高了代码的可重用性。\n提高了代码的可扩展性，可以在不修改算法骨架结构的情况下替换部分内容。\n使得算法的实现更加灵活，允许不同子类实现算法骨架的不同部分。\n\n模板方法设计模式的缺点\n\n由于将算法细节分离开，代码的难度可能会增加，这会导致代码的维护成本增加。\n子类对父类的依赖性较高，使得继承的滥用可能会导致代码的复杂性和不可读性增加。\n如果算法骨架的修改较多，可能会导致大量的类都需要进行调整，这会带来一定的开销。\n\n示例首先，创建一个抽象模板类，它定义了一个算法的骨架，并包含一些抽象方法，这些方法将在子类中实现。\npublic abstract class AlgorithmTemplate &#123;\n    public void executeAlgorithm() &#123;\n        initialize();\n        process();\n        finalize();\n    &#125;\n\n    protected abstract void initialize();\n\n    protected abstract void process();\n\n    protected abstract void finalize();\n&#125;\n\n然后，创建几个继承自抽象模板类的具体子类，并实现抽象方法。\npublic class ConcreteAlgorithmA extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmA: Finalizing...&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteAlgorithmB extends AlgorithmTemplate &#123;\n    protected void initialize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Initializing...&quot;);\n    &#125;\n\n    protected void process() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Processing...&quot;);\n    &#125;\n\n    protected void finalize() &#123;\n        System.out.println(&quot;ConcreteAlgorithmB: Finalizing...&quot;);\n    &#125;\n&#125;\n\n最后，在主程序中使用这些子类来演示模板方法设计模式。\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        AlgorithmTemplate algorithmA = new ConcreteAlgorithmA();\n        AlgorithmTemplate algorithmB = new ConcreteAlgorithmB();\n\n        algorithmA.executeAlgorithm();\n        algorithmB.executeAlgorithm();\n    &#125;\n&#125;\n\n当执行该程序时，输出如下：\nConcreteAlgorithmA: Initializing...\nConcreteAlgorithmA: Processing...\nConcreteAlgorithmA: Finalizing...\nConcreteAlgorithmB: Initializing...\nConcreteAlgorithmB: Processing...\nConcreteAlgorithmB: Finalizing...\n\n可以看出，多个具体子类都通过继承抽象模板类来实现相同的算法骨架。这使得更改算法骨架变得更加容易，并且可以避免重复编写相似的算法代码。\n","slug":"模板方法模式","date":"2023-05-09T13:53:44.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"8ced7c3b7dad33d06ee59bde7028cd4a","title":"策略模式","content":"策略模式它允许在运行时根据不同的情况选择算法的行为方式。\n在策略模式中，有多个算法可以完成同一项任务。在使用策略模式时，我们将每个算法都封装在一个独立的类中，这些类都实现了一个共同的接口。然后，在运行时，我们可以根据需要选择合适的算法来完成任务。\n优点\n\n封装了一系列算法：将一系列算法封装在不同的策略类中，使得这些算法可以互相替换而不影响客户端使用。\n可以动态切换算法：客户端可以在运行时动态选择使用哪个算法，实现了算法的动态切换。\n减少了复杂的条件语句：在不使用策略模式时，常常需要使用大量的条件语句来实现不同的算法，这样会使代码变得复杂而难以维护，策略模式可以避免这种情况的发生。\n提高了代码的可复用性：不同的策略类可以被多个客户端使用，提高了代码的重用性和可扩展性。\n\n缺点\n\n增加了类的数量：每个算法都需要一个对应的策略类，这样就会增加类的数量，使代码更加复杂，因此需要适当考虑其使用情况。\n客户端必须了解不同的策略类：客户端必须知道所有可用的策略类，并且自己决定哪一个策略类最适合解决当前的问题，这将增加客户端的困难。\n策略模式无法完全解决复杂的问题：虽然策略模式可以很好地解决简单的问题，但在某些情况下，可能需要多个算法之间的协调和处理，这时使用策略模式就很难实现。\n\n示例//创建一个接口，实现所有算法类都要实现的方法\ninterface Operation &#123;\n    double calculate(double a, double b);\n&#125;\n\n//创建算法类和实现Operation接口\nclass Addition implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\nclass Subtraction implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a - b;\n    &#125;\n&#125;\n\nclass Multiplication implements Operation &#123;\n    public double calculate(double a, double b) &#123;\n        return a * b;\n    &#125;\n&#125;\n\n//创建一个Context类，用来设置实际的策略\nclass Calculator &#123;\n    private Operation operation;\n\n    public void setOperation(Operation operation) &#123;\n        this.operation = operation;\n    &#125;\n\n    public double calculate(double a, double b) &#123;\n        return operation.calculate(a, b);\n    &#125;\n&#125;\n\n//使用示例\npublic class StrategyExample &#123;\n    public static void main(String[] args) &#123;\n        double a = 1.5;\n        double b = 2.0;\n\n        Calculator calculator = new Calculator();\n\n        //设置加法运算策略\n        calculator.setOperation(new Addition());\n        System.out.println(calculator.calculate(a, b)); //3.5\n\n        //设置减法运算策略\n        calculator.setOperation(new Subtraction());\n        System.out.println(calculator.calculate(a, b)); //-0.5\n\n        //设置乘法运算策略\n        calculator.setOperation(new Multiplication());\n        System.out.println(calculator.calculate(a, b)); //3.0\n    &#125;\n&#125;\n\n","slug":"策略模式","date":"2023-05-09T13:20:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"观察者模式它允许一个对象（称为被观察者或主题）维护一组依赖于它的对象（称为观察者），当被观察者发生变化时，它会通知所有观察者以便更新它们自己的状态。\n优点：\n\n在观察者模式中，被观察者和观察者之间是松耦合的关系，使得它们之间的交互变得简单而灵活。\n观察者模式支持广播通信，当一个对象发生改变时，多个观察者会同时得到通知，可以在不同的处理逻辑对其进行响应，提高了系统的可扩展性。\n观察者模式符合面向对象设计原则，将业务分离，使得代码更易于维护和扩展。\n\n缺点：\n\n观察者模式可能会导致系统中的观察者对象过多，造成性能上的问题。\n观察者模式需要考虑到开发效率与运行效率的平衡，在一些特定的场景下，使用观察者模式并不是最佳实践。\n\n应用场景：\n\n一个对象的改变需要同时改变其他对象的时候，可以考虑使用观察者模式。\n当系统中多个对象之间存在着一对多关系：一个对象的改变会影响到其他对象的时候，可以使用观察者模式。\n在分层架构中，可以使用观察者模式来解耦各层之间的关系。\n当需要将一个对象的状态同步到其他对象中，而又不希望耦合太多代码的时候，可以使用观察者模式。\n\n下面是一个Java代码示例首先，我们定义一个主题接口（Subject），定义主题必须实现的方法：\npublic interface Subject &#123;\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers(String msg);\n&#125;\n\n其中，attach(Observer)方法和detach(Observer)方法用于注册和注销观察者，notifyObservers(String)方法用于通知所有注册的观察者主题发生了变化。\n然后，我们定义一个观察者接口（Observer），观察者必须实现的方法：\npublic interface Observer &#123;\n    void update(String msg);\n&#125;\n\n其中，update(String)方法用于接收主题发生变化的通知并进行相应的处理。\n接下来，我们实现Subject接口：\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer> observers = new ArrayList&lt;>();\n    private String state;\n\n    public void attach(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    public void detach(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    public void notifyObservers(String msg) &#123;\n        for (Observer observer : observers) &#123;\n            observer.update(msg);\n        &#125;\n    &#125;\n\n    public void setState(String state) &#123;\n        this.state = state;\n        notifyObservers(\"State changed to \" + state);\n    &#125;\n&#125;\n\n其中，observers是用于存储所有观察者对象的列表，state是主题的状态。\nattach(Observer)方法和detach(Observer)方法用于添加和删除观察者对象，notifyObservers(String)方法用于通知所有观察者主题发生了变化。在setState(String)方法中，每次设置主题状态时都会调用notifyObservers(String)方法通知所有观察者。\n最后，我们实现Observer接口：\npublic class ConcreteObserver implements Observer &#123;\n    private String name;\n\n    public ConcreteObserver(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void update(String msg) &#123;\n        System.out.println(name + \" received message: \" + msg);\n    &#125;\n&#125;\n\n其中，update()方法用于接收主题发生变化的通知并进行相应的处理。\n下面是一个使用观察者模式的示例：\npublic static void main(String[] args) &#123;\n    ConcreteSubject subject = new ConcreteSubject();\n\n    ConcreteObserver observer1 = new ConcreteObserver(\"Observer 1\");\n    ConcreteObserver observer2 = new ConcreteObserver(\"Observer 2\");\n\n    subject.attach(observer1);\n    subject.attach(observer2);\n\n    subject.setState(\"New state\");\n\n    subject.detach(observer1);\n\n    subject.setState(\"Another new state\");\n&#125;\n\n在这个示例中，我们首先创建了一个ConcreteSubject对象，并创建了两个ConcreteObserver对象。然后，我们将两个观察者对象注册到主题对象中，并设置主题状态为“New state”，所有观察者都会收到通知并进行相应的处理。接着，我们将其中一个观察者对象从主题对象中注销，设置主题状态为“Another new state”，只有一个观察者对象会收到通知并进行相应的处理。\n","slug":"观察者模式","date":"2023-05-09T12:47:06.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"2b09bf65e737f820cf301fb7434c8c8e","title":"责任链模式","content":"责任链模式责任链模式是一种行为设计模式，用于将请求从一个处理程序传递到另一个处理程序，直到找到能够处理请求的处理程序。每个处理程序都将请求传递给下一个处理程序，直到请求被处理为止。\n责任链模式的特点\n\n请求发送者不必知道请求在何时、何处以及如何被处理。\n可以动态增加或修改请求的处理流程，增强了系统的灵活性、可维护性、可扩展性。\n处理程序之间解耦，互相独立，易于单元测试和调试。\n可以避免请求的发送者和接收者的耦合关系，提高系统的灵活性。\n\n责任链模式的优点\n\n单一职责原则：每个处理程序只负责处理自己专业领域内的请求。\n开闭原则：可以很方便地增加或删除处理程序，同时不会影响到其他处理程序。\n易于扩展：可以根据需要动态地增加或修改请求的处理流程。具有很好的灵活性和可扩展性。\n代码复用性高：能够避免大量重复代码的产生，减少了系统的维护成本。\n\n责任链模式的缺点\n\n无法保证请求一定被处理：如果链中没有任何一个处理程序能够处理请求，那么请求可能会被忽略或者丢失。\n可能导致系统性能下降：由于处理程序是动态添加的，可能会导致系统的处理过程比较缓慢、效率较低。\n可能会产生很多细粒度的对象：如果责任链比较长，那么可能会产生很多细粒度的对象，导致系统资源的浪费。\n\n示例public abstract class Handler &#123;\n \n    protected Handler successor;\n \n    public void setSuccessor(Handler successor) &#123;\n        this.successor = successor;\n    &#125;\n \n    public abstract void handleRequest(Request request);\n&#125;\n\npublic class ConcreteHandler1 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE1) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler1\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class ConcreteHandler2 extends Handler &#123;\n \n    public void handleRequest(Request request) &#123;\n        if (request.getType() == RequestType.TYPE2) &#123;\n            System.out.println(request.getName() + \" is handled by ConcreteHandler2\");\n        &#125; else if (successor != null) &#123;\n            successor.handleRequest(request);\n        &#125;\n    &#125;\n&#125;\n\npublic class Request &#123;\n     \n    private RequestType type;\n    private String name;\n \n    public Request(RequestType type, String name) &#123;\n        this.type = type;\n        this.name = name;\n    &#125;\n \n    public RequestType getType() &#123;\n        return type;\n    &#125;\n \n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;\n\npublic enum RequestType &#123;\n    TYPE1, TYPE2\n&#125;\n\npublic class Main &#123;\n \n    public static void main(String[] args) &#123;\n        Handler handler1 = new ConcreteHandler1();\n        Handler handler2 = new ConcreteHandler2();\n         \n        handler1.setSuccessor(handler2);\n \n        Request request1 = new Request(RequestType.TYPE1, \"Request 1\");\n        Request request2 = new Request(RequestType.TYPE2, \"Request 2\");\n \n        handler1.handleRequest(request1);\n        handler1.handleRequest(request2);\n    &#125;\n&#125;\n\n在上面的示例中，我们定义了一个抽象处理程序类Handler，它包含一个指向下一个处理程序的引用。然后我们创建了两个具体的处理程序类ConcreteHandler1和ConcreteHandler2，它们都继承了Handler类并实现了handleRequest()方法。\n我们还创建了一个Request类和一个枚举类型RequestType用于模拟请求对象。最后，我们在Main类中创建了两个请求对象并将它们传递给链中的第一个处理程序ConcreteHandler1。\n在上面的示例中，如果请求类型是TYPE1，则它由ConcreteHandler1处理，否则它将传递给下一个处理程序。如果请求类型是TYPE2，则它由ConcreteHandler2处理，否则它将传递给下一个处理程序，直到找到能够处理请求的处理程序。\n","slug":"责任链模式","date":"2023-05-09T12:16:17.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"424f199f6c88af138e76cfdf85fb4fa5","title":"代理模式","content":"代理模式它为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，可以进行一些附加的工作，例如访问控制、远程访问、缓存等。\n以下是一个简单的代理模式的Java例子：interface Image &#123;\n    void display();\n&#125;\n\nclass RealImage implements Image &#123;\n    private String filename;\n\n    public RealImage(String filename) &#123;\n        this.filename = filename;\n        loadFromDisk();\n    &#125;\n\n    private void loadFromDisk() &#123;\n        System.out.println(\"Loading \" + filename);\n    &#125;\n\n    public void display() &#123;\n        System.out.println(\"Displaying \" + filename);\n    &#125;\n&#125;\n\nclass ImageProxy implements Image &#123;\n    private String filename;\n    private RealImage image;\n\n    public ImageProxy(String filename) &#123;\n        this.filename = filename;\n    &#125;\n\n    public void display() &#123;\n        if (image == null)\n            image = new RealImage(filename);\n        image.display();\n    &#125;\n&#125;\n\npublic class ProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        Image image = new ImageProxy(\"test.jpg\");\n        image.display();\n    &#125;\n&#125;\n\n在上面的例子中，我们定义了一个Image接口，其中RealImage是实现此接口的具体对象，它代表了一个真实的图片文件。ImageProxy类也实现了Image接口，但是它并不是真正的图片，而是一个代理。它可以延迟加载RealImage对象，并且在需要时，通过代理实现对RealImage对象的访问。这样，我们就可以控制对RealImage对象的访问并且可以做一些附加的工作。当客户端调用Image的display()方法时，ImageProxy会判断是否已经加载了RealImage对象，如果没有，则创建RealImage对象并调用它的display()方法。\n","slug":"代理模式","date":"2023-05-09T11:52:50.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"af957b16e3777023cafc3b1e9179b2cd","title":"装饰器模式","content":"装饰器模式装饰者模式（Decorator Pattern）\n​\t它允许你向现有对象添加新的功能，同时又不改变其结构。装饰者模式的核心思想是将功能进行分离，让各个类只专注于自己的职责。通过这种方式，我们可以以非常灵活的方式扩展系统的功能，而不必修改原有代码。\n​\t装饰器模式的主要目的是为对象动态地添加额外的功能，不需要修改原始对象的结构。装饰器接收一个原始对象，并在其上添加一些额外的装饰操作，从而增强了原始对象的功能。装饰器模式避免了使用子类继承的方式进行功能扩展，因为这种方式可能导致类层次结构过于复杂，而且无法动态修改对象的行为。\n下面是一个简单的示例：\n首先，我们需要定义一个具有基本功能的接口Component和该接口的一个实现类ConcreteComponent：\npublic interface Component &#123;\n    void operation();\n&#125;\n\npublic class ConcreteComponent implements Component &#123;\n    @Override\n    public void operation() &#123;\n        System.out.println(\"This is a Concrete Component\");\n    &#125;\n&#125;\n\n然后，我们需要创建装饰器Decorator，它持有一个Component实例，并重新实现operation方法：\npublic class Decorator implements Component &#123;\n    private Component component;\n\n    public Decorator(Component component) &#123;\n        this.component = component;\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        component.operation();\n    &#125;\n&#125;\n\n最后，我们创建一个具体的装饰器ConcreteDecorator，它添加了额外的功能：\npublic class ConcreteDecorator extends Decorator &#123;\n    public ConcreteDecorator(Component component) &#123;\n        super(component);\n    &#125;\n\n    @Override\n    public void operation() &#123;\n        super.operation();\n        addedFunction();\n    &#125;\n\n    private void addedFunction() &#123;\n        System.out.println(\"This is an added function\");\n    &#125;\n&#125;\n\n我们可以通过以下方式使用装饰器模式：\nComponent c1 = new ConcreteComponent();\nc1.operation();\n\nComponent c2 = new ConcreteDecorator(new ConcreteComponent());\nc2.operation();\n\nComponent c3 = new ConcreteDecorator(new ConcreteDecorator(new ConcreteComponent()));\nc3.operation();\n\n输出结果：\nThis is a Concrete Component\nThis is a Concrete Component\nThis is an added function\nThis is a Concrete Component\nThis is an added function\nThis is an added function\n\n从输出结果可以看出，通过装饰器模式，我们可以动态地添加额外的功能，而不需要修改原有代码。\n总结一下，装饰器模式是一种非常有用的设计模式，它可以让我们以一种灵活的方式扩展系统的功能。同时，装饰器模式让各个类的职责更加清晰，可以更加方便地进行维护。但是，在使用装饰器模式时，我们需要注意不要过度使用，避免造成代码过于复杂和混乱。\n","slug":"装饰器模式","date":"2023-05-09T11:12:05.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"890198f3e29403fa2d961081f54ed8cd","title":"组合模式","content":"组合模式组合模式 \n主要通过将对象组合成树形结构来表示“整体-部分”的关系，让客户端能够以一致的方式对待单个对象和对象合。\n下面是一个简单的例子import java.util.ArrayList;\nimport java.util.List;\n\npublic interface Employee &#123;\n    void showDetails();\n&#125;\n\nclass Leaf implements Employee &#123;\n    private String name;\n    private String position;\n\n    Leaf(String name, String position) &#123;\n        this.name = name;\n        this.position = position;\n    &#125;\n\n    @Override\n    public void showDetails() &#123;\n        System.out.println(name + \" is a \" + position);\n    &#125;\n&#125;\n\nclass Composite implements Employee &#123;\n    private List&lt;Employee> employees = new ArrayList&lt;Employee>();\n\n    @Override\n    public void showDetails() &#123;\n        for (Employee employee : employees) &#123;\n            employee.showDetails();\n        &#125;\n    &#125;\n\n    public void addEmployee(Employee employee) &#123;\n        employees.add(employee);\n    &#125;\n\n    public void removeEmployee(Employee employee) &#123;\n        employees.remove(employee);\n    &#125;\n&#125;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Composite organization = new Composite();\n        organization.addEmployee(new Leaf(\"John Doe\", \"Manager\"));\n        Composite department = new Composite();\n        department.addEmployee(new Leaf(\"Jane Smith\", \"Team Lead\"));\n        department.addEmployee(new Leaf(\"Bob Johnson\", \"Engineer\"));\n        Composite subDepartment = new Composite();\n        subDepartment.addEmployee(new Leaf(\"Tina Turner\", \"Engineer\"));\n        subDepartment.addEmployee(new Leaf(\"Steve Rogers\", \"Engineer\"));\n        department.addEmployee(subDepartment);\n        organization.addEmployee(department);\n        organization.showDetails();\n    &#125;\n&#125;\n\n在上面的示例中，Employee是一个接口，有两个实现类：Leaf和Composite。Leaf代表的是单个员工，而Composite代表的是员工组合。composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成\n使用组合模式，我们可以创建一个包含多个员工和部门的组织结构，并可以方便地对整个组织结构进行操作。在示例中，我们创建了一个根节点organization，它包含一个员工John Doe和一个部门department。部门department包含一个团队领导Jane Smith和一个工程师Bob Johnson，以及一个子部门subDepartment，子部门subDepartment包含两个工程师Tina Turner和Steve Rogers。最后，我们通过调用organization.showDetails()方法来打印组织结构中每个员工的详细信息。\n","slug":"组合模式","date":"2023-05-09T10:42:25.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"a8b2eb4f810dce05fcecb16e8edfd126","title":"适配器模式","content":"适配器模式适配器模式（Adapter Pattern）是一种结构型设计模式，它用于将一个类的接口转换成客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作。在适配器模式中，适配器充当了两个不兼容接口之间的桥梁，它负责允许这些接口间能够相互协作。\n在Java中，适配器模式常用于将不兼容的接口进行转换，通常包含以下三个角色：\n\nTarget（目标抽象类）：客户端所期望的接口，定义客户端所需的操作。\nAdapter（适配器类）：适配器，将Adaptee转换成Target所期望的接口。它维护了一个指向Adaptee对象的引用，并实现Target接口，使得客户端能够通过Adapter来访问Adaptee对象。\nAdaptee（原本的类）：需要被适配的类，包含原本的方法或接口。\n\n示例我们模拟了一个旧版的Android手机（OldAndroidPhone）和一个新版的iOS手机（NewiPhone），它们分别有不同的音乐播放器接口，而我们需要使用一个适配器（MusicPlayerAdapter）来兼容它们的操作：\n//原有音乐播放接口 \ninterface MusicPlayer &#123;\n    void playMP3(String fileName);\n&#125;\n\n//旧版Android手机\nclass OldAndroidPhone implements MusicPlayer &#123;\n    public void playMP3(String fileName) &#123;\n        System.out.println(\"Old Android phone is playing MP3 file: \" + fileName);\n    &#125;\n&#125;\n\n//新版iPhone手机 \ninterface NewiPhonePlayer &#123;\n    void playAAC(String fileName);\n&#125;\n\nclass NewiPhone implements NewiPhonePlayer &#123;\n    public void playAAC(String fileName) &#123;\n        System.out.println(\"New iPhone is playing AAC file: \" + fileName);\n    &#125;\n&#125;\n\n//适配器，将旧版手机的操作适配成新版手机可以使用的形式\nclass MusicPlayerAdapter implements NewiPhonePlayer &#123;\n    private MusicPlayer player;\n    \n    public MusicPlayerAdapter(MusicPlayer player)&#123;\n        this.player = player;\n    &#125;\n    \n    //适配器将AAC文件转化为MP3文件，并调用原有的播放方法\n    public void playAAC(String fileName) &#123;\n        String mp3File = convertAACtoMP3(fileName);\n        player.playMP3(mp3File);\n    &#125;\n    \n    private String convertAACtoMP3(String fileName)&#123;\n        System.out.println(\"Converting AAC to MP3: \" + fileName);\n        return fileName.replace(\".aac\", \".mp3\");\n    &#125;\n&#125;\n\n//客户端使用例子\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        //旧版Android手机播放MP3\n        MusicPlayer oldPhone = new OldAndroidPhone();\n        oldPhone.playMP3(\"old_phone_music.mp3\");\n        \n        //新版iPhone手机播放AAC，使用适配器兼容播放MP3文件\n        NewiPhonePlayer newPhone = new NewiPhone();\n        MusicPlayerAdapter adapter = new MusicPlayerAdapter(oldPhone);\n        newPhone.playAAC(\"new_phone_music.aac\");\n        adapter.playAAC(\"new_phone_music.aac\");\n    &#125;\n&#125;\n\n在上面的代码中，我们首先定义了两个已有的音乐播放器接口 MusicPlayer 和 NewiPhonePlayer，它们分别被 OldAndroidPhone 和 NewiPhone 实现。然后，我们使用 MusicPlayerAdapter 类将 OldAndroidPhone 类的 playMP3 方法适配成 NewiPhonePlayer 接口的 playAAC 方法，通过这个适配器，新版 iPhone 手机可以兼容旧版 Android 手机的音乐播放功能。在客户端使用时，我们分别调用了 OldAndroidPhone 的 playMP3 方法（旧版 Android 手机）和 NewiPhonePlayer 的 playAAC 方法（新版 iPhone 手机，使用 MusicPlayerAdapter 适配器）。\n我们可以看出适配器模式的优点：\n\n可以让原有的接口和新接口之间不发生冲突地协同工作，从而让代码更好地拓展和维护。\n\n","slug":"适配器模式","date":"2023-05-09T08:09:59.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"3dbdc722104d94fc07273118e255f7fd","title":"工厂模式","content":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数\n简单工厂UML类图\n\n适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需\n要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较\n复杂。\n简单工厂的例子:\nCalendar类的getInstance方法使用了一种简单工厂的方式来创建不同地区的日历对象。\n具体来说，Calendar类本身是一个抽象类，它定义了一些方法来处理日期和时间。由于不同地区有不同的日历，因此Calendar类并没有直接实现具体的日历，而是通过getInstance方法来获取指定地区的Calendar实例。getInstance方法接受一个Locale类型的参数，它根据不同的Locale参数调用createCalendar方法创建具体的日历实例。createCalendar方法是一个protected方法，由Calendar类的子类来实现。在具体的子类中，根据传入的Locale参数创建相应的日历对象，然后返回。这里，createCalendar方法就扮演了一个简单工厂模式中的工厂的角色，而Calendar类则相当于一个创建工厂，负责整个日历对象的生成过程的调度。\n工厂方法模式在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是提供一个工厂接口，由不同的子类来实现工厂接口中的方法来创建不同的对象。这样做的好处是增加了系统的扩展性和灵活性，可以根据实际需求来增加相应的子类和工厂实现。\n工厂方法模式通常由四部分组成：抽象产品、具体产品、抽象工厂、具体工厂。其中，抽象产品是需要创建的对象的通用接口，具体产品是实现抽象产品接口的具体类，抽象工厂是创建产品的接口，具体工厂是实现抽象工厂接口的具体类。\n工厂方法UML类图：\n\n使用工厂方法模式的好处是：\n\n可扩展性更好。使用工厂方法模式可以更加容易地扩展和添加新的产品类，而不会影响原有的代码结构。\n\n易于维护。工厂方法模式将创建对象的代码集中在一个地方，易于维护。当需要修改时，只需要修改对应的工厂类即可，而不需要修改客户端代码。\n\n降低耦合度。使用工厂方法模式可以将客户端代码和具体产品的实现解耦，使得客户端代码不需要了解每个具体产品类的细节。\n\n\n抽象工厂方法模式抽象工厂模式是工厂方法模式的扩展，旨在提供一个工厂接口来创建一系列相关的产品，而不是单一的产品类。\n抽象工厂模式中会存在多个产品族，每个产品族包含多个产品等级结构。产品等级结构是指具有相同功能的产品组成的集合，例如大众汽车、奥迪汽车和奔驰汽车组成了一个产品族，而每种汽车都具有车轮、车身和发动机等等组成的产品等级结构。\n在抽象工厂模式中，定义一个抽象工厂接口，它包含了一组用于创建产品族中每个产品等级结构的方法。每个具体的工厂类实现这个接口，负责实现自己的产品族生产过程。而具体产品则由具体工厂类中的具体方法实现来创建。\n通过抽象工厂模式，我们可以创造一个家族的对象，这个家族可以看做是一个产品族，而每个家族成员可以看做是这个产品族中的某个产品等级结构。抽象工厂模式保证了各种产品之间的兼容性，即一个工厂创建的产品都是该工厂创建的其他产品的兼容组合。\n抽象工厂UML类图：\n\n示例代码:首先是汽车工厂的抽象类（Abstract Factory）：\n// 定义汽车工厂的抽象类\nabstract class CarFactory &#123;\n    abstract Wheel createWheel();\n    abstract Body createBody();\n    abstract Engine createEngine();\n&#125;\n\n然后是具体的大众汽车工厂类（Volkswagen Car Factory）和奥迪汽车工厂类（Audi Car Factory）：\n// 定义大众汽车工厂\nclass VolkswagenFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new VolkswagenWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new VolkswagenBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new VolkswagenEngine();\n    &#125;\n&#125;\n\n// 定义奥迪汽车工厂\nclass AudiFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new AudiWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new AudiBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new AudiEngine();\n    &#125;\n&#125;\n\n然后是汽车组件的抽象类（Abstract Product）：\n// 定义汽车的组件抽象类\nabstract class Wheel &#123;\n    public abstract void create();\n&#125;\nabstract class Body &#123;\n    public abstract void create();\n&#125;\nabstract class Engine &#123;\n    public abstract void create();\n&#125;\n\n具体的大众和奥迪汽车组件的类：\n// 定义大众汽车组件\nclass VolkswagenWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车轮\");\n    &#125;\n&#125;\nclass VolkswagenBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车身\");\n    &#125;\n&#125;\nclass VolkswagenEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众发动机\");\n    &#125;\n&#125;\n\n// 定义奥迪汽车组件\nclass AudiWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车轮\");\n    &#125;\n&#125;\nclass AudiBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车身\");\n    &#125;\n&#125;\nclass AudiEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪发动机\");\n    &#125;\n&#125;\n\n最后，我们可以使用这些类来创建不同品牌的汽车：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        // 创建大众汽车\n        CarFactory vwFactory = new VolkswagenFactory();\n        vwFactory.createWheel().create();\n        vwFactory.createBody().create();\n        vwFactory.createEngine().create();\n        \n        // 创建奥迪汽车\n        CarFactory audiFactory = new AudiFactory();\n        audiFactory.createWheel().create();\n        audiFactory.createBody().create();\n        audiFactory.createEngine().create();\n    &#125;\n&#125;\n\n","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"b00cac0eae3b04411014ea36945005af","title":"建造者模式","content":"Java建造者模式Java中的建造者模式(Builder Pattern)\n主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。\n该模式包含以下几个角色：\n\nBuilder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。\n\nConcreteBuilder(具体建造者)：实现Builder接口，实现具体产品的创建过程，以及返回具体产品的方法。\n\nDirector(导演者)：负责调用建造者生成产品。\n\nProduct(产品)：表示被生成的复杂对象，包含多个部件。\n\n\n以下是Java中的建造者模式示例代码：\n// Product\nclass Car &#123;\n    private String engine;\n    private String chassis;\n    private String body;\n\n    public void setEngine(String engine) &#123;\n        this.engine = engine;\n    &#125;\n\n    public void setChassis(String chassis) &#123;\n        this.chassis = chassis;\n    &#125;\n\n    public void setBody(String body) &#123;\n        this.body = body;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Car &#123;engine='\" + engine + \"', chassis='\" + chassis + \"', body='\" + body + \"'&#125;\";\n    &#125;\n&#125;\n\n// Builder\ninterface CarBuilder &#123;\n    void buildEngine();\n    void buildChassis();\n    void buildBody();\n    Car getCar();\n&#125;\n\n// ConcreteBuilders\nclass SportsCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SportsCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"3.0L V6\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Aluminum\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Carbon Fiber\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\nclass SedanCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SedanCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"2.4L 4-cylinder\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Steel\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Metal\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\n\n// Director\nclass AutomotiveEngineer &#123;\n    public void build (CarBuilder builder) &#123;\n        builder.buildEngine();\n        builder.buildChassis();\n        builder.buildBody();\n    &#125;\n&#125;\n\npublic class BuilderPatternExample &#123;\n    public static void main(String[] args) &#123;\n        AutomotiveEngineer engineer = new AutomotiveEngineer();\n\n        CarBuilder sportsCarBuilder = new SportsCarBuilder();\n        engineer.build (sportsCarBuilder);\n        System.out.println(sportsCarBuilder.getCar()); \n        // Output: Car &#123;engine='3.0L V6', chassis='Aluminum', body='Carbon Fiber'&#125;\n\n        CarBuilder sedanCarBuilder = new SedanCarBuilder();\n        engineer.build (sedanCarBuilder);\n        System.out.println(sedanCarBuilder.getCar()); \n        // Output: Car &#123;engine='2.4L 4-cylinder', chassis='Steel', body='Metal'&#125;\n    &#125;\n&#125;\n\n在这个示例中，CarBuilder表示抽象建造者，SportsCarBuilder和SedanCarBuilder分别表示具体建造者，AutomotiveEngineer表示导演者，Car表示产品。通过导演者调用具体建造者的构建方法，即可建造出不同的Car实例。\n它的主要亮点有三处：\n\n较为灵活的构建产品对象\n\n在不执行最后 build 方法前，产品对象都不可用\n\n构建过程采用链式调用，看起来比较爽\n\n\n","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"0c6e8405652937a86cc3782f838cf782","title":"spring中常见的设计模式","content":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别\n\n根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it\n\n就是确保只有一个实例提供给全局使用\n\n显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例\n Spring中也有用到单例模式\n\norg.springframework.transaction.TransactionDefinition#withDefaults\n\norg.springframework.aop.TruePointcut#INSTANCE\n\norg.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR\n\norg.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE\n\norg.springframework.core.OrderComparator#INSTANCE\n\n\n2.Spring中的Builder（建造者模式）定义 Separate the construction of a complex object from its representation so that the same construction process can create different representations 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。\n优点：\n\n较为灵活的构建产品对象\n在不执行最后 build 方法前，产品对象都不可用\n构建过程采用链式调用，看起来比较爽\n\nSpring 中体现 Builder 模式的地方：\n\norg.springframework.beans.factory.support.BeanDefinitionBuilder\norg.springframework.web.util.UriComponentsBuilder\norg.springframework.http.ResponseEntity.HeadersBuilder\norg.springframework.http.ResponseEntity.BodyBuilder\n\n3.Spring中的Factory Method(工厂方法模式)定义Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。\nSpring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现\nSpring 中其它工厂：\n\norg.springframework.beans.factory.FactoryBean\n\n@Bean 标注的静态方法及实例方法\n\nObjectFactory 及 ObjectProvider\n\n\n前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题\n4.Spring中的Adapter(适配器模式)定义 Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。\n典型的实现有两处:\n\norg.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有\n@RequestMapping 标注的控制器实现\n传统的基于 Controller 接口（不是 @Controller注解啊）的实现\n较新的基于 RouterFunction 接口的实现\n它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口\n\n\norg.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法\n\n5.Spring中的Composite(组合模式)定义 Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly  即将对象组合成树形结构来表示部分-整体层次结构。组合模式可以让客户端统一地对待单个对象和对象组合。\n典型实现有：\n\norg.springframework.web.method.support.HandlerMethodArgumentResolverComposite\norg.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite\norg.springframework.web.servlet.handler.HandlerExceptionResolverComposite\norg.springframework.web.servlet.view.ViewResolverComposite\n\ncomposite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是：与具体干活的类实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的类实现来完成                                                                     \n6.Spring中的Decorator(装饰器模式)定义 Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality 即 向对象动态地附加职责。 装饰器提供了一种灵活的替代继承的方式，以扩展功能。\n典型实现：\n\norg.springframework.web.util.ContentCachingRequestWrapper\n\nContentCachingRequestWrapper 通过包装 HttpServletRequest 对象，提供了对输入流进行重复读取和缓存的功能。其构造函数需要传入一个原始的 HttpServletRequest 对象，然后使用自己的 ByteArrayOutputStream 缓存请求体，同时提供了多个方法来获取请求信息。例如：\n\ngetContentAsByteArray() : 获取请求的内容（byte 数组），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetContentAsStream() : 返回请求的内容流（ServletInputStream），如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\ngetReader() : 返回一个读取请求内容的 BufferedReader 实例，如果请求内容被缓存了，则返回缓存的内容，否则读取并返回原始内容。\n\n总的来说，ContentCachingRequestWrapper 的实现非常好地体现了装饰器模式的思想，通过包装原始请求对象，提供了额外的功能，并且不改变原始对象的行为，从而实现了请求体的缓存和多次读取。\n7.Spring中的Proxy(代理模式)定义 Provide a surrogate or placeholder for another object to control access to it 即，为另一个对象提供一个代理或占位符来控制对它的访问。\n代理模式的主要目的是控制对目标对象的访问，在不改变原有代码的情况下，为对象提供一种间接访问的方式。代理模式在客户端和目标对象之间创建了一个代理对象，客户端通过代理对象来访问目标对象，从而可以对访问进行控制。代理模式可以用于保护目标对象的访问性、缓存对象等。\n与装饰器模式的区别\n装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问\n典型实现：\n\norg.springframework.aop.framework.JdkDynamicAopProxy\norg.springframework.aop.framework.ObjenesisCglibAopProxy\n\n8.Spring中的Chain of Responsibility(责任链模式)定义 Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it 即 避免使用一个对象直接调用另一个对象，而是通过将请求传递给多个对象中的一个来处理请求。将接收对象链接在一起，并将请求沿着链传递，直到一个对象能够处理它。\n典型实现：\n\norg.springframework.web.servlet.HandlerInterceptor\n\nHandlerInterceptor支持责任链模式，通过链式调用多个HandlerInterceptor，可以处理同一个请求的多个这样的拦截器。\n当一个请求到达后端控制器前，可以通过多个HandlerInterceptor按照特定的顺序进行处理。每个HandlerInterceptor可以处理请求，然后将处理结果传递给下一个HandlerInterceptor。这样，就形成了一个责任链。\n在责任链模式中，我们可以动态添加或删除HandlerInterceptor，并且可以定义多个拦截器链。这样，我们可以实现一些复杂的处理逻辑，将请求按照不同的方式进行处理，以达到更好的效果。\n9.Spring 中的 Observer(观察者模式)定义 Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically 即 定义一种一对多的对象依赖关系，这样当一个对象改变状态时，所有其依赖者将自动得到通知并更新。\n典型实现：\n\norg.springframework.context.ApplicationListener\norg.springframework.context.event.ApplicationEventMulticaster\norg.springframework.context.ApplicationEvent\n\n一个事件（ApplicationEvent）可以被ApplicationContext中的一个或多个ApplicationListener所监听。ApplicationContext会在事件发生时通知已注册的ApplicationListener，并由ApplicationListener来负责对该事件做出响应。\n为了实现这种模式，Spring提供了以下几个核心组件：\n\nApplicationEvent：代表了一个应用程序中发生的事件，包含了事件的信息。\nApplicationListener：负责处理事件，并进行响应的组件。\nApplicationEventMulticaster：用于管理事件监听器，负责将事件分发给对应的监听器进行处理。\n\n当一个事件被触发时，ApplicationEventMulticaster会调用所有已注册的ApplicationListener实例的onApplicationEvent()方法来进行处理。当事件被多个ApplicationListener监听时，ApplicationEventMulticaster会按顺序调用它们的onApplicationEvent()方法。\n因此，Spring的事件驱动模型就体现了观察者模式的特征，其中ApplicationListener充当了观察者的角色，ApplicationEventMulticaster充当了被观察者的角色。\n10. Spring 中的 Strategy(策略模式)定义 Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it 即，定义一个算法族，将每个算法封装起来，使它们可以互换。策略模式能够让算法的变化独立于使用它们的客户端。\n典型实现：\n\norg.springframework.beans.factory.support.InstantiationStrategy\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy\norg.springframework.boot.autoconfigure.condition.SearchStrategy\n\norg.springframework.beans.factory.support.InstantiationStrategy：存在多个实现InstantiationStrategy接口的类，这些类都实现了不同的实例化策略，比如：CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy和SmartInstantiationStrategy等。这些实现类可以根据实际情况取舍，通过策略模式实现了实例化策略的动态切换。\norg.springframework.core.annotation.MergedAnnotations.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的注解查找策略，比如：TypeMappedAnnotationChecker、RepeatableContainers、DirectlyDeclaredAnnotations和SynthesizedAnnotationDetection等。这些实现类可以根据实际情况取舍，通过策略模式实现了注解查找策略的动态切换。\norg.springframework.boot.autoconfigure.condition.SearchStrategy：存在多个实现SearchStrategy接口的类，这些类都实现了不同的条件判断策略，比如：OnClassCondition、ConditionalOnWebApplication和ConditionalOnProperty等。这些实现类可以根据实际情况取舍，通过策略模式实现了条件判断策略的动态切换。\n11. Spring 中的 Template Method(模板方法)定义 Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure  在一个操作中定义算法的框架，将某些步骤延迟到子类中。模板方法让子类重新定义算法的某些步骤，而不改变算法的结构。\n典型实现：\n\n大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate\n很多以 Abstract 命名的类，如 AbstractApplicationContext\n\n在JdbcTemplate中，模板方法是execute()方法，它封装了执行SQL语句的流程，具体的SQL语句可以通过传入不同的参数来实现。execute()方法中包含了一些固定的步骤，如获取连接、创建Statement、执行SQL语句、关闭资源等，这些步骤是不变的，但是具体的SQL语句和参数是可以变化的。通过这种方式，JdbcTemplate将重复的、泛化的操作封装到模板方法中，使得使用者只需要关注具体的SQL语句和参数。\nTransactionTemplate也是类似的，在Spring事务管理中，它封装了执行事务的流程，具体的事务操作可以通过传入不同的参数来实现。TransactionTemplate中的模板方法是execute()方法，它包含了获取事务、执行方法、提交&#x2F;回滚事务等固定步骤，这些步骤是每个事务操作都必须要执行的，但是具体的事务操作可以改变。通过这种方式，TransactionTemplate将事务管理的复杂性封装到模板方法中，使用者只需要关注自己的业务逻辑，而不需要关心事务的管理。\n在AbstractApplicationContext中，模板方法是refresh()方法，该方法包含了Spring容器的初始化流程，具体的初始化过程可以通过继承AbstractApplicationContext的子类来实现。refresh()方法中包含了一些固定的步骤，比如读取配置文件、创建&#x2F;初始化BeanFactory、加载Bean定义、注册BeanPostProcessor等，这些步骤是不变的，但是具体的实现可以改变。子类根据自己的需要，可以通过重写refresh()方法中的一些步骤来实现自己的初始化过程，比如读取不同的配置文件、使用不同的BeanFactory等。\n通过这种方式，AbstractApplicationContext将Spring容器的初始化过程封装到模板方法中，使得使用者只需要关注具体的Bean的配置和使用，而不需要关心Spring容器的初始化过程。这样可以大大简化代码的编写和维护，提高开发效率。\n","slug":"Spring中的设计模式","date":"2023-05-09T04:00:50.000Z","categories_index":"","tags_index":"Java,设计模式,Spring","author_index":"大宝贝的程序员"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，\n构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀\n个静态公有⽅法获取实例。\n优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的\n情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，\n与单⼀职责原则冲突。\n单例模式的常⻅写法有哪些？饿汉式顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间。\n\n优点：线程安全，没有加锁，执⾏效率较⾼\n\n缺点：不是懒加载，类加载时就初始化，浪费内存空间\n\n\n\n线程安全：饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程\n的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。\n\n\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123;&#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private final static Singleton instance = new\nSingleton();\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n return instance;\n &#125;\n&#125;\n\n使⽤反射破坏单例public class Test &#123;\n public static void main(String[] args) throws\nException&#123;\n // 使⽤反射破坏单例\n // 获取空参构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(null);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例\n Singleton singleton =\ndeclaredConstructor.newInstance();\n System.out.println(\"反射创建的实例\" + singleton);\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n &#125;\n&#125;\n\n输出结果如下反射创建的实例\ncom.example.spring.demo.single.Singleton@6267c3bb\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n\n线程不安全的懒汉式这种⽅式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的，这⾥列出来是为了和后⾯使⽤锁保证线程安全的单例做对⽐\n\n优点：懒加载\n缺点：线程不安全\n\n//线程不安全的懒汉式单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 判断为 null 的时候再创建对象\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n &#125;\n&#125;\n\n线程安全的懒汉式懒汉式单例如何保证线程安全呢？通过 synchronized 关键字加锁保证线程\n安全， synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这\n⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时\n都需要加锁和释放锁，这样是⾮常影响性能的。\n\n优点：懒加载，线程安全\n\n缺点：效率较低\n\n\n//懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public synchronized static Singleton getInstance() &#123;\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n    &#125;\n&#125;\n\n双重检查锁(DCL)这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么\n要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就\n不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进\n⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调\n⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同\n步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创\n建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单\n例。\n关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁\n竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对\n象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返\n回已创建的单例对象。\n其中最关键的⼀个点就是 volatile 关键字的使⽤，关于 volatile 的详细介\n绍可以直接搜索 volatile 关键字即可，有很多写的⾮常好的⽂章，这⾥不做\n详细介绍，简单说明⼀下，双重检查锁中使⽤ volatile 的两个重要特性：\n可⻅性、禁⽌指令重排序\n当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令\n的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对\nvolatile 修饰的变量的修改对其他任何线程都是可⻅的\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private volatile static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 第⼀重检查是否为 null\n if (instance == null) &#123;\n // 使⽤ synchronized 加锁\n synchronized (Singleton.class) &#123;\n // 第⼆重检查是否为 null\n     if (instance == null) &#123;\n // new 关键字创建对象不是原⼦操作\n instance = new Singleton();\n\t \t\t&#125;\n \t\t&#125;\n \t&#125;\n return instance;\n \t&#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼\n\n缺点：实现较复杂\n\n\n静态内部类//静态内部类实现单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、对外提供获取实例的公共⽅法\n public static Singleton getInstance() &#123;\n return InnerClass.INSTANCE;\n     \n // 定义静态内部类\n private static class InnerClass&#123;\n private final static Singleton INSTANCE = new\nSingleton();\n &#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼，实现简单\n\n静态内部类单例是如何实现懒加载的呢？⾸先，我们先了解下类的加载时机。虚拟机规范要求有且只有 5 种情况必须⽴即对类进⾏初始化（加载、验证、准备需要在此之前开始）：\n\n遇到 new 、 getstatic 、 putstatic 、 invokestatic 这 4 条字节码指令时。⽣成这 4 条指令最常⻅的 Java 代码场景是：使⽤ new 关键字实例化对象的时候、读取或设置⼀个类的静态字段（final 修饰除外，被final 修饰的静态字段是常量，已在编译期把结果放⼊常量池）的时候，以及调⽤⼀个类的静态⽅法的时候。\n使⽤ java.lang.reflect 包⽅法对类进⾏反射调⽤的时候。\n当初始化⼀个类的时候，如果发现其⽗类还没有进⾏过初始化，则需要先触发其⽗类的初始化。\n当虚拟机启动时，⽤户需要指定⼀个要执⾏的主类（包含 main()的那个类），虚拟机会先初始化这个主类。\n当使⽤ JDK 1.7 的动态语⾔⽀持时，如果⼀个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_getStatic 、 REF_putStatic 、 REF_invokeStatic 的⽅法句柄，则需要先触发这个⽅法句柄所对应的类的初始化。\n\n这 5 种情况被称为是类的主动引⽤，注意，这⾥《虚拟机规范》中使⽤的限定词是 “有且仅有”，那么，除此之外的所有引⽤类都不会对类进⾏初始化，称为被动引⽤。静态内部类就属于被动引⽤的情况。\n当 getInstance()⽅法被调⽤时，InnerClass 才在 Singleton 的运⾏时常量池⾥，把符号引⽤替换为直接引⽤，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()⽅法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中⼜是如何保证线程安全的呢？\n虚拟机会保证⼀个类的 () ⽅法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个类的 () ⽅法，其他线程都需要阻塞等待，直到活动线程执⾏() ⽅法完毕。如果在⼀个类的 () ⽅法中有耗时很⻓的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执⾏ () ⽅法后，其他线程唤醒之后不会再次进⼊ () ⽅法。同⼀个加载器下，⼀个类型只会初始化⼀次。)，在实际应⽤中，这种阻塞往往是很隐蔽的。\n所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯⼀性，同时也延迟了单例的实例化。\n枚举单例//枚举实现单例\npublic enum Singleton &#123;\n INSTANCE;\n public void doSomething(String str) &#123;\n System.out.println(str);\n &#125;\n&#125;\n\n\n优点：简单，⾼效，线程安全，可以避免通过反射破坏枚举单例\n\n枚举在 java 中与普通类⼀样，都能拥有字段与⽅法，⽽且枚举实例创建是线程安全的，在任何情况下，它都是⼀个单例，可以直接通过如下⽅式调⽤获取实例：\nSingleton singleton = Singleton.INSTANCE;\n使⽤下⾯的命令反编译枚举类\njavap Singleton.class\n得到如下内容\nCompiled from \"Singleton.java\"\npublic final class com.spring.demo.singleton.Singleton\nextends\njava.lang.Enum&lt;com.spring.demo.singleton.Singleton> &#123;\n public static final\ncom.spring.demo.singleton.Singleton INSTANCE;\n public static com.spring.demo.singleton.Singleton[]\nvalues();\n public static com.spring.demo.singleton.Singleton\nvalueOf(java.lang.String);\n public void doSomething(java.lang.String);\n static &#123;&#125;;\n&#125;\n\n从枚举的反编译结果可以看到，INSTANCE 被 static final 修饰，所以可以通过类名直接调⽤，因为static 类型的属性会在类被加载之后被初始化，当⼀个 Java 类第⼀次被真正使⽤到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的，所以创建⼀个 enum 类型是线程安全的。\n通过反射破坏枚举，实现代码如下：public class Test &#123;\n public static void main(String[] args) throws\nException &#123;\n Singleton singleton = Singleton.INSTANCE;\n singleton.doSomething(\"hello enum\");\n // 尝试使⽤反射破坏单例\n // 枚举类没有空参构造⽅法，反编译后可以看到枚举有⼀个两个\n参数的构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(String.class,\nint.class);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例，这⾥会报错，因为⽆法通过反射创建枚举的实例\n Singleton enumSingleton =\ndeclaredConstructor.newInstance();\n System.out.println(enumSingleton);\n &#125;\n&#125;\n\n运⾏结果报如下错误：\nException in thread \"main\"\njava.lang.IllegalArgumentException: Cannot reflectively\ncreate enum objects at\njava.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492) \nat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\nat com.spring.demo.singleton.Test.main(Test.java:24)\n\n所以⽆法通过反射创建枚举的实例。\n","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"064fd1f961f785b45ddfca5b3ce563ee","title":"spring事务失效的情况以及注意事项","content":"什么是spring事务？​\tSpring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。\n​\tSpring事务的核心思想是将事务管理从具体的数据访问代码中抽象出来。Spring提供了一种集中式的方式来管理事务，这使得我们可以在不修改具体数据访问代码的情况下轻松地添加或删除事务。\nspring事务的优点Spring事务具有以下优点：\n简单性 - Spring事务使得事务管理变得非常简单，只需要添加少量的注释就可以实现。\n可扩展性 - Spring事务提供了各种事务管理器，以适应各种不同的事务需求。它还允许我们自行扩展和定制事务管理器。\n独立性 - Spring事务提供了一种与底层数据访问技术无关的事务管理方式，因此我们可以轻松地更改数据库，而不需要更改事务管理方式。\nspring事务的类型Spring事务有以下常见的类型：\n\n声明式事务 - 该类型的事务是在配置文件或注释中声明的。这使得我们可以轻松地添加和删除事务。\n编程式事务 - 该类型的事务是通过编写代码来实现的。它提供了更细粒度的控制和更高的自定义程度。但是，编写代码会使得代码复杂化。\n\nspring事务失效的情况事务失效的八种场景1.抛出检查异常导致事务不能正确回滚补充什么是检查异常：\nJava中的异常分为两种类型：检查异常和非检查异常。\n检查异常需要使用try-catch语句或者throws声明来处理或抛出，否则编译器会报错。这种异常通常表示程序运行时必须解决的某些错误或不合法操作。例如：IOException、SQLException、ClassNotFoundException等。\n非检查异常是指RuntimeException及其子类异常，不需要在代码中进行特殊处理，程序在运行期间出现这种异常时，会自动触发JVM的异常处理机制。这种异常通常表示程序出现了逻辑或编程错误。例如：NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。\n@Service\npublic class Service1 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n无法事务回滚：Spring默认只会回滚非检查异常\n\n解法：\n配置rollbackFor属性 (什么错误需要回滚)：\n @Transactional(rollbackFor = Exception.class)\n\n\n2.方法内自己try-catch异常导致事务不能正确回滚@Service\npublic class Service2 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount)  &#123;\n        try &#123;\n            int fromBalance = accountMapper.findBalanceBy(from);\n            if (fromBalance - amount >= 0) &#123;\n                accountMapper.update(from, -1 * amount);\n                new FileInputStream(\"hj\");\n                accountMapper.update(to, amount);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n原因：事务通知只有捕捉到了目标方法抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉\n\n方法1：将catch到的异常，包装成运行时异常抛出\n\n在catch块里throw new RuntimeException(e);\n\n\n方法2：手动设置回滚\n\n在catch块添加\nTransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n\n\n\n\n3.aop切面顺序异常导致事务不能正确回滚@Service\npublic class Service3 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n@Aspect\npublic class MyAspect &#123;\n    @Around(\"execution(* transfer(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        LoggerUtils.get().debug(\"log:&#123;&#125;\", pjp.getTarget());\n        try &#123;\n            return pjp.proceed();\n        &#125; catch (Throwable e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.非public方法导致事务失效@Service\npublic class Service4 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n原因：Spring为方法创建代理，添加事务通知，前提条件都是方法为public\n\n方法1：方法改为public\n\n方法2：添加bean配置，不推荐使用\n\n@Bean\npublic TransactionAttributeSource transactionAttributeSource() &#123;\n    return new AnnotationTransactionAttributeSource(false);\n&#125;\n\n\n\n\n\n​\t拓展：AnnotationTransactionAttributeSource\n​\t\tAnnotationTransactionAttributeSource是Spring事务框架中的一个类，用于解析@Transactional注解并以此为基础生成TransactionAttribute对象。TransactionAttribute对象描述了一段方法执行时应该使用的事务属性，包括事务的名字、传播行为、隔离级别、超时时间、只读属性等。\n​\t\t在Spring的事务管理中，事务切面对象会调用AnnotationTransactionAttributeSource对象的getTransactionAttribute()方法，从而获取方法或类级别的事务属性。这种方式可以将事务属性与具体的业务代码解耦，使得业务代码更加简洁可读。\n​\t\tAnnotationTransactionAttributeSource对象有一个布尔类型的构造函数参数，它用于控制@Transactional注解的解析方式。如果这个参数为false，则AnnotationTransactionAttributeSource只会解析@Transactional注解，而不会考虑继承和重载关系，即只解析被注解类或方法上的@Transactional注解，而不考虑其基类和子类以及重载方法中的@Transactional注解。\n​\t\t默认情况下AnnotationTransactionAttributeSource对象的构造函数参数是true，即支持继承和重载的注解解析。但是，在某些特殊情况下，这种解析方式可能会导致一些问题，如事务传播、超时等不被正确解析。此时，可以通过设置构造函数参数为false来禁用这种解析机制，以确保正确地解析@Transactional注解。\n5.父子容器导致的事务失效6.调用本类方法导致传播行为失效7.@Transactional没有保证原子行为8.@Transactional方法导致的synchronized失效","slug":"Spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","categories_index":"","tags_index":"Java,tx,Spring","author_index":"大宝贝的程序员"},{"id":"94364c933b9df4578d2492ddcb35178f","title":"How to use Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nmyHexoCreate a new post$ hexo new \"title\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"}]