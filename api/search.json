[{"id":"3dbdc722104d94fc07273118e255f7fd","title":"工厂模式","content":"工厂模式简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数\n简单工厂UML类图\n\n适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需\n要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较\n复杂。\n简单工厂的例子\nCalendar类的getInstance方法使用了一种简单工厂的方式来创建不同地区的日历对象。\n具体来说，Calendar类本身是一个抽象类，它定义了一些方法来处理日期和时间。由于不同地区有不同的日历，因此Calendar类并没有直接实现具体的日历，而是通过getInstance方法来获取指定地区的Calendar实例。getInstance方法接受一个Locale类型的参数，它根据不同的Locale参数调用createCalendar方法创建具体的日历实例。createCalendar方法是一个protected方法，由Calendar类的子类来实现。在具体的子类中，根据传入的Locale参数创建相应的日历对象，然后返回。这里，createCalendar方法就扮演了一个简单工厂模式中的工厂的角色，而Calendar类则相当于一个创建工厂，负责整个日历对象的生成过程的调度。\n工厂方法模式在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是提供一个工厂接口，由不同的子类来实现工厂接口中的方法来创建不同的对象。这样做的好处是增加了系统的扩展性和灵活性，可以根据实际需求来增加相应的子类和工厂实现。\n工厂方法模式通常由四部分组成：抽象产品、具体产品、抽象工厂、具体工厂。其中，抽象产品是需要创建的对象的通用接口，具体产品是实现抽象产品接口的具体类，抽象工厂是创建产品的接口，具体工厂是实现抽象工厂接口的具体类。\n工厂方法UML类图：\n\n使用工厂方法模式的好处是：\n\n可扩展性更好。使用工厂方法模式可以更加容易地扩展和添加新的产品类，而不会影响原有的代码结构。\n\n易于维护。工厂方法模式将创建对象的代码集中在一个地方，易于维护。当需要修改时，只需要修改对应的工厂类即可，而不需要修改客户端代码。\n\n降低耦合度。使用工厂方法模式可以将客户端代码和具体产品的实现解耦，使得客户端代码不需要了解每个具体产品类的细节。\n\n\n抽象工厂方法模式抽象工厂模式是工厂方法模式的扩展，旨在提供一个工厂接口来创建一系列相关的产品，而不是单一的产品类。\n抽象工厂模式中会存在多个产品族，每个产品族包含多个产品等级结构。产品等级结构是指具有相同功能的产品组成的集合，例如大众汽车、奥迪汽车和奔驰汽车组成了一个产品族，而每种汽车都具有车轮、车身和发动机等等组成的产品等级结构。\n在抽象工厂模式中，定义一个抽象工厂接口，它包含了一组用于创建产品族中每个产品等级结构的方法。每个具体的工厂类实现这个接口，负责实现自己的产品族生产过程。而具体产品则由具体工厂类中的具体方法实现来创建。\n通过抽象工厂模式，我们可以创造一个家族的对象，这个家族可以看做是一个产品族，而每个家族成员可以看做是这个产品族中的某个产品等级结构。抽象工厂模式保证了各种产品之间的兼容性，即一个工厂创建的产品都是该工厂创建的其他产品的兼容组合。\n抽象工厂UML类图：\n\n示例代码:首先是汽车工厂的抽象类（Abstract Factory）：\n// 定义汽车工厂的抽象类\nabstract class CarFactory &#123;\n    abstract Wheel createWheel();\n    abstract Body createBody();\n    abstract Engine createEngine();\n&#125;\n\n然后是具体的大众汽车工厂类（Volkswagen Car Factory）和奥迪汽车工厂类（Audi Car Factory）：\n// 定义大众汽车工厂\nclass VolkswagenFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new VolkswagenWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new VolkswagenBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new VolkswagenEngine();\n    &#125;\n&#125;\n\n// 定义奥迪汽车工厂\nclass AudiFactory extends CarFactory &#123;\n    @Override\n    public Wheel createWheel() &#123;\n        return new AudiWheel();\n    &#125;\n    @Override\n    public Body createBody() &#123;\n        return new AudiBody();\n    &#125;\n    @Override\n    public Engine createEngine() &#123;\n        return new AudiEngine();\n    &#125;\n&#125;\n\n然后是汽车组件的抽象类（Abstract Product）：\n// 定义汽车的组件抽象类\nabstract class Wheel &#123;\n    public abstract void create();\n&#125;\nabstract class Body &#123;\n    public abstract void create();\n&#125;\nabstract class Engine &#123;\n    public abstract void create();\n&#125;\n\n具体的大众和奥迪汽车组件的类：\n// 定义大众汽车组件\nclass VolkswagenWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车轮\");\n    &#125;\n&#125;\nclass VolkswagenBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众车身\");\n    &#125;\n&#125;\nclass VolkswagenEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产大众发动机\");\n    &#125;\n&#125;\n\n// 定义奥迪汽车组件\nclass AudiWheel extends Wheel &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车轮\");\n    &#125;\n&#125;\nclass AudiBody extends Body &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪车身\");\n    &#125;\n&#125;\nclass AudiEngine extends Engine &#123;\n    @Override\n    public void create() &#123;\n        System.out.println(\"生产奥迪发动机\");\n    &#125;\n&#125;\n\n最后，我们可以使用这些类来创建不同品牌的汽车：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        // 创建大众汽车\n        CarFactory vwFactory = new VolkswagenFactory();\n        vwFactory.createWheel().create();\n        vwFactory.createBody().create();\n        vwFactory.createEngine().create();\n        \n        // 创建奥迪汽车\n        CarFactory audiFactory = new AudiFactory();\n        audiFactory.createWheel().create();\n        audiFactory.createBody().create();\n        audiFactory.createEngine().create();\n    &#125;\n&#125;\n\n","slug":"工厂模式","date":"2023-05-09T05:19:32.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"b00cac0eae3b04411014ea36945005af","title":"建造者模式","content":"Java建造者模式Java中的建造者模式(Builder Pattern)\n主要用于创建一个复杂对象，它通过一步一步地构建，可以创建出不同的对象表示。\n该模式包含以下几个角色：\n\nBuilder(建造者)：抽象建造者，定义创建对象的接口，并包含返回建造产品的方法。\n\nConcreteBuilder(具体建造者)：实现Builder接口，实现具体产品的创建过程，以及返回具体产品的方法。\n\nDirector(导演者)：负责调用建造者生成产品。\n\nProduct(产品)：表示被生成的复杂对象，包含多个部件。\n\n\n以下是Java中的建造者模式示例代码：\n// Product\nclass Car &#123;\n    private String engine;\n    private String chassis;\n    private String body;\n\n    public void setEngine(String engine) &#123;\n        this.engine = engine;\n    &#125;\n\n    public void setChassis(String chassis) &#123;\n        this.chassis = chassis;\n    &#125;\n\n    public void setBody(String body) &#123;\n        this.body = body;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Car &#123;engine='\" + engine + \"', chassis='\" + chassis + \"', body='\" + body + \"'&#125;\";\n    &#125;\n&#125;\n\n// Builder\ninterface CarBuilder &#123;\n    void buildEngine();\n    void buildChassis();\n    void buildBody();\n    Car getCar();\n&#125;\n\n// ConcreteBuilders\nclass SportsCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SportsCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"3.0L V6\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Aluminum\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Carbon Fiber\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\nclass SedanCarBuilder implements CarBuilder &#123;\n    private Car car;\n\n    public SedanCarBuilder() &#123;\n        this.car = new Car();\n    &#125;\n\n    @Override\n    public void buildEngine() &#123;\n        car.setEngine(\"2.4L 4-cylinder\");\n    &#125;\n\n    @Override\n    public void buildChassis() &#123;\n        car.setChassis(\"Steel\");\n    &#125;\n\n    @Override\n    public void buildBody() &#123;\n        car.setBody(\"Metal\");\n    &#125;\n\n    @Override\n    public Car getCar() &#123;\n        return this.car;\n    &#125;\n&#125;\n\n\n// Director\nclass AutomotiveEngineer &#123;\n    public void build (CarBuilder builder) &#123;\n        builder.buildEngine();\n        builder.buildChassis();\n        builder.buildBody();\n    &#125;\n&#125;\n\npublic class BuilderPatternExample &#123;\n    public static void main(String[] args) &#123;\n        AutomotiveEngineer engineer = new AutomotiveEngineer();\n\n        CarBuilder sportsCarBuilder = new SportsCarBuilder();\n        engineer.build (sportsCarBuilder);\n        System.out.println(sportsCarBuilder.getCar()); \n        // Output: Car &#123;engine='3.0L V6', chassis='Aluminum', body='Carbon Fiber'&#125;\n\n        CarBuilder sedanCarBuilder = new SedanCarBuilder();\n        engineer.build (sedanCarBuilder);\n        System.out.println(sedanCarBuilder.getCar()); \n        // Output: Car &#123;engine='2.4L 4-cylinder', chassis='Steel', body='Metal'&#125;\n    &#125;\n&#125;\n\n在这个示例中，CarBuilder表示抽象建造者，SportsCarBuilder和SedanCarBuilder分别表示具体建造者，AutomotiveEngineer表示导演者，Car表示产品。通过导演者调用具体建造者的构建方法，即可建造出不同的Car实例。\n它的主要亮点有三处：\n\n较为灵活的构建产品对象\n\n在不执行最后 build 方法前，产品对象都不可用\n\n构建过程采用链式调用，看起来比较爽\n\n\n","slug":"建造者模式","date":"2023-05-09T04:38:15.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"0c6e8405652937a86cc3782f838cf782","title":"spring中常见的设计模式","content":"Spring中常见的设计模式1.Spring中的单例模式单例模式 与 单例bean 的区别\n\n根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it\n\n就是确保只有一个实例提供给全局使用\n\n显然Spring中的单例bean并非实现了单例模式，单例bean只能保证每个容器内，相同id的bean单实例\n Spring中也有用到单例模式\n\norg.springframework.transaction.TransactionDefinition#withDefaults\n\norg.springframework.aop.TruePointcut#INSTANCE\n\norg.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR\n\norg.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE\n\norg.springframework.core.OrderComparator#INSTANCE\n\n\n2.Spring中的Builder（建造者模式）定义 Separate the construction of a complex object from its representation so that the same construction process can create different representations 即将复杂对象的构建与其表示分离，以便同样的构建过程可以创建不同的表示形式。\n优点：\n\n较为灵活的构建产品对象\n在不执行最后 build 方法前，产品对象都不可用\n构建过程采用链式调用，看起来比较爽\n\nSpring 中体现 Builder 模式的地方：\n\norg.springframework.beans.factory.support.BeanDefinitionBuilder\norg.springframework.web.util.UriComponentsBuilder\norg.springframework.http.ResponseEntity.HeadersBuilder\norg.springframework.http.ResponseEntity.BodyBuilder\n\n3.Spring中的Factory Method(工厂方法模式)定义Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses  即一个创建对象的接口，但是让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到其子类中进行。\nSpring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现\nSpring 中其它工厂：\n\norg.springframework.beans.factory.FactoryBean\n\n@Bean 标注的静态方法及实例方法\n\nObjectFactory 及 ObjectProvider\n\n\n前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题\n4.Spring中的Adapter(适配器模式)定义 Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces 即 将一个类的接口转换为另一个客户端所期望的接口。适配器模式可以让原本由于接口不兼容而无法一起工作的类能够协同工作。\n","slug":"spring中的设计模式","date":"2023-05-09T04:00:50.000Z","categories_index":"","tags_index":"Java,设计模式,Spring","author_index":"大宝贝的程序员"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"什么是单例模式？单例模式的特点是什么？单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，\n构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀\n个静态公有⽅法获取实例。\n优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的\n情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，\n与单⼀职责原则冲突。\n单例模式的常⻅写法有哪些？饿汉式顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间。\n\n优点：线程安全，没有加锁，执⾏效率较⾼\n\n缺点：不是懒加载，类加载时就初始化，浪费内存空间\n\n\n\n线程安全：饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程\n的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。\n\n\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123;&#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private final static Singleton instance = new\nSingleton();\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n return instance;\n &#125;\n&#125;\n\n使⽤反射破坏单例public class Test &#123;\n public static void main(String[] args) throws\nException&#123;\n // 使⽤反射破坏单例\n // 获取空参构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(null);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例\n Singleton singleton =\ndeclaredConstructor.newInstance();\n System.out.println(\"反射创建的实例\" + singleton);\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n System.out.println(\"正常创建的实例\" +\nSingleton.getInstance());\n &#125;\n&#125;\n\n输出结果如下反射创建的实例\ncom.example.spring.demo.single.Singleton@6267c3bb\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n正常创建的实例\ncom.example.spring.demo.single.Singleton@533ddba\n\n线程不安全的懒汉式这种⽅式在单线程下使⽤没有问题，对于多线程是⽆法保证单例的，这⾥列出来是为了和后⾯使⽤锁保证线程安全的单例做对⽐\n\n优点：懒加载\n缺点：线程不安全\n\n//线程不安全的懒汉式单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 判断为 null 的时候再创建对象\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n &#125;\n&#125;\n\n线程安全的懒汉式懒汉式单例如何保证线程安全呢？通过 synchronized 关键字加锁保证线程\n安全， synchronized 可以添加在⽅法上⾯，也可以添加在代码块上⾯，这\n⾥演示添加在⽅法上⾯，存在的问题是 每⼀次调⽤ getInstance 获取实例时\n都需要加锁和释放锁，这样是⾮常影响性能的。\n\n优点：懒加载，线程安全\n\n缺点：效率较低\n\n\n//懒汉式单例，⽅法上⾯添加 synchronized 保证线程安全\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton()&#123; &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public synchronized static Singleton getInstance() &#123;\n if (instance == null) &#123;\n instance = new Singleton();\n &#125;\n return instance;\n    &#125;\n&#125;\n\n双重检查锁(DCL)这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么\n要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就\n不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进\n⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调\n⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同\n步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创\n建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单\n例。\n关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁\n竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对\n象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返\n回已创建的单例对象。\n其中最关键的⼀个点就是 volatile 关键字的使⽤，关于 volatile 的详细介\n绍可以直接搜索 volatile 关键字即可，有很多写的⾮常好的⽂章，这⾥不做\n详细介绍，简单说明⼀下，双重检查锁中使⽤ volatile 的两个重要特性：\n可⻅性、禁⽌指令重排序\n当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令\n的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对\nvolatile 修饰的变量的修改对其他任何线程都是可⻅的\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、定义⼀个静态变量指向⾃⼰类型\n private volatile static Singleton instance;\n // 3、对外提供⼀个公共的⽅法获取实例\n public static Singleton getInstance() &#123;\n // 第⼀重检查是否为 null\n if (instance == null) &#123;\n // 使⽤ synchronized 加锁\n synchronized (Singleton.class) &#123;\n // 第⼆重检查是否为 null\n     if (instance == null) &#123;\n // new 关键字创建对象不是原⼦操作\n instance = new Singleton();\n\t \t\t&#125;\n \t\t&#125;\n \t&#125;\n return instance;\n \t&#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼\n\n缺点：实现较复杂\n\n\n静态内部类//静态内部类实现单例\npublic class Singleton &#123;\n // 1、私有化构造⽅法\n private Singleton() &#123;\n &#125;\n // 2、对外提供获取实例的公共⽅法\n public static Singleton getInstance() &#123;\n return InnerClass.INSTANCE;\n     \n // 定义静态内部类\n private static class InnerClass&#123;\n private final static Singleton INSTANCE = new\nSingleton();\n &#125;\n&#125;\n\n\n优点：懒加载，线程安全，效率较⾼，实现简单\n\n静态内部类单例是如何实现懒加载的呢？⾸先，我们先了解下类的加载时机。虚拟机规范要求有且只有 5 种情况必须⽴即对类进⾏初始化（加载、验证、准备需要在此之前开始）：\n\n遇到 new 、 getstatic 、 putstatic 、 invokestatic 这 4 条字节码指令时。⽣成这 4 条指令最常⻅的 Java 代码场景是：使⽤ new 关键字实例化对象的时候、读取或设置⼀个类的静态字段（final 修饰除外，被final 修饰的静态字段是常量，已在编译期把结果放⼊常量池）的时候，以及调⽤⼀个类的静态⽅法的时候。\n使⽤ java.lang.reflect 包⽅法对类进⾏反射调⽤的时候。\n当初始化⼀个类的时候，如果发现其⽗类还没有进⾏过初始化，则需要先触发其⽗类的初始化。\n当虚拟机启动时，⽤户需要指定⼀个要执⾏的主类（包含 main()的那个类），虚拟机会先初始化这个主类。\n当使⽤ JDK 1.7 的动态语⾔⽀持时，如果⼀个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_getStatic 、 REF_putStatic 、 REF_invokeStatic 的⽅法句柄，则需要先触发这个⽅法句柄所对应的类的初始化。\n\n这 5 种情况被称为是类的主动引⽤，注意，这⾥《虚拟机规范》中使⽤的限定词是 “有且仅有”，那么，除此之外的所有引⽤类都不会对类进⾏初始化，称为被动引⽤。静态内部类就属于被动引⽤的情况。\n当 getInstance()⽅法被调⽤时，InnerClass 才在 Singleton 的运⾏时常量池⾥，把符号引⽤替换为直接引⽤，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()⽅法返回出去，这点同饿汉模式。\n那么 INSTANCE 在创建过程中⼜是如何保证线程安全的呢？\n虚拟机会保证⼀个类的 () ⽅法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个类的 () ⽅法，其他线程都需要阻塞等待，直到活动线程执⾏() ⽅法完毕。如果在⼀个类的 () ⽅法中有耗时很⻓的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执⾏ () ⽅法后，其他线程唤醒之后不会再次进⼊ () ⽅法。同⼀个加载器下，⼀个类型只会初始化⼀次。)，在实际应⽤中，这种阻塞往往是很隐蔽的。\n所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯⼀性，同时也延迟了单例的实例化。\n枚举单例//枚举实现单例\npublic enum Singleton &#123;\n INSTANCE;\n public void doSomething(String str) &#123;\n System.out.println(str);\n &#125;\n&#125;\n\n\n优点：简单，⾼效，线程安全，可以避免通过反射破坏枚举单例\n\n枚举在 java 中与普通类⼀样，都能拥有字段与⽅法，⽽且枚举实例创建是线程安全的，在任何情况下，它都是⼀个单例，可以直接通过如下⽅式调⽤获取实例：\nSingleton singleton = Singleton.INSTANCE;\n使⽤下⾯的命令反编译枚举类\njavap Singleton.class\n得到如下内容\nCompiled from \"Singleton.java\"\npublic final class com.spring.demo.singleton.Singleton\nextends\njava.lang.Enum&lt;com.spring.demo.singleton.Singleton> &#123;\n public static final\ncom.spring.demo.singleton.Singleton INSTANCE;\n public static com.spring.demo.singleton.Singleton[]\nvalues();\n public static com.spring.demo.singleton.Singleton\nvalueOf(java.lang.String);\n public void doSomething(java.lang.String);\n static &#123;&#125;;\n&#125;\n\n从枚举的反编译结果可以看到，INSTANCE 被 static final 修饰，所以可以通过类名直接调⽤，因为static 类型的属性会在类被加载之后被初始化，当⼀个 Java 类第⼀次被真正使⽤到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的，所以创建⼀个 enum 类型是线程安全的。\n通过反射破坏枚举，实现代码如下：public class Test &#123;\n public static void main(String[] args) throws\nException &#123;\n Singleton singleton = Singleton.INSTANCE;\n singleton.doSomething(\"hello enum\");\n // 尝试使⽤反射破坏单例\n // 枚举类没有空参构造⽅法，反编译后可以看到枚举有⼀个两个\n参数的构造⽅法\n Constructor&lt;Singleton> declaredConstructor =\nSingleton.class.getDeclaredConstructor(String.class,\nint.class);\n // 设置强制访问\n declaredConstructor.setAccessible(true);\n // 创建实例，这⾥会报错，因为⽆法通过反射创建枚举的实例\n Singleton enumSingleton =\ndeclaredConstructor.newInstance();\n System.out.println(enumSingleton);\n &#125;\n&#125;\n\n运⾏结果报如下错误：\nException in thread \"main\"\njava.lang.IllegalArgumentException: Cannot reflectively\ncreate enum objects at\njava.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492) \nat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)\nat com.spring.demo.singleton.Test.main(Test.java:24)\n\n所以⽆法通过反射创建枚举的实例。\n","slug":"单例模式","date":"2023-05-08T13:10:28.000Z","categories_index":"","tags_index":"Java,设计模式","author_index":"大宝贝的程序员"},{"id":"064fd1f961f785b45ddfca5b3ce563ee","title":"spring事务失效的情况以及注意事项","content":"什么是spring事务？​\tSpring Framework提供了一种简单而强大的机制来管理事务，这个机制被称为Spring事务。Spring事务是在Java应用程序中管理数据库事务的一种强大的方法。在Spring事务中，所有的数据库访问是在事务管理器的上下文中进行的。\n​\tSpring事务的核心思想是将事务管理从具体的数据访问代码中抽象出来。Spring提供了一种集中式的方式来管理事务，这使得我们可以在不修改具体数据访问代码的情况下轻松地添加或删除事务。\nspring事务的优点Spring事务具有以下优点：\n简单性 - Spring事务使得事务管理变得非常简单，只需要添加少量的注释就可以实现。\n可扩展性 - Spring事务提供了各种事务管理器，以适应各种不同的事务需求。它还允许我们自行扩展和定制事务管理器。\n独立性 - Spring事务提供了一种与底层数据访问技术无关的事务管理方式，因此我们可以轻松地更改数据库，而不需要更改事务管理方式。\nspring事务的类型Spring事务有以下常见的类型：\n\n声明式事务 - 该类型的事务是在配置文件或注释中声明的。这使得我们可以轻松地添加和删除事务。\n编程式事务 - 该类型的事务是通过编写代码来实现的。它提供了更细粒度的控制和更高的自定义程度。但是，编写代码会使得代码复杂化。\n\nspring事务失效的情况事务失效的八种场景1.抛出检查异常导致事务不能正确回滚补充什么是检查异常：\nJava中的异常分为两种类型：检查异常和非检查异常。\n检查异常需要使用try-catch语句或者throws声明来处理或抛出，否则编译器会报错。这种异常通常表示程序运行时必须解决的某些错误或不合法操作。例如：IOException、SQLException、ClassNotFoundException等。\n非检查异常是指RuntimeException及其子类异常，不需要在代码中进行特殊处理，程序在运行期间出现这种异常时，会自动触发JVM的异常处理机制。这种异常通常表示程序出现了逻辑或编程错误。例如：NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。\n@Service\npublic class Service1 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n无法事务回滚：Spring默认只会回滚非检查异常\n\n解法：\n配置rollbackFor属性 (什么错误需要回滚)：\n @Transactional(rollbackFor = Exception.class)\n\n\n2.方法内自己try-catch异常导致事务不能正确回滚@Service\npublic class Service2 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount)  &#123;\n        try &#123;\n            int fromBalance = accountMapper.findBalanceBy(from);\n            if (fromBalance - amount >= 0) &#123;\n                accountMapper.update(from, -1 * amount);\n                new FileInputStream(\"hj\");\n                accountMapper.update(to, amount);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n原因：事务通知只有捕捉到了目标方法抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉\n\n方法1：将catch到的异常，包装成运行时异常抛出\n\n在catch块里throw new RuntimeException(e);\n\n\n方法2：手动设置回滚\n\n在catch块添加\nTransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n\n\n\n\n3.aop切面顺序异常导致事务不能正确回滚@Service\npublic class Service3 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            new FileInputStream(\"hj\");\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n@Aspect\npublic class MyAspect &#123;\n    @Around(\"execution(* transfer(..))\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        LoggerUtils.get().debug(\"log:&#123;&#125;\", pjp.getTarget());\n        try &#123;\n            return pjp.proceed();\n        &#125; catch (Throwable e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.非public方法导致事务失效@Service\npublic class Service4 &#123;\n\n    @Autowired\n    private AccountMapper accountMapper;\n\n    @Transactional\n    void transfer(int from, int to, int amount) throws FileNotFoundException &#123;\n        int fromBalance = accountMapper.findBalanceBy(from);\n        if (fromBalance - amount >= 0) &#123;\n            accountMapper.update(from, -1 * amount);\n            accountMapper.update(to, amount);\n        &#125;\n    &#125;\n&#125;\n\n\n原因：Spring为方法创建代理，添加事务通知，前提条件都是方法为public\n\n方法1：方法改为public\n\n方法2：添加bean配置，不推荐使用\n\n@Bean\npublic TransactionAttributeSource transactionAttributeSource() &#123;\n    return new AnnotationTransactionAttributeSource(false);\n&#125;\n\n\n\n\n\n​\t拓展：AnnotationTransactionAttributeSource\n​\t\tAnnotationTransactionAttributeSource是Spring事务框架中的一个类，用于解析@Transactional注解并以此为基础生成TransactionAttribute对象。TransactionAttribute对象描述了一段方法执行时应该使用的事务属性，包括事务的名字、传播行为、隔离级别、超时时间、只读属性等。\n​\t\t在Spring的事务管理中，事务切面对象会调用AnnotationTransactionAttributeSource对象的getTransactionAttribute()方法，从而获取方法或类级别的事务属性。这种方式可以将事务属性与具体的业务代码解耦，使得业务代码更加简洁可读。\n​\t\tAnnotationTransactionAttributeSource对象有一个布尔类型的构造函数参数，它用于控制@Transactional注解的解析方式。如果这个参数为false，则AnnotationTransactionAttributeSource只会解析@Transactional注解，而不会考虑继承和重载关系，即只解析被注解类或方法上的@Transactional注解，而不考虑其基类和子类以及重载方法中的@Transactional注解。\n​\t\t默认情况下AnnotationTransactionAttributeSource对象的构造函数参数是true，即支持继承和重载的注解解析。但是，在某些特殊情况下，这种解析方式可能会导致一些问题，如事务传播、超时等不被正确解析。此时，可以通过设置构造函数参数为false来禁用这种解析机制，以确保正确地解析@Transactional注解。\n5.父子容器导致的事务失效6.调用本类方法导致传播行为失效7.@Transactional没有保证原子行为8.@Transactional方法导致的synchronized失效","slug":"spring事务失效的情况以及注意事项","date":"2023-05-07T12:31:38.000Z","categories_index":"","tags_index":"Java,tx,Spring","author_index":"大宝贝的程序员"},{"id":"94364c933b9df4578d2492ddcb35178f","title":"How to use Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nmyHexoCreate a new post$ hexo new \"title\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-06T09:17:31.212Z","categories_index":"","tags_index":"","author_index":"大宝贝的程序员"}]